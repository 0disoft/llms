# Deno 25H1 핵심 변경사항

---

## 서론

2025년 상반기(1월~6월)는 **Deno 런타임**과 그 주변 생태계에 있어 활발한 발전이 이루어진 시기였습니다. 이 기간 동안 Deno는 **2.2 및 2.3 버전**을 공식 릴리스했으며, **2.4 버전의 주요 기능들**이 상반기 기간 내에 발표되거나 논의되었습니다. 주요 변화의 초점은 **개발자 경험(DX) 개선, Node.js 및 npm 생태계와의 호환성 강화, 그리고 내장 도구(lint, fmt, compile, lsp)의 기능 및 성능 향상**에 맞춰져 있습니다. 또한, **Deno Deploy와 JSR(JavaScript Registry)** 같은 핵심 플랫폼 서비스도 꾸준히 발전했습니다. 이 보고서는 특히 코딩 구현 시 개발자들에게 직접적인 영향을 미치는 핵심 변경사항들을 심층적으로 분석하고, 그 의미와 활용 방안을 제시합니다.

Deno는 Node.js의 문제점을 해결하고 **"더 나은" JavaScript 런타임**을 만들겠다는 야심찬 비전으로 시작했습니다. 이는 내장된 툴링(lint, fmt, test), 보안 기본값, 그리고 TypeScript 네이티브 지원 등을 통해 npm과 Node.js API 없이도 동작하는 새로운 생태계를 구축하려는 시도였습니다. 그러나 이러한 초기 비전은 광범위한 채택에 있어 큰 장벽으로 작용했습니다. **기존 JavaScript 생태계, 특히 npm 및 Node.js API와의 호환성 부족**은 개발자들이 기존 애플리케이션을 거의 재작성해야 하는 부담을 느끼게 했고, 대부분은 Node.js에 머물도록 했습니다. 예를 들어, Next.js와 같은 npm 중심 스택에서 Deno를 사용하는 것이 어렵다는 피드백도 있었습니다.

이러한 채택의 어려움을 인식하고, Deno는 **2024년 Deno 2.0 출시와 함께 Node.js 호환성에 대한 전략적 전환**을 단행했습니다. 이는 Bun과 같은 경쟁 런타임이 Node.js 호환성을 우선시한 것에 영향을 받았을 가능성이 높습니다. 2025년 상반기 변경사항들은 이러한 전략적 전환이 심화되고 있음을 명확히 보여줍니다.

**`deno compile`의 FFI(Foreign Function Interface) 및 Node Native Add-ons 지원**은 Deno가 단순히 Node.js API를 에뮬레이션하는 것을 넘어, Node.js의 핵심적인 확장 메커니즘까지 포용하려는 의지를 나타냅니다. 이는 기존 Node.js 프로젝트의 Deno 마이그레이션 장벽을 크게 낮추는 효과를 가져옵니다. 또한, **`deno.json` 파일의 `patch` 필드를 통한 로컬 npm 패키지 지원**은 `npm link`와 유사한 기능을 제공하여, npm 생태계에 깊이 의존하는 프로젝트들이 Deno 환경에서 로컬 개발 및 테스트를 훨씬 용이하게 합니다. 이는 "Deno 방식"으로 전환하기 어려운 기존 프로젝트들을 Deno로 끌어들이는 중요한 단계입니다.

명시적으로 Node.js 호환성 모드를 제공하는 **`DENO_COMPAT=1` 모드 지원**과, Deno 2부터 **npm specifier를 통한 npm 패키지 임포트를 권장하는 정책**은 Deno가 npm을 "퍼스트 클래스 시민"으로 대우하고 있음을 의미합니다.

**`node:sqlite` 모듈의 직접적인 지원** 및 **`node:fs`, `node:process`, `node:crypto` 등 Node.js API의 지속적인 개선**은 호환성 레이어의 견고함을 증명합니다. Deno는 **"기술적 우수성만으로는 성공할 수 없다"는 교훈을 받아들여**, 기존 Node.js 개발자들을 적극적으로 포용하고 마이그레이션 장벽을 낮추는 방향으로 전략을 수정하고 있습니다. 이는 Deno가 더 넓은 JavaScript/TypeScript 개발 커뮤니티에서 주류 런타임으로 자리매김하려는 강력한 의지를 보여주는 것으로 해석됩니다. 개발자 관점에서는, 이제 Deno를 사용할 때 Node.js 생태계의 풍부한 자원을 훨씬 더 원활하게 활용할 수 있게 되었다는 의미이며, 이는 Deno의 채택률 증가에 긍정적인 영향을 미칠 것으로 예상됩니다.

---

## 핵심 런타임 업데이트: Deno 코어

### Deno 2.2 릴리스 주요 변경사항 (2025년 2월)

Deno 2.2는 2025년 2월에 릴리스되었으며, OpenTelemetry 통합, 린터 개선, Node.js 호환성 강화 등 다양한 핵심 기능과 성능 향상을 포함합니다.

#### 내장 OpenTelemetry 통합 및 안정화

Deno 2.2는 로그, 메트릭, 트레이스 수집을 위한 **내장 OpenTelemetry 지원**을 도입했습니다. `console.log`, `Deno.serve`, `fetch`와 같은 API를 자동으로 계측(auto-instrument)하며, `npm:@opentelemetry/api` 패키지를 사용하여 사용자 정의 계측도 가능합니다. 데이터 캡처를 위해 OTLP 엔드포인트가 필요하며, **`--unstable-otel` 플래그와 `--allow-net` 권한**이 필요했습니다.

이러한 내장 OpenTelemetry 지원은 개발 워크플로우에 중요한 변화를 가져왔습니다. 전통적인 애플리케이션 개발에서 로깅, 모니터링, 트레이싱은 별도의 라이브러리 설치와 복잡한 설정이 필요했으며, 특히 분산 시스템에서는 트레이싱을 위한 컨텍스트 전파가 어려워 디버깅과 성능 분석에 많은 노력이 들었습니다. Deno 2.2는 OpenTelemetry를 내장하여 개발자가 별도의 설정 없이도 기본적인 관측 가능성 데이터를 얻을 수 있게 함으로써 이러한 문제를 해결했습니다. Deno 2.2.4(2025년 3월)에서는 Span Context Propagators 지원이 추가되었고, **`node:http.request`에 대한 OTel 트레이싱이 내장**되었습니다. Deno 2.4에서는 OpenTelemetry 지원이 **`--unstable-otel` 플래그 없이도 안정화**되어, 개발자는 추가 구현 없이 필요한 텔레메트리 데이터를 쉽게 캡처할 수 있게 되었습니다. 이는 디버깅 및 문제 해결 시간을 크게 단축시키고 개발 생산성을 향상시킵니다. 또한, **`node:http.request`에 대한 OTel 트레이싱 지원**은 Node.js 기반 프로젝트를 Deno로 마이그레이션하거나, Deno와 Node.js 서비스를 함께 운영하는 환경에서 일관된 관측 가능성을 확보하는 데 기여합니다.

#### 향상된 린터 (`deno lint`) 및 플러그인 시스템

`deno lint`는 **새로운 플러그인 시스템과 15개의 새로운 규칙(특히 React 및 Preact 사용자 대상)**으로 대폭 업그레이드되었습니다. 새로운 내장 규칙에는 **`jsx-boolean-value`, `jsx-key` 등 JSX 및 React 모범 사례를 목표로 하는 규칙들**이 포함되며, `jsx` 및 `react` 태그도 추가되었습니다. 플러그인 API는 ESLint 플러그인 API를 모델로 하며, TypeScript로 작성되어 로컬, npm, JSR에서 소비될 수 있습니다. **`deno lint --rules`는 이제 모든 사용 가능한 규칙을 표시하고, 현재 구성에서 활성화된 규칙을 표시**합니다.

Deno는 초기부터 내장된 린터, 포맷터, 테스터를 제공하여 "All-in-one" 개발 경험을 강조해왔습니다. 그러나 모든 개발 환경과 프로젝트의 요구사항을 내장 도구만으로 충족하기는 어렵습니다. 특히 React/Preact와 같은 특정 프레임워크나 라이브러리에는 해당 생태계의 특성을 반영하는 린팅 규칙이 필요하며, 15개의 새로운 JSX/React 관련 규칙 추가는 이러한 필요성을 반영합니다. `Deno lint` 플러그인 API가 ESLint 플러그인 API를 모델로 했다는 점은 매우 중요합니다. ESLint는 JavaScript/TypeScript 생태계에서 가장 널리 사용되는 린터이므로, 이 모델을 따름으로써 Deno는 개발자들이 새로운 린터 시스템에 적응하는 데 드는 학습 곡선을 최소화합니다. 또한, **일부 기존 ESLint 플러그인이 Deno에서도 작동할 것으로 예상되어**, 기존 ESLint 플러그인 생태계의 풍부한 자원을 Deno에서도 활용할 수 있는 잠재력을 시사합니다. Deno는 새로운 플러그인 시스템을 통해 커뮤니티의 참여를 적극적으로 유도하고 있으며, 이는 `Deno lint`의 기능과 규칙 세트를 빠르게 확장하는 데 기여할 것입니다.

#### `node:sqlite` 모듈 지원

Deno 2.2는 인메모리 또는 로컬 데이터베이스 작업을 간소화하는 **`node:sqlite` 모듈을 도입**했습니다. `DatabaseSync`를 사용하여 데이터베이스 생성, SQL 명령 실행, 데이터 삽입 및 행 검색이 가능합니다. 사용 시 **`--allow-read` 및 `--allow-write` 권한**이 필요합니다.

이 모듈의 지원은 Node.js 호환성 전략의 구체적인 결과물입니다. `node:sqlite`는 Node.js 환경에서 로컬 데이터베이스를 다루는 데 널리 사용되므로, 이 모듈을 Deno에서 직접 지원함으로써 Node.js에서 `node:sqlite`를 사용하던 개발자들이 Deno로 전환할 때 코드 변경 없이 기존 로직을 재사용할 수 있게 됩니다. 이는 Deno로의 마이그레이션 장벽을 크게 낮추는 실질적인 조치이며, 개발 편의성을 향상시킵니다.

#### `deno check` 및 `deno lsp` 개선

`deno check`는 JSDoc `@import` 태그를 존중하고, 워크스페이스 멤버별 `compilerOptions` 설정이 가능해졌습니다. **`deno lsp`는 자동 완성 제안 속도가 5-20배 향상**되었고, Svelte, Qwik, Vite 사용자 경험 개선을 위한 `compilerOptions.rootDirs` 및 `compilerOptions.types`를 지원합니다. 또한, **`.wasm` 파일 임포트 완성, `.scss`, `.sass`, `.less`, `.sql`, `.svelte`, `.vue` 등 컴포넌트 파일 포맷팅 지원, npm 패키지 자동 완성 개선** 등의 기능이 추가되었습니다. Deno 2.2.4에서는 LSP가 TypeScript 서버를 지연 로딩하여 시작 속도를 개선했습니다.

이러한 개선은 개발 생산성과 IDE 통합을 크게 강화합니다. 자동 완성 속도 향상은 개발자가 코드를 작성하는 동안 지연 없이 즉각적인 피드백을 받을 수 있게 하여 생산성을 높입니다. Svelte, Qwik, Vite와 같은 인기 웹 프레임워크에 대한 지원 강화는 Deno가 특정 기술 스택을 사용하는 개발자들에게 더 나은 경험을 제공하려는 노력을 보여주며, Deno의 활용 범위를 넓힙니다. `compilerOptions`를 워크스페이스 멤버별로 설정할 수 있게 된 것은 모노레포와 같이 복잡한 프로젝트 구조에서 타입 체크의 정확성과 유연성을 높입니다.

#### `deno task` 기능 확장

`deno task`는 OS 시그널이 서브 태스크로 올바르게 전달되고, 서브 프로세스가 Windows에서 올바르게 종료되도록 개선되었습니다. 또한, **와일드카드(`*`)를 사용하여 여러 태스크를 병렬로 실행**할 수 있게 되었고, 명령 없이 태스크를 정의하여 다른 태스크를 종속성으로 그룹화할 수 있게 되었습니다.

이러한 기능 확장은 빌드 및 자동화 워크플로우의 유연성을 증대시킵니다. OS 시그널 전달 개선은 개발자가 실행 중인 태스크를 안정적으로 중단하고 프로세스 누수를 방지할 수 있게 하여 개발 경험의 안정성을 높입니다. 와일드카드 지원은 모노레포 환경에서 여러 프로젝트의 빌드, 테스트, 린팅 등을 동시에 처리할 때 매우 유용하며 빌드 시간을 단축시킵니다. 명령 없는 태스크 정의는 복잡한 태스크 종속성 그래프를 명확하게 정의하고 관리할 수 있게 하여 태스크 정의의 가독성과 재사용성을 높입니다.

#### `deno compile` 성능 및 기능 향상

`deno compile`로 컴파일된 프로그램 크기가 macOS에서 약 5MB 더 작아졌고, 컴파일된 프로그램에 내장된 파일 읽기 속도가 ~40% 빨라졌습니다. 또한, 포함된 파일과 크기(node_modules 포함) 요약을 제공합니다.

`deno compile`은 Deno 프로젝트를 단일 독립 실행형 바이너리로 컴파일하여 Deno 런타임이 설치되지 않은 시스템에도 애플리케이션을 배포할 수 있게 하는 핵심 기능입니다. 바이너리 크기 감소 및 읽기 속도 향상은 배포 파일의 효율성을 높이고 애플리케이션의 시작 및 실행 성능을 개선합니다. 이는 특히 리소스가 제한된 환경이나 빠른 시작 시간이 중요한 서버리스 함수에 유리합니다. 포함된 파일 요약은 개발자가 바이너리 크기를 최적화할 때 어떤 파일이 큰 용량을 차지하는지 쉽게 파악할 수 있게 하여 디버깅 및 최적화 프로세스를 간소화합니다.

#### Node.js 및 npm 호환성 진전 (Deno 2.2)

Deno 2.2에서는 Node.js 및 npm 호환성이 더욱 진전되었습니다. **`.npmrc` 파일이 홈 디렉터리 및 프로젝트 디렉터리에서 발견**되며, **`--unstable-detect-cjs` 플래그**가 CommonJS 모듈 문제 해결을 위해 재활용되었습니다. AWS SDK 및 **`tls.connect` 소켓 업그레이드의 신뢰성이 향상**되었고, **`process`, `fs`, `http`, `zlib`, `worker_threads`, `crypto` 모듈에 대한 수많은 변경사항**이 포함됩니다.

이러한 변화는 Deno가 기존 Node.js 개발자 기반을 적극적으로 흡수하려는 명확한 의도를 보여줍니다. `.npmrc` 파일 지원은 Deno가 npm 레지스트리 설정, 인증, 프록시 설정 등을 Node.js와 동일한 방식으로 처리할 수 있게 하여, npm 중심의 개발 환경에서 Deno를 사용하는 데 필요한 마찰을 크게 줄입니다. 이는 기업 환경에서 특히 중요합니다. Node.js 핵심 모듈에 대한 수많은 API 추가 및 버그 수정은 Deno의 Node.js 호환성 레이어가 지속적으로 성숙하고 견고해지고 있음을 보여주며, Node.js 코드를 Deno로 포팅할 때 필요한 변경량을 최소화합니다.

#### 전반적인 성능 최적화 (Deno 2.2)

Deno 2.2는 전반적인 성능 최적화를 포함합니다. 모듈 분석 정보 캐시 해제로 메모리 소비량이 감소했고, **`Deno.stat` 및 `node:fs.stat`이 Windows에서 최대 2.5배 빨라졌습니다.** **`package.json` 조회 속도 향상** 및 **`@aws-sdk/client-s3`가 sha256 및 sha512 구현을 위한 어셈블리 사용으로 최대 2배 빨라졌습니다.** Node.js 모듈 해결 속도 향상 및 **`node:fs.cpSync`가 Deno 2.1보다 최대 2배, Node.js 20보다 3배 빨라졌습니다.** Linux 바이너리 크기도 약 15MB 감소했습니다.

런타임의 성능은 애플리케이션의 응답 속도, 리소스 사용량, 그리고 궁극적으로 운영 비용에 직접적인 영향을 미칩니다. Deno는 메모리 관리, 파일 시스템 작업, 패키지/모듈 해결, 암호화 작업, 그리고 바이너리 크기 등 다양한 측면에서 최적화를 진행했습니다. 이는 런타임 전반의 효율성을 끌어올리려는 체계적인 노력을 보여줍니다. **`node:fs.cpSync`가 Node.js 20보다 3배 빨라졌다는 점**은 Deno가 특정 Node.js API 구현에서 Node.js 자체보다 더 나은 성능을 제공할 수 있음을 보여주며, 이는 Node.js에서 Deno로의 마이그레이션을 고려하는 개발자들에게 강력한 유인책이 됩니다.

---

### Deno 2.3 릴리스 주요 변경사항 (2025년 5월)

Deno 2.3은 2025년 5월에 릴리스되었으며, 로컬 npm 패키지 지원 및 `deno compile` 개선에 중점을 두었습니다.

#### 로컬 npm 패키지 지원 (`deno.json`의 `patch` 필드)

`deno.json` 파일 내 **`patch` 필드를 사용하여 로컬 npm 패키지를 테스트하고 개발**할 수 있게 되었습니다. 이는 Node.js의 **`npm link`와 유사한 기능을 제공**하여, 개발 중인 라이브러리나 비공개 패키지를 쉽게 연동할 수 있도록 합니다.

이 기능은 복잡한 프로젝트 구조, 특히 모노레포나 조직 내부의 비공개 npm 패키지를 사용하는 환경에서 매우 중요합니다. Deno는 초기에는 npm 패키지 지원이 제한적이어서 이러한 환경에서 Node.js 개발자들이 Deno로 전환하는 데 큰 걸림돌이었습니다. **`patch` 필드의 도입**은 이러한 문제를 직접적으로 해결하여, 개발자가 `npm link`와 유사한 방식으로 로컬 패키지를 Deno 프로젝트에 연결할 수 있게 함으로써 개발 및 테스트 워크플로우를 크게 간소화합니다. 이는 Deno가 엔터프라이즈 및 복잡한 프로젝트 환경에서의 채택률을 높이기 위한 중요한 단계입니다.

#### `deno compile` 추가 개선사항

Deno 2.3에서는 `deno compile`이 **FFI(Foreign Function Interface) 및 Node Native Add-ons를 사용하는 프로그램을 컴파일**할 수 있게 되었습니다. 또한, 컴파일 과정에서 특정 파일을 제외하여 실행 파일 크기를 줄일 수 있는 기능이 추가되었습니다.

FFI는 Deno의 JavaScript 런타임과 네이티브 코드 간의 다리 역할을 하여, 기존 C/C++ 라이브러리를 Deno 애플리케이션에서 직접 사용할 수 있게 합니다. 이는 특히 고성능 계산, 시스템 레벨 상호작용, 또는 특정 하드웨어 기능 접근이 필요한 경우 Deno의 활용 범위를 크게 확장합니다. Node Native Add-ons 지원은 Node.js 생태계에서 C/C++로 작성된 성능 최적화 모듈이나 시스템 인터페이스 모듈을 Deno에서도 사용할 수 있게 하여, Node.js에서 Deno로의 마이그레이션을 더욱 용이하게 합니다. 컴파일 시 특정 파일을 제외할 수 있는 기능은 개발자가 불필요한 개발/테스트 파일 등을 최종 배포 바이너리에서 제거하여, 실행 파일의 크기를 더욱 세밀하게 최적화할 수 있게 합니다.

#### `deno fmt` 확장

Deno 2.3에서 `deno fmt`는 **태그된 템플릿(tagged templates) 내에 포함된 CSS, HTML, SQL을 포맷팅**할 수 있게 되었습니다. Deno 2.4에서는 XML 및 SVG 포맷팅도 지원합니다.

프로젝트 내에서 일관된 코드 스타일을 유지하는 것은 가독성을 높이고 협업을 용이하게 합니다. 기존 `deno fmt`는 JavaScript/TypeScript 코드 자체의 포맷팅은 가능했지만, 태그된 템플릿 내의 문자열은 포맷팅이 어려웠습니다. `deno fmt`의 확장은 개발자가 Deno 환경 내에서 모든 주요 웹 관련 코드(JS/TS, CSS, HTML, SQL, XML, SVG)를 일관되게 포맷팅할 수 있게 함으로써, 개발자가 여러 포맷팅 도구를 설정하고 관리하는 번거로움을 없애고 "All-in-one" 개발 경험을 강화합니다.

---

### Deno 2.4 주요 기능 (H1 2025 기간 내 논의된 기능)

**참고**: Deno 2.4는 2025년 7월 1일에 공식 릴리스되었지만, 그 주요 기능들은 2025년 상반기 동안 활발히 논의되고 발표되었습니다. 따라서 상반기 기간 내의 변경사항으로 포함하여 다룹니다.

#### `deno bundle` 재도입

프로젝트를 단일 JavaScript 파일로 번들링하는 **`deno bundle` 명령이 재도입**되었습니다.

`deno bundle`의 재도입은 개발자 커뮤니티의 지속적인 수요를 반영한 것입니다. `deno compile`이 바이너리 배포에 초점을 맞추는 반면, `deno bundle`은 웹 환경(예: 브라우저에서 직접 실행 가능한 스크립트, CDN 배포)이나 특정 런타임에서 JavaScript 파일 자체로 배포하는 시나리오에 여전히 유용합니다. 이는 개발자에게 독립 실행형 바이너리 외에 단일 JavaScript 파일 배포라는 또 다른 유연한 옵션을 제공하여, Deno의 활용 범위를 넓히고 특정 워크플로우에 대한 지원을 개선합니다.

#### 새로운 `--preload` 플래그

스크립트 실행 전에 Deno 런타임 환경을 수정할 수 있는 **`--preload` 플래그가 추가**되었습니다. 이는 설정 코드나 계측(instrumentation) 코드 주입에 유용합니다.

`--preload` 플래그는 런타임에 대한 개발자의 제어력을 크게 향상시키며, 특히 고급 계측, 환경 설정, 그리고 특정 호환성 요구사항을 가진 시나리오에서 매우 유용합니다. 예를 들어, OpenTelemetry와 같은 계측 라이브러리를 애플리케이션 코드에 직접 통합하지 않고도 `--preload`를 통해 주입하여, 모든 요청이나 함수 호출에 대한 트레이싱을 시작할 수 있습니다. 이는 "Zero-config Debugging" 개념을 더욱 강화합니다.

#### `deno update`를 통한 의존성 관리 간소화

**`deno update` 명령을 통해 의존성 관리가 간소화**됩니다. 소프트웨어 프로젝트에서 의존성을 최신 상태로 유지하는 것은 새로운 기능 활용, 성능 개선, 그리고 보안 취약점 패치를 위해 필수적입니다. **`deno update`는 Deno 프로젝트의 의존성을 자동으로 최신 버전으로 업데이트하는 기능**을 제공하여, 유지보수 오버헤드를 크게 줄이고 프로젝트의 보안 상태를 개선합니다. 이는 개발자가 의존성 관리에 들이는 노력을 줄여 핵심 개발에 집중할 수 있게 합니다.

#### `deno run --coverage`를 통한 스크립트 커버리지 수집

**`deno run --coverage` 명령을 통해 스크립트 커버리지를 수집**할 수 있습니다. 이는 테스트 품질을 추적하고 테스트되지 않은 로직을 식별하는 데 유용합니다. Deno는 이미 내장된 테스팅 도구(`deno test`)를 제공하며, 여기에 `deno run --coverage`를 추가함으로써 테스트 워크플로우를 더욱 완벽하게 만듭니다. 개발자는 이제 Deno 런타임 내에서 직접 코드 커버리지를 측정할 수 있으므로, 어떤 코드가 테스트를 거치지 않았는지 명확하게 식별하고 해당 부분에 대한 테스트를 추가하여 애플리케이션의 전반적인 견고성을 높일 수 있습니다.

---

## Deno 표준 라이브러리 (`denoland/std`) 변화

Deno의 표준 라이브러리(`denoland/std`)는 2025년 상반기 동안 수많은 패치 및 마이너 업데이트를 통해 기능이 확장되고 안정성이 개선되었습니다. 이는 Deno 코어 런타임의 발전과 함께 Deno 생태계의 성숙도를 보여주는 중요한 지표입니다.

### 주요 모듈별 업데이트 요약

#### `@std/fs` (파일 시스템) 모듈의 새로운 API

2025년 3월부터 4월에 걸쳐 `@std/fs` 모듈에는 **`remove`, `removeSync`, `umask`, `utime`, `utimeSync`, `mkdir`, `mkdirSync`, `copyFile`, `copyFileSync`, `truncate`, `truncateSync`, `readTextFileSync`, `readTextFile`, `chown`, `chownSync`, `readDirSync`, `create`, `createSync`, `open`, `openSync`, `FsFile` 클래스** 등 Node.js의 `fs` 모듈에서 흔히 볼 수 있는 다양한 파일 시스템 조작 API들이 대거 추가되었습니다 (모두 `fs/unstable`로 표시).

파일 시스템(FS) 조작은 대부분의 백엔드 및 CLI 애플리케이션에서 필수적인 기능입니다. 이들 API의 추가는 Deno가 `node:fs` API의 기능을 Node.js와 거의 동등한 수준으로 끌어올리려는 노력을 보여줍니다. 이는 Node.js에서 `fs` 모듈을 사용하던 개발자들이 Deno로 전환할 때, 기존 파일 시스템 관련 코드를 최소한의 수정으로 재사용할 수 있게 하여 마이그레이션 장벽을 크게 낮춥니다. 또한, 파일 및 디렉터리 생성, 삭제, 복사, 권한 변경 등 일상적인 파일 시스템 작업을 위한 강력하고 직관적인 API를 제공하여 개발자의 생산성을 향상시킵니다.

#### `@std/encoding` (인코딩) 모듈의 변경사항 및 성능 개선

2025년 3월에는 `Base32Hex(Encoder|Decoder)Stream`를 `Base32(Encoder|Decoder)Stream`으로, `Base64Url(Encoder|Decoder)Stream`를 `Base64(Encoder|Decoder)Stream`으로 병합하는 **Breaking Change**가 있었습니다. 또한, **`encodeBase32` 및 `decodeBase32`에 `format` 옵션이 추가**되었고, **`encode/decodeRawHex`가 추가**되었습니다. Hex, Base32, Base64 인코딩/디코딩 성능도 향상되었습니다. 4월에는 **`encodeRaw`가 `encodeInto`로 대체되고 `decodeRaw`가 제거**되었으며, **`decodeBase64`, `32`, `hex`에 `Uint8Array` 지원이 추가**되었습니다.

이러한 변경은 API의 통일성과 일관성을 확보하여 사용성을 개선하려는 의도입니다. 특히 `proposal-arraybuffer-base64` API와의 일치도 이러한 통일성 노력의 일환입니다. 인코딩/디코딩 성능 향상은 특히 대량의 데이터를 처리하거나 성능이 중요한 애플리케이션에서 직접적인 이점을 제공합니다. `Uint8Array` 지원 추가는 바이너리 데이터 처리의 유연성을 높이고, 다른 모듈이나 Web API와의 상호 운용성을 개선합니다.

#### `@std/cli` (CLI 유틸리티) 모듈의 개선사항

2025년 3월에는 `ProgressBarFormatter` 속성에서 후행 공백이 제거되는 **Breaking Change**가 있었고, 4월에는 **`promptSelect`에 `visibleLines` 및 `indicator` 옵션이 추가되어 스크롤 시뮬레이션이 가능**해졌습니다. 5월에는 **`ProgressBarFormatter.styledTime`가 getter로 변경되고, `ProgressBar`의 `value`, `max` 속성이 public화되었으며 `add` 메서드가 제거되었고, `end()` 메서드가 `stop()`으로 변경되는 Breaking Change**가 있었습니다.

이러한 개선은 CLI 도구의 사용자 경험을 향상시킵니다. ProgressBar 및 Spinner 관련 개선사항은 진행 상황 표시의 시각적 피드백을 개선하고, 개발자가 CLI 도구를 통해 장시간 실행되는 작업을 더 쉽게 모니터링할 수 있게 합니다. 특히 `promptSelect`의 스크롤 시뮬레이션 기능은 많은 옵션이 있는 경우 사용자 경험을 크게 향상시킵니다. Breaking Change는 API의 명확성과 일관성을 높이기 위한 리팩토링의 일환으로, 장기적으로 더 안정적이고 예측 가능한 API를 제공합니다.

#### 기타 주요 모듈 업데이트 및 불안정 API

`@std/toml` 및 `@std/yaml` 모듈은 파싱/스트링화 로직 개선 및 오류 메시지 정렬이 이루어졌습니다. `@std/uuid`는 **UUID v6 및 v7 지원이 추가**되었고, `@std/datetime`은 날짜/시간 포맷팅 및 파싱 버그가 수정되었습니다. `@std/collections`는 **Iterable 입력이 안정화되고 `cycle` 유틸리티가 추가**되었으며, `@std/path`는 **URL 입력 지원이 추가**되었고, `@std/testing`에는 **`assertInlineSnapshot()`이 추가**되었습니다.

이러한 업데이트는 Deno 표준 라이브러리가 API의 일관성과 효율성을 지속적으로 추구하고 있음을 보여줍니다. UUID v6/v7 지원과 같은 새로운 기능은 Deno가 최신 웹 표준 및 개발 트렌드를 반영하고 있음을 의미합니다. 전반적인 코드 품질 개선 노력은 개발자가 더욱 신뢰하고 사용할 수 있는 라이브러리를 제공합니다.

#### 표: Deno 표준 라이브러리 주요 변경사항 요약 (2025년 상반기)

Deno 표준 라이브러리의 변경사항은 여러 릴리스 노트에 걸쳐 분산되어 있으므로, 다음 표는 핵심 모듈의 주요 변경사항을 월별로 요약하여 개발자가 특정 모듈의 변화를 한눈에 파악하고 의사 결정에 활용할 수 있도록 돕습니다.

| 모듈명         | 월   | 주요 변경사항                                                                                                         |
| :------------- | :--- | :-------------------------------------------------------------------------------------------------------------------- |
| `@std/fs`      | 3월  | `remove`, `umask`, `mkdir`, `copyFile`, `truncate`, `readTextFile`, `writeTextFile`, `writeFile` API 추가 (unstable)    |
|                | 4월  | `chown`, `readDirSync`, `create`, `open`, `FsFile` 클래스 추가 (unstable)                                            |
|                | 5월  | `rename`, `renameSync` 테스트 개선 (unstable)                                                                          |
| `@std/encoding` | 3월  | **BREAKING CHANGE**: `Base32Hex`/`Base64Url` 스트림 병합. `encode`/`decodeRawHex` 추가. Hex, Base32, Base64 성능 향상. |
|                | 4월  | **BREAKING CHANGE**: `encodeRaw`를 `encodeInto`로 대체, `decodeRaw` 제거. `Uint8Array` 지원 추가.                   |
| `@std/cli`     | 3월  | **BREAKING CHANGE**: `ProgressBarFormatter` 후행 공백 제거.                                                             |
|                | 4월  | `promptSelect`에 `visibleLines`, `indicator` 옵션 추가 (스크롤 시뮬레이션).                                             |
|                | 5월  | **BREAKING CHANGE**: `ProgressBarFormatter.styledTime`를 getter로 변경. `ProgressBar` 속성 public화, `add`/`end` 메서드 변경. |
| `@std/uuid`    | 3월  | UUID V6 지원 추가 (unstable).                                                                                         |
|                | 6월  | UUID V7 유효성 검사 지원 추가.                                                                                        |
| `@std/toml`    | 4월  | 빈 인라인 테이블, 숫자 리터럴 처리 버그 수정. 파싱 성능 향상.                                                          |
|                | 6월  | 날짜/시간 및 부동 소수점 처리 버그 수정.                                                                                |
| `@std/yaml`    | 4월  | 파싱/스트링화 로직 개선.                                                                                                |
| `@std/datetime` | 4월  | `fractionalSecond` 포맷팅, `yy`/`yyyy` 파싱 버그 수정.                                                                  |
| `@std/collections` | 5월  | Iterable 입력 안정화. `cycle` 유틸리티 추가 (unstable).                                                               |
| `@std/path`    | 5월  | `basename`, `dirname`, `extname`, `join`, `normalize`에 URL 입력 지원 추가.                                          |
| `@std/testing` | 5월  | `assertInlineSnapshot()` 추가 (unstable).                                                                           |

---

## 생태계 및 플랫폼 개발

### JSR (JavaScript Registry) 업데이트

JSR은 Deno의 핵심 패키지 레지스트리로, 2025년 상반기 동안 중요한 발전을 이루었습니다. 2025년 1월 24일, **OpenAI의 JavaScript 및 TypeScript SDK가 JSR에 출시**되었습니다. 이는 OpenAI와 같은 주요 AI 기술 제공업체가 JSR을 중요한 패키지 배포 채널로 인정하고 있음을 보여줍니다. 2025년 2월 3일에는 **JSR의 독립적인 거버넌스 위원회가 출범**했습니다. 이는 JSR이 특정 기업의 통제에서 벗어나 커뮤니티 주도로 운영되는 오픈 소스 프로젝트로서의 정체성을 강화하려는 노력으로, JSR의 중립성과 장기적인 지속 가능성에 대한 신뢰를 높입니다. 2025년 4월 25일에는 **pnpm 및 Yarn을 사용하여 JSR 패키지를 추가할 수 있게 되어**, Deno 환경 외부에서도 JSR 패키지를 쉽게 통합할 수 있게 되었습니다.

JSR은 엄격한 패키지 검증, 스쿼팅 방지, 필수 스코핑, 타입 체크 최적화, 직접 TypeScript 게시 기능 등 혁신적인 기능을 제공합니다. 이러한 기능들은 npm의 오랜 문제점들을 해결하고 더 안전하고 효율적인 패키지 관리 경험을 제공하려는 JSR의 핵심 가치를 보여줍니다. JSR의 2025년 상반기 업데이트는 JSR이 Deno 생태계의 핵심 구성요소를 넘어, 더 넓은 JavaScript/TypeScript 커뮤니티를 위한 중요한 패키지 레지스트리로 성장하고 있음을 보여줍니다.

### Deno Deploy 및 Subhosting 개선

Deno Deploy는 Deno의 핵심 비즈니스 모델이자 수익 창출 전략입니다. 2025년 5월 20일, Deno는 "Reports of Deno's Demise Have Been Greatly Exaggerated"라는 블로그 게시물을 통해 최근 Deno에 대한 비판에 대응하고 Deno Deploy의 미래 비전을 공유했습니다. 이는 Deno Deploy가 여전히 Deno의 핵심 전략적 축임을 재확인하는 것입니다.

2025년 4월의 Early Access Changelog는 Deno Deploy의 실질적인 개선사항들을 상세히 보여줍니다. **라이브 스트리밍 로그 및 트레이스 패널, 향상된 프레임워크 자동 감지(Vite 기반 프로젝트 포함)**는 배포된 애플리케이션의 모니터링 및 디버깅 기능을 크게 향상시킵니다. **플레이그라운드 지원(다중 파일, 빌드 단계, 미리보기 iframe, 템플릿), 빌드 개선(최대 8GB 스토리지, 환경 변수/시크릿, 최대 5분 런타임), 메트릭 페이지 대대적인 개선, 수동 빌드 시 브랜치 선택, Astro 정적 사이트 배포 간소화, 참조 문서, `.env` 파일 붙여넣기를 통한 환경 변수 대량 가져오기, SvelteKit 및 Lume 프리셋 지원** 등은 Deno Deploy 플랫폼에서 애플리케이션을 개발하고 배포하는 과정을 더욱 빠르고 편리하게 만듭니다. Next.js 빌드 안정성, GitHub 트리거 빌드 중복 실행 방지, 대시보드 페이지 로딩 속도 향상, **`npx` 빌더에서 사용 가능, Astro 및 Svelte 프로젝트 배포 수정**과 같은 버그 수정도 이루어졌습니다.

Deno Deploy는 완전 관리형 서버리스 솔루션으로, 전역 분산, 내장 Key/Value 데이터베이스, 큐, Cron 등을 제공하며 GitHub와 통합됩니다. Deno Subhosting은 안전한 샌드박스 함수, 자동 스케일링, 전역 분산, API 관리를 특징으로 하며, 멀티테넌트 환경에서 안전하게 사용자 코드를 실행하는 데 중점을 둡니다. Deno Deploy 및 Subhosting의 지속적인 개선은 Deno가 클라우드 네이티브 애플리케이션 개발을 위한 강력하고 효율적인 플랫폼으로서의 입지를 강화하고 있음을 보여줍니다.

### Fresh 프레임워크 업데이트

Fresh는 Deno용 서버 렌더링 웹 프레임워크로, Preact를 기반으로 합니다. 2025년 5월 15일, "An Update on Fresh" 블로그 게시물을 통해 Fresh 2.0이 여전히 활발히 개발 중이며 알파 버전을 시도해 볼 수 있음을 밝혔습니다. Fresh가 Preact 기반의 서버 렌더링 프레임워크라는 점은 Deno의 빠른 시작 시간과 낮은 리소스 사용량이라는 강점을 웹 개발에서 최대한 활용하려는 전략을 보여줍니다. JSX/TSX 컴포넌트로 경로를 작성하는 방식은 React/Preact 개발자들에게 친숙하며, 코드의 가독성과 유지보수성을 높입니다. Fresh 프레임워크의 지속적인 발전은 Deno가 단순한 런타임을 넘어, 풀 스택 웹 개발을 위한 통합된 생태계를 구축하려는 노력을 보여줍니다.

### WebAssembly (Wasm) 통합 소개

2025년 1월 28일, Deno에서 Wasm을 사용하여 웹 애플리케이션 성능을 향상시키는 방법에 대한 소개 가이드가 게시되었습니다. WebAssembly(Wasm)는 웹 브라우저에서 고성능 애플리케이션을 실행하기 위해 설계된 바이너리 명령어 형식으로, JavaScript와 함께 작동하며 C, C++, Rust 등 다양한 언어로 작성된 코드를 웹에서 거의 네이티브에 가까운 성능으로 실행할 수 있게 합니다.

Deno의 Wasm 지원은 고성능 컴퓨팅 및 다국어 개발을 지원하는 범용 런타임으로서의 역량을 강화합니다. CPU 집약적인 작업을 Wasm 모듈로 구현하고 Deno에서 실행함으로써, JavaScript만으로는 달성하기 어려운 수준의 성능을 확보할 수 있습니다. 이는 개발자에게 더 넓은 언어 선택의 폭을 제공하고, 기존 코드베이스의 재사용을 용이하게 합니다.

---

## 전략적 방향 및 호환성

### Node.js 호환성 및 npm Specifier 사용 권장

Deno 2.0 출시 이후 Node.js 호환성이 크게 강화되었으며, Bun의 영향도 받았습니다. 2025년 2월 13일, Deno는 "If you're not using npm specifiers, you're doing it wrong"이라는 블로그 게시물을 통해 Deno 2부터 npm 패키지 임포트에 **npm specifier 사용을 권장**했습니다. 이는 Deno가 npm 패키지를 "퍼스트 클래스 시민"으로 대우하고 있음을 명확히 선언한 것입니다.

Deno는 **`.npmrc` 파일 지원**, **`deno.json`의 `patch` 필드를 통한 로컬 npm 패키지 지원**, **`DENO_COMPAT=1` 모드**, 그리고 Node.js API(`fs`, `process`, `http`, `crypto` 등)의 **지속적인 개선** 등 구체적인 호환성 기능을 추가했습니다. 이러한 기능들은 Node.js 개발자들이 겪을 수 있는 모든 마찰 지점을 체계적으로 제거하려 노력하고 있음을 보여줍니다. Deno는 **"기술적 우수성이 항상 승리하는 것은 아니며, 기존 도구와의 호환성 파괴는 채택에 큰 장벽을 만든다"는 교훈**을 얻었으며, 이러한 전략적 변화는 Deno가 Node.js가 지배하는 거대한 JavaScript 시장에서 더 큰 점유율을 확보하려는 실용적인 목표를 가지고 있음을 시사합니다.

### 커뮤니티 피드백 반영 및 미래 비전

오픈 소스 프로젝트의 성공은 기술력뿐만 아니라 커뮤니티와의 소통, 피드백 수용, 그리고 투명한 비전 공유에 크게 좌우됩니다. 2025년 5월 20일, Deno는 "Reports of Deno's Demise Have Been Greatly Exaggerated"라는 블로그 게시물을 통해 최근 Deno에 대한 비판에 대응하고 미래 비전을 공유했습니다. 이는 Deno 팀이 커뮤니티의 목소리에 귀 기울이고 있음을 시사합니다.

Deno 2.4에서 **`deno bundle`이 재도입된 것은 커뮤니티의 요청을 반영한 구체적인 사례**이며, JSR의 독립 거버넌스 위원회 출범은 Deno가 핵심 프로젝트의 통제권을 커뮤니티와 공유함으로써, 더 넓은 생태계의 참여를 유도하고 장기적인 지속 가능성을 확보하려는 전략적인 움직임입니다. 또한, Deno가 Oracle과의 JavaScript 상표권 분쟁에 적극적으로 참여하고 그 진행 상황을 커뮤니티에 공유하는 것은 Deno가 단순히 런타임 개발을 넘어, JavaScript 표준화와 오픈 웹 생태계의 발전에 기여하려는 더 큰 비전을 가지고 있음을 보여줍니다. Deno 팀은 2025년 상반기 동안 커뮤니티와의 투명한 소통, 피드백의 적극적인 수용, 그리고 핵심 프로젝트의 거버넌스 분산을 통해 개발자들의 신뢰를 구축하고 지속 가능한 성장을 위한 기반을 다지고 있습니다.

---

## 결론

2025년 상반기 Deno는 핵심 런타임 기능, 표준 라이브러리, 그리고 클라우드 플랫폼에 걸쳐 전방위적인 발전을 이루었습니다. 특히 Node.js 및 npm 생태계와의 호환성 강화는 Deno의 가장 중요한 전략적 변화로, 기존 Node.js 개발자들에게 Deno로의 전환을 더욱 매력적으로 만들고 있습니다.

코딩 구현 시 개발자들에게는 다음과 같은 주요 시사점이 있습니다.

* **Node.js 프로젝트 마이그레이션 용이성**: `patch` 필드를 통한 로컬 npm 패키지 지원, `DENO_COMPAT=1` 모드, 그리고 지속적인 Node.js API 구현 개선은 기존 Node.js 코드베이스를 Deno로 포팅하는 데 필요한 노력을 크게 줄여줍니다. FFI 및 Node Native Add-ons 지원은 C/C++ 확장 기능을 활용하던 프로젝트의 전환까지 가능하게 합니다.
* **향상된 개발자 경험**: `deno lsp`의 속도 향상, `deno fmt`의 확장된 포맷팅 기능, `deno lint`의 플러그인 시스템은 개발자의 일상적인 코딩 생산성을 직접적으로 향상시킵니다.
* **강력한 내장 도구**: `deno compile`의 성능 개선 및 기능 확장, `deno task`의 유연성 증대, `deno run --coverage`를 통한 테스트 커버리지 수집 기능은 Deno가 단순한 런타임을 넘어, 개발자가 고품질의 소프트웨어를 개발하고 배포하는 데 필요한 모든 도구를 내장하려는 비전을 지속적으로 추구하고 있음을 보여줍니다.
* **클라우드 네이티브 개발 준비성**: 내장 OpenTelemetry 지원 및 Deno Deploy의 지속적인 개선(관측 가능성, 빌드 유연성, 프레임워크 지원)은 Deno가 서버리스 및 클라우드 네이티브 애플리케이션 개발을 위한 강력하고 효율적인 플랫폼으로서의 입지를 강화하고 있음을 나타냅니다.
* **고성능 컴퓨팅 및 다국어 지원**: WebAssembly 통합은 Deno가 고성능이 요구되는 작업에 더욱 적합해지고, JavaScript/TypeScript 외 다양한 언어로 작성된 코드를 통합할 수 있는 유연성을 제공함을 의미합니다.

결론적으로, 2025년 상반기 Deno의 변화는 기술적 우수성을 유지하면서도 시장의 요구와 개발자 커뮤니티의 피드백을 적극적으로 수용하여 실용성을 강화하는 방향으로 나아가고 있음을 명확히 보여줍니다. 이는 Deno가 현대 웹 개발 환경에서 더욱 강력하고 매력적인 선택지로 자리매김할 수 있는 견고한 기반을 마련했습니다.
