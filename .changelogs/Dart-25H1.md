# Dart 25H1 핵심 변경사항

-----

## 서론: 2025년 상반기 Dart 업데이트 개요

2025년 상반기(1월 \~ 6월) 동안 Dart SDK는 두 가지 중요한 릴리스를 통해 언어, 핵심 도구, 런타임 및 웹 플랫폼 지원 전반에 걸쳐 상당한 발전을 이루었습니다. 이 기간 동안 **Dart 3.7** (2025년 2월 12일 릴리스)과 **Dart 3.8** (2025년 5월 20일 릴리스)이 출시되었습니다. 이 두 버전은 개발자의 코딩 구현 방식과 워크플로우에 직접적인 영향을 미치는 주요 변경사항들을 포함하고 있습니다. 본 보고서는 이러한 핵심 변경사항들을 심층적으로 분석하고, 각 업데이트의 기술적 의미와 개발자가 숙지해야 할 마이그레이션 전략을 상세히 다룰 것입니다.

다음 표는 2025년 상반기에 출시된 Dart SDK 버전들을 한눈에 파악할 수 있도록 요약하여 제공하며, 각 버전의 주요 초점 영역을 명시합니다. 이는 독자가 보고서의 범위를 즉시 이해하고 논의될 핵심 버전을 파악하는 데 도움을 줍니다.

### 표 1: Dart 2025년 상반기 릴리스 요약

| 릴리스 버전 | 릴리스 날짜  | 주요 변경사항                          |
| :---------- | :----------- | :------------------------------------- |
| Dart 3.7    | 2025년 2월 12일 | 와일드카드 변수 도입, `dart format`의 새로운 "Tall Style" |
| Dart 3.8    | 2025년 5월 20일 | Null-aware 요소 추가, `dart format` 추가 개선    |

-----

## 주요 언어 기능 추가 및 코딩 영향

2025년 상반기 Dart는 개발자 생산성과 코드 가독성을 향상시키는 새로운 언어 기능을 도입했습니다. 이러한 기능들은 코드 작성 방식에 미묘하지만 중요한 변화를 가져올 것입니다.

### Dart 3.7: 와일드카드 변수 (`_`) 도입 및 활용

Dart 3.7부터 \*\*와일드카드 변수(wildcard variables)\*\*가 언어에 추가되었습니다. 이는 밑줄(`_`)로 명명된 로컬 변수 또는 매개변수를 의미합니다. 와일드카드 변수의 핵심 특징은 "**비바인딩(non-binding)**"이라는 점입니다. 즉, 동일한 스코프 내에서 여러 번 선언되어도 이름 충돌을 일으키지 않습니다.

이 기능은 코딩 구현에 직접적인 영향을 미칩니다. `Foo(_, this._, super._, void _()) {}`와 같은 예시에서 볼 수 있듯이, 특정 값을 사용하지 않고 단순히 위치를 채우거나 무시해야 하는 경우에 유용합니다. 이는 특히 패턴 매칭이나 구조 분해 할당(destructuring assignment)과 함께 사용될 때, 불필요한 변수 이름을 생성하지 않고 코드의 의도를 명확히 하는 데 기여하여 가독성을 향상시킵니다. 사용하지 않는 변수에 의미 없는 이름을 부여하는 대신 \*\*`_`\*\*를 사용함으로써, 개발자는 코드의 특정 부분이 무시되거나 관련이 없음을 즉시 파악할 수 있어 코드의 명확성이 증대됩니다.

와일드카드 변수의 도입은 Dart가 코드의 "의도"를 더 명확하게 표현하고, 불필요한 보일러플레이트(boilerplate)를 줄이는 방향으로 진화하고 있음을 나타냅니다. 이는 최근 다른 현대 프로그래밍 언어(예: Rust, Scala, Kotlin의 `_` 사용)에서도 나타나는 추세와 일치하며, 개발자 경험(DX) 개선에 중점을 둡니다. 이 변화는 개발자가 특정 변수의 값이 중요하지 않음을 명시적으로 나타낼 수 있도록 하여, 코드 리뷰 시 불필요한 논의를 줄이고 코드의 의미를 더욱 직관적으로 전달하는 데 기여합니다. 언어가 불필요한 세부 사항을 줄이고 핵심 로직에 집중하도록 돕는 것은 개발자의 인지 부하를 감소시키고 전반적인 생산성을 향상시키는 데 중요한 역할을 합니다.

### Dart 3.8: Null-aware 요소 추가 및 컬렉션 리터럴 활용

Dart 3.8에서는 컬렉션 리터럴(리스트, 맵, 세트) 내에서 **Null-aware 요소**를 사용할 수 있게 되었습니다. 이는 컬렉션에 추가될 표현식이 **`null`이 아닌 경우에만 해당 값을 컬렉션에 삽입하는 기능**입니다.

이 기능은 컬렉션을 구성하는 코드를 훨씬 간결하게 만듭니다. 기존에는 null 체크를 통해 조건부로 요소를 추가하기 위해 `if` 문이나 `where` 절 등을 사용해야 했습니다. 이제는 `...?` 또는 `if (expression != null) expression`과 유사한 형태로 컬렉션 내에서 직접 null 여부를 확인하고 요소를 포함할 수 있어 코드가 훨씬 간결해집니다. 이는 특히 옵션 값이나 동적으로 생성되는 데이터로 컬렉션을 구성할 때 유용합니다.

**예시**:

```dart
String? nullableString = "hello";
List<String> oldWay = ['item1'];
if (nullableString != null) {
  oldWay.add(nullableString);
}
oldWay.add('item3');
// 결과: ['item1', 'hello', 'item3']

List<String> newWay = [
  'itemA',
  if (nullableString != null) nullableString, // if-element 사용
  'itemC',
];
// 결과: ['itemA', 'hello', 'itemC']

List<String>? nullableList = ['element1', 'element2'];
List<String> combinedList = ['start', ...? nullableList, 'end']; // null-aware spread 사용
// nullableList가 null이면 combinedList는 ['start', 'end']
// nullableList가 ['element1', 'element2']이면 combinedList는 ['start', 'element1', 'element2', 'end']
```

Null-aware 요소의 도입은 Dart의 강력한 Sound Null Safety 시스템을 컬렉션 리터럴 수준까지 확장하고 강화하는 자연스러운 진화입니다. 이 기능은 Dart 2.12에서 도입되고 Dart 3.0에서 기본값이 된 Sound Null Safety에 대한 Dart의 지속적인 노력을 반영합니다. 컬렉션 리터럴을 Null-aware하게 만듦으로써, Dart는 Null Safety를 핵심 언어 구성 요소에 더욱 통합하여, Null 관련 런타임 오류의 발생 가능성을 줄이고 Null을 안전하게 처리하는 코드를 더욱 직관적으로 작성할 수 있도록 돕습니다. 이는 Dart가 "안전성"과 "생산성"이라는 두 가지 가치를 동시에 추구하는 지속적인 노력의 일환입니다. 특히 Flutter 개발에서 UI 트리가 중첩된 컬렉션 리터럴(예: 위젯의 `children` 목록)을 사용하여 구성되는 경우가 많기 때문에, 이 기능은 선택적 값의 존재 여부에 따라 위젯이나 데이터를 조건부로 추가하는 일반적인 패턴을 단순화하여 더 깔끔하고 유지보수하기 쉬운 UI 코드를 작성할 수 있도록 합니다.

-----

## 핵심 도구 업데이트: `dart format` 및 `dart fix`

Dart 개발 워크플로우의 핵심인 `dart format`과 `dart fix` 도구는 2025년 상반기에 상당한 개선이 이루어졌으며, 이는 코드 스타일 및 유지보수 방식에 직접적인 영향을 미칩니다.

### 새로운 "Tall Style" 포맷팅 및 자동 후행 쉼표 처리

Dart 3.7부터 `dart format` 명령은 언어 버전에 따라 새로운 "**Tall Style**"을 적용합니다. 입력 파일의 언어 버전이 3.7 이상인 경우, 이 새로운 스타일이 자동으로 적용됩니다. 이 스타일은 인자 목록에 후행 쉼표를 추가했을 때와 유사하게 보이지만, 이제 포매터가 이러한 쉼표를 자동으로 추가하거나 제거합니다. Dart 3.8에서는 이 포매터가 더욱 개선되어, 단순히 쉼표를 추가하는 것을 넘어 구성 요소를 분할할지 여부를 지능적으로 결정하며, 전반적인 코드 출력을 더욱 정돈하고 개선하는 스타일 변경 사항이 포함되었습니다.

이 변화는 개발자가 더 이상 수동으로 후행 쉼표를 관리하거나 긴 인자 목록의 줄 바꿈을 신경 쓸 필요가 없음을 의미합니다. `dart format`이 이 작업을 자동으로 처리하여 일관된 코드 스타일을 유지하고 코드 리뷰 시 스타일 관련 논쟁을 줄여줍니다. 긴 함수 호출이나 위젯 트리가 자동으로 여러 줄로 분할되고 후행 쉼표가 추가되어 가독성이 크게 향상됩니다. 이는 특히 Flutter 개발에서 복잡한 위젯 트리를 다룰 때 유용합니다.

**예시**:

```dart
// Dart 3.7 이전 (줄 바꿈을 위한 수동 후행 쉼표)
longFunction(longArgument, anotherLongArgument,);

// Dart 3.7+ 새로운 Tall Style (포매터가 후행 쉼표를 자동으로 추가/제거하고 줄 바꿈)
longFunction(
  longArgument,
  anotherLongArgument,
);
```

이러한 변화는 Dart가 개발자 생산성과 코드 품질을 자동화된 방식으로 향상시키려는 지속적인 노력을 보여줍니다. "Tall Style"은 단순히 미적인 변화를 넘어, 복잡한 코드 구조(특히 Flutter의 중첩된 위젯)의 가독성을 근본적으로 개선하려는 의도가 담겨 있습니다. 이는 Go 언어의 `gofmt`와 같이 코드 포맷팅에 대한 더 강력한 의견을 제시하는 것과 유사합니다. 자동화를 통해 개발자는 미적 측면보다는 핵심 로직에 집중할 수 있게 되어 개발자 경험(DX)이 향상되고 협업 워크플로우가 간소화됩니다. 이는 지속적 통합/지속적 배포(CI/CD) 파이프라인에서 `dart format --check`의 중요성을 더욱 높여 코드 일관성을 보장하는 신뢰할 수 있는 게이트키퍼 역할을 수행하게 합니다.

### 프로젝트 단위 페이지 너비 설정 및 코드 영역 포맷팅 제외 기능

`dart format` 도구는 이제 프로젝트 단위의 유연한 제어 기능을 제공합니다. 이제 **`analysis_options.yaml`** 파일을 통해 프로젝트 단위로 선호하는 포맷팅 페이지 너비를 설정할 수 있습니다. 포매터는 파일이 위치한 디렉토리와 상위 디렉토리에서 \*\*`analysis_options.yaml`\*\*을 찾아 \*\*`formatter: page_width: 123`\*\*과 같은 설정을 적용합니다. 이를 통해 전체 디렉토리, 패키지 또는 여러 패키지에 걸쳐 일관된 포맷팅 너비를 설정할 수 있으며, `include` 키를 사용하여 구성을 공유할 수도 있습니다.

또한, 특정 코드 영역을 자동 포맷팅에서 제외할 수 있는 특별한 마커 주석(**`// dart format off`** 및 **`// dart format on`**)이 도입되었습니다. 이 주석은 정확히 해당 형식이어야 하며, 파일 내에 여러 영역이 있을 수 있지만 중첩되거나 겹칠 수는 없습니다. 이는 사용자 정의 레이아웃이 데이터 이해에 도움이 되는 고도로 구조화된 데이터(예: 대규모 숫자 목록)에 유용합니다. 마지막으로, **`// dart format width=XX`** 주석을 파일 시작 부분에 추가하여 단일 파일의 페이지 너비를 재정의할 수 있습니다. 이는 주로 생성된 코드(code generators)가 주변 **`analysis_options.yaml`** 파일의 설정을 알지 못할 때 유용합니다.

이러한 기능들은 개발 팀이 프로젝트의 특성이나 선호도에 따라 포맷팅 규칙을 더욱 세밀하게 제어할 수 있도록 합니다. 특히 코드 생성 도구를 사용하는 경우, 생성된 코드의 포맷팅 일관성을 보장하기가 훨씬 쉬워집니다. 또한, 특정 데이터 구조나 수동으로 정렬된 코드 블록이 자동 포맷팅으로 인해 손상되는 것을 방지할 수 있어, 개발자가 의도한 레이아웃을 유지할 수 있습니다.

이러한 기능의 추가는 `dart format`이 단순한 스타일 도구를 넘어, 팀 및 프로젝트 수준에서 코드베이스의 일관성과 유지보수성을 관리하는 데 필수적인 "**엔터프라이즈급**" 도구로 진화하고 있음을 보여줍니다. 이는 대규모 프로젝트나 여러 팀이 협업하는 환경에서 코드 스타일 충돌을 최소화하고 개발 워크플로우를 효율화하는 데 크게 기여할 것입니다. 이러한 고급 구성 옵션은 조직이 Dart를 기존 개발 표준 및 CI/CD 파이프라인에 통합하는 것을 용이하게 합니다. 이러한 유연성은 엄격한 코드 품질과 일관성이 중요한 엔터프라이즈 채택에 핵심적인 요소이며, Dart가 성숙한 도구를 갖춘 프로덕션 준비 언어라는 명성을 강화합니다.

### `dart format --fix` 제거 및 `dart fix`로의 전환

`dart format --fix` 명령에 대한 지원이 제거되었습니다. 이제 대신 \*\*`dart fix`\*\*를 사용해야 합니다. `dart fix`는 `dart format --fix`가 적용할 수 있었던 모든 수정 사항과 더 많은 수정 사항을 지원합니다.

이 변경은 개발자가 `dart format --fix` 대신 `dart fix`를 사용하여 코드베이스에 자동 수정 사항을 적용해야 함을 의미합니다. 이는 CI/CD 스크립트나 개발 환경 설정에서 명령어 업데이트가 필요함을 시사합니다. `dart fix`는 더 광범위한 코드 문제를 해결할 수 있으므로, 코드베이스의 품질과 최신 Dart 관행 준수를 더욱 효과적으로 유지할 수 있습니다.

이러한 변경은 Dart 도구의 "**책임 분리(separation of concerns)**"를 명확히 하려는 의도를 보여줍니다. `dart format`은 코드 스타일링에 집중하고, `dart fix`는 잠재적인 오류, 경고, 비권장 패턴을 수정하는 데 특화됩니다. 이는 도구의 목적을 명확히 하고, 개발자가 필요한 작업을 위해 올바른 도구를 더 쉽게 선택할 수 있도록 돕습니다. `dart fix`의 확장된 기능은 대규모 코드베이스에서 개발자가 프로젝트를 최신 Dart 언어 기능, 모범 사례 및 API 변경 사항에 따라 쉽게 업데이트할 수 있도록 합니다. 이는 시간이 지남에 따라 기술 부채를 줄이고 대규모 리팩토링 또는 마이그레이션 노력을 더 쉽게 관리할 수 있도록 하여 궁극적으로 코드 품질과 개발자 생산성 향상에 기여합니다.

### `--line-length` 옵션명 변경 (`--page-width`)

`dart format` 명령의 `--line-length` 옵션이 \*\*`--page-width`\*\*로 이름이 변경되었습니다.

`--line-length`는 여전히 하위 호환성을 위해 지원되지만, `--page-width`로 전환하는 것이 권장됩니다. 이 변경은 옵션 이름이 공개 API, 내부 구현 및 문서에서 "page width"라는 용어를 사용하는 것과 일치하도록 하기 위함입니다.

기존 스크립트나 설정에서 `--line-length`를 사용하고 있다면, `--page-width`로 업데이트하는 것이 좋습니다. 이는 향후 버전에서 `--line-length` 지원이 완전히 중단될 가능성에 대비하는 것입니다.

이러한 변경은 Dart 문서 및 도구 전반에 걸쳐 용어의 일관성과 명확성을 높이려는 노력의 일환입니다. "page width"로 용어를 표준화함으로써, 개발자가 문서를 읽거나 도구 사용법을 배울 때 혼란을 줄이고, Dart 생태계의 전반적인 사용자 경험을 개선하는 데 기여합니다. 이러한 명명 규칙에 대한 세심한 주의는 SDK의 전반적인 전문성과 사용 편의성에 기여합니다. 명확하고 일관된 용어는 새로운 개발자의 학습 곡선을 낮추고 숙련된 개발자의 효율성을 향상시켜 Dart를 잘 설계되고 사용자 친화적인 언어라는 명성을 강화합니다.

-----

## 주요 호환성 파괴 변경사항 및 마이그레이션 가이드

2025년 상반기 Dart 릴리스에는 기존 코드베이스에 영향을 미칠 수 있는 몇 가지 호환성 파괴 변경사항이 포함되어 있습니다. 개발자는 이러한 변경사항을 인지하고 필요한 마이그레이션 작업을 수행해야 합니다.

### Dart VM: Sound Null Safety 코드만 실행 (Unsound Null Safety 코드 실행 지원 제거)

Dart VM은 이제 **Sound Null Safety 코드**를 엄격하게 실행합니다. **`--no-sound-null-safety`** 옵션을 사용하여 Unsound Null Safety 코드를 실행하는 기능이 제거되었습니다.

이 변경은 모든 Dart 프로젝트가 이제 Sound Null Safety를 완벽하게 준수해야 함을 의미합니다. 기존에 `--no-sound-null-safety` 플래그에 의존하여 Unsound 코드를 실행하던 프로젝트는 더 이상 작동하지 않습니다. 개발자는 모든 코드베이스를 Null Safety로 완전히 마이그레이션해야 합니다. 이 변경은 런타임 Null 참조 오류를 근본적으로 방지하여 애플리케이션의 안정성과 예측 가능성을 크게 향상시킵니다.

이 변경은 Dart 2.12에서 도입되고 Dart 3.0에서 기본값이 된 Sound Null Safety의 "**완성**" 단계입니다. `--no-sound-null-safety` 옵션 제거는 Dart 팀이 Null Safety를 더 이상 선택 사항이 아닌, 언어의 핵심적이고 필수적인 부분으로 확고히 자리매김하겠다는 의지를 보여줍니다. 이는 Dart가 "안전성"을 최우선 가치로 두는 언어임을 명확히 합니다. 레거시 프로젝트에 상당한 마이그레이션 노력이 필요할 수 있지만, 이 변화는 궁극적으로 안정성과 신뢰성이 중요한 엔터프라이즈 및 미션 크리티컬 애플리케이션에 대한 Dart의 매력을 강화합니다. 이는 일반적인 버그 원인을 방지하고 코드 동작에 대한 추론을 단순화하여 장기적인 유지보수 부담을 줄여주므로, Dart를 복잡한 소프트웨어 개발을 위한 더욱 신뢰할 수 있는 플랫폼으로 만듭니다.

### `dart:html` 네이티브 클래스 확장 불가

`HtmlElement`와 같은 `dart:html`의 네이티브 클래스는 더 이상 확장(extend)할 수 없습니다. 이는 Dart 3.0.0에서 **`registerElement` API가 제거된 이후의 후속 조치**입니다. 이 클래스들은 이전에 사용자 정의 요소를 지원하기 위해 **`.created` 생성자**를 노출했지만, 이 생성자들이 제거되면서 클래스 확장이 불가능해졌습니다. 향후에는 이 클래스들이 인터페이스 클래스로도 지정될 수 있습니다.

이 변경은 `dart:html`을 사용하여 사용자 정의 웹 컴포넌트를 개발하고 `HtmlElement`와 같은 네이티브 클래스를 확장하던 기존 코드가 더 이상 유효하지 않음을 의미합니다. 개발자는 **`dart:js_interop` 및 `package:web`을 사용하는 새로운 웹 개발 패러다임으로 전환**해야 합니다. 특히 웹 기반 프로젝트에서 레거시 `dart:html` 확장에 의존하는 경우 상당한 리팩토링이 필요할 수 있습니다.

이 변경은 `dart:html` 라이브러리의 전반적인 Deprecation 및 `dart:js_interop` 및 `package:web`으로의 전환이라는 더 큰 전략적 움직임의 일부입니다. 이는 Dart가 웹 플랫폼과의 상호 운용성을 더욱 현대적이고 효율적인 방식으로 재정의하려는 의도를 명확히 보여줍니다. `dart:html`은 과거 웹 기술에 기반을 두었지만, 새로운 접근 방식은 최신 웹 표준 및 JavaScript 생태계와의 더 긴밀한 통합을 목표로 합니다. Dart 웹 애플리케이션을 구축하는 개발자에게 이는 중요한 아키텍처적 진화를 의미합니다. 이는 Dart의 미래 웹 개발이 직접적인 JavaScript 상호 운용성과 웹 특정 패키지에 점점 더 의존하게 될 것이며, 잠재적으로 더 세밀한 제어, 더 나은 성능, 그리고 방대한 JavaScript 생태계와의 더 쉬운 통합을 제공할 것임을 시사합니다. 이 변화는 Dart가 진화하는 웹 개발 환경에서 경쟁력을 유지하는 데 중요합니다.

### Dart C API 함수 제거 (`Dart_NewListOf`, `Dart_IsLegacyType`, `Dart_DefaultCanonicalizeUrl`)

Dart C API에서 `Dart_NewListOf`, `Dart_IsLegacyType`, `Dart_DefaultCanonicalizeUrl` 함수가 제거되었습니다.

이 변경은 Dart VM의 C API를 직접 사용하는 FFI(Foreign Function Interface) 기반 애플리케이션이나 플러그인이 이 제거된 함수에 대한 모든 호출을 업데이트하거나 대체해야 함을 의미합니다. 이는 주로 네이티브 코드와 Dart를 연동하는 고급 시나리오에 영향을 미칩니다.

C API 함수의 제거는 Dart VM의 내부 구조를 간소화하고, 더 이상 사용되지 않거나 더 나은 대안이 있는 기능을 정리하려는 노력의 일환입니다. 이는 Dart VM의 유지보수성을 향상시키고, 장기적으로는 더 안정적이고 효율적인 런타임을 제공하는 데 기여합니다. 특히 `Dart_IsLegacyType`의 제거는 Null Safety의 완전한 정착으로 인해 "레거시 타입"의 개념이 더 이상 필요 없게 되었음을 시사합니다. 이러한 API 정리 작업은 Dart VM의 핵심 기능을 더욱 견고하고 미래 지향적으로 만드는 데 기여하며, 이는 Dart 생태계의 전반적인 안정성과 성능에 긍정적인 영향을 미칩니다.

-----

## 결론

2025년 상반기 Dart SDK의 업데이트는 언어의 표현력 향상, 핵심 도구의 정교화, 그리고 플랫폼 전반의 안정성 및 호환성 강화라는 세 가지 주요 방향으로 진행되었습니다. Dart 3.7의 **와일드카드 변수 도입**과 Dart 3.8의 **Null-aware 요소 추가**는 개발자가 더 간결하고 의도가 명확한 코드를 작성할 수 있도록 지원하며, 이는 Dart가 안전성과 생산성을 동시에 추구하는 언어로서의 입지를 더욱 공고히 합니다.

`dart format`과 `dart fix` 도구의 개선은 개발 워크플로우의 효율성을 크게 높였습니다. 새로운 "**Tall Style**" 포맷팅과 유연한 프로젝트 단위 설정은 코드 일관성을 자동화하고 팀 간의 스타일 충돌을 줄이는 데 기여합니다. 또한 `dart fix`로의 기능 통합은 코드베이스의 품질을 지속적으로 향상시키는 데 필수적인 역할을 합니다.

마지막으로, Dart VM의 **Sound Null Safety 강제화**와 **`dart:html` 라이브러리의 현대화**는 Dart가 최신 기술 표준을 적극적으로 수용하고 미래 지향적인 개발 환경을 제공하려는 의지를 명확히 보여줍니다. 이러한 호환성 파괴 변경사항들은 단기적으로 마이그레이션 노력을 요구할 수 있지만, 장기적으로는 애플리케이션의 안정성과 유지보수성을 크게 향상시키며, Dart가 복잡하고 중요한 소프트웨어 프로젝트에 더욱 적합한 플랫폼으로 진화하고 있음을 나타냅니다.

종합적으로, 2025년 상반기 Dart의 변화는 개발자 경험을 개선하고, 코드 품질을 높이며, Dart 생태계를 더욱 견고하게 만드는 데 중점을 두었음을 보여줍니다. 이러한 지속적인 발전은 Dart가 Flutter와 웹을 포함한 다양한 플랫폼에서 강력하고 신뢰할 수 있는 개발 언어로서의 입지를 계속해서 강화할 것임을 시사합니다.
