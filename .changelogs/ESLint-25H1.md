# ESLint 25H1 핵심 변경사항

---

## I. 서론

ESLint는 **JavaScript** 및 **TypeScript** 코드의 품질, 일관성, 그리고 잠재적 오류를 보장하는 데 필수적인 정적 분석 도구로 자리매김하고 있습니다. 개발 워크플로우에 깊이 통합되어 코드 표준 준수를 자동화하고 개발 생산성을 향상시키는 데 기여합니다. 2025년 상반기(1월~6월)는 ESLint에 있어 중요한 변화와 발전이 있었던 시기였습니다. 이 기간 동안 ESLint는 여러 마이너 및 패치 릴리스를 통해 새로운 기능을 도입하고, 기존 기능을 개선하며, 특히 **TypeScript 생태계와의 통합을 크게 강화**했습니다. 이러한 변화들은 개발자들이 코드를 작성하고, 린팅 규칙을 구성하며, 전반적인 개발 프로세스를 관리하는 방식에 직접적인 영향을 미칩니다.

본 보고서는 2025년 상반기 ESLint의 모든 주요 변경사항을 종합적으로 분석하고, 그중 특히 코딩 구현 및 개발 워크플로우에 미치는 핵심적인 영향을 심층적으로 정리하는 것을 목표로 합니다. 각 변경사항의 기술적 내용과 함께, 실제 개발 환경에서의 의미와 활용 방안을 제시하여 독자가 ESLint의 최신 기능을 효과적으로 활용할 수 있도록 지원합니다.

---

## II. 2025년 상반기 ESLint 릴리스 개요

2025년 상반기 동안 ESLint는 꾸준히 업데이트를 진행하며, 거의 격주 단위로 마이너 릴리스를 발표했습니다. 이는 ESLint 팀이 사용자 피드백을 신속하게 반영하고, 최신 웹 기술 트렌드에 발맞춰 도구를 지속적으로 발전시키려는 의지를 보여줍니다. 이러한 민첩한 개발 주기는 ESLint가 현대 개발 환경의 요구사항을 빠르게 수용할 수 있도록 합니다.

ESLint는 대규모의 단일 업데이트보다는 작고 빈번한 업데이트를 통해 기능을 점진적으로 추가하고 개선하는 방식을 선호합니다. 이러한 접근 방식은 사용자들에게 최신 기능을 빠르게 제공하고, 잠재적인 문제를 신속하게 해결하며, 더 나아가 ESLint가 현대 웹 개발 생태계의 변화 속도에 효과적으로 보조를 맞출 수 있도록 합니다. 이는 안정성과 최신 기술 지원 사이의 균형을 유지하려는 전략적 노력을 반영합니다.

다음 표는 2025년 상반기 동안의 주요 ESLint 릴리스 버전과 날짜, 그리고 각 버전의 핵심적인 변경 유형을 요약하여 보여줍니다. 이를 통해 독자는 ESLint의 릴리스 주기와 각 버전의 주요 변경 유형을 한눈에 파악할 수 있으며, 보고서의 나머지 부분에서 설명될 세부 변경사항들의 맥락을 이해하는 데 도움이 됩니다.

Table 1: ESLint 2025년 상반기 릴리스 요약

| 버전 (Version)       | 릴리스 날짜 (Release Date) | 주요 변경 유형 (Key Change Type)                 |
| :------------------- | :------------------------- | :------------------------------------------- |
| v9.18.0              | 2025-01-10                 | TypeScript 설정 파일 공식 지원, 규칙 개선        |
| v9.25.0              | 2025-04-18                 | 규칙 옵션 추가, TypeScript 지원 강화           |
| v9.25.1              | 2025-04-21                 | 버그 수정                                    |
| v9.26.0              | 2025-05-02                 | MCP 서버 통합, 규칙 개선                     |
| v9.27.0              | 2025-05-16                 | MCP 서버 분리, 새 규칙 추가, TypeScript 지원 강화 |
| v9.28.0              | 2025-05-30                 | CLI 옵션 추가, TypeScript 지원 대폭 강화       |
| v9.29.0              | 2025-06-13                 | 최신 ECMAScript 문법 지원, 규칙 옵션 추가, TypeScript 지원 강화 |
| v9.30.0              | 2025-06-27                 | 설정 객체 `basePath` 속성, 규칙 옵션 추가        |
| @eslint/eslintrc v3.3.0 | 2025-02-21                 | 타입 정의 추가                               |
| @eslint/eslintrc v3.3.1 | 2025-03-21                 | 타입 정의 버그 수정                          |

---

## III. 코딩 구현에 영향을 미치는 핵심 변경사항

2025년 상반기 ESLint의 변화는 개발자의 코딩 구현 방식과 린팅 워크플로우에 직접적인 영향을 미치는 여러 중요한 개선사항을 포함합니다. 특히 TypeScript 생태계와의 통합 강화, 새로운 규칙 및 기존 규칙 옵션의 개선, 그리고 설정 및 CLI 도구의 발전은 주목할 만합니다.

### A. TypeScript 통합 강화

ESLint는 TypeScript를 사용하는 개발자들에게 더욱 원활한 경험을 제공하기 위해 TypeScript 지원을 전례 없이 강화했습니다. 이는 ESLint가 JavaScript 전용 린터에서 벗어나, TypeScript를 포함하는 범용 린터로서의 입지를 확고히 하려는 전략적 움직임으로 해석될 수 있습니다.

#### TypeScript 설정 파일 공식 지원

ESLint **v9.18.0**부터 TypeScript 설정 파일(확장자 `.ts`)에 대한 공식적인 안정화 지원이 구현되었습니다. 이는 몇 달간의 실험 기간을 거쳐 특별한 불만 없이 안정적인 기능으로 확정된 결과입니다. 이 변경은 ESLint가 TypeScript 생태계에 대한 전략적이고 깊이 있는 지원을 강화하고 있음을 보여주는 중요한 신호입니다.

과거에는 TypeScript 프로젝트에서 ESLint 설정을 관리할 때, `.js` 파일에 JSDoc을 사용하거나 별도의 빌드 과정을 거쳐야 하는 번거로움이 있었습니다. 이제 개발자들은 ESLint 설정을 TypeScript로 직접 작성함으로써, **타입 안전성, 자동 완성, IDE 지원** 등 TypeScript가 제공하는 이점을 설정 파일 작성 시에도 누릴 수 있습니다. 이는 설정 오류를 컴파일 시점에 발견하고, 설정 속성에 대한 정확한 타입 힌트를 받을 수 있도록 하여 설정 미스로 인한 런타임 오류를 줄이고, 설정 작업의 생산성을 높이는 데 기여합니다. 궁극적으로 이는 TypeScript 기반 프로젝트에서 설정 관리의 일관성과 개발 경험을 크게 향상시킵니다.

#### 코어 규칙의 TypeScript 구문 지원

2025년 상반기 ESLint 릴리스의 가장 두드러진 특징 중 하나는 **핵심 규칙에 대한 TypeScript 구문 지원이 점진적으로 확대**되었다는 점입니다. 이는 `@typescript-eslint/parser`와 같은 호환 가능한 파서를 사용할 경우, ESLint 코어 규칙이 TypeScript 코드를 더 정확하게 린팅할 수 있도록 합니다. 이러한 코어 규칙에 대한 TypeScript 지원의 체계적인 확장은 ESLint가 "범용 린터"로서의 입지를 강화하고, `@typescript-eslint`와 같은 외부 플러그인과의 역할 분담을 재정의하려는 전략적 움직임을 시사합니다.

과거에는 ESLint가 TypeScript 코드를 린팅하기 위해 주로 `@typescript-eslint/parser`와 `@typescript-eslint/eslint-plugin`에 크게 의존했습니다. 이제 ESLint 코어 규칙 자체가 TypeScript 구문을 이해하게 됨으로써, 개발자는 `@typescript-eslint` 플러그인의 특정 규칙 없이도 기본적인 TypeScript 코드 린팅을 수행할 수 있게 됩니다. 이는 설정의 복잡성을 줄이고, 잠재적인 규칙 충돌을 방지하며, 린팅 과정의 성능을 개선할 수 있습니다. 장기적으로 ESLint는 더 이상 JavaScript 전용 린터가 아니라, JavaScript와 그 주요 슈퍼셋인 TypeScript를 모두 포괄하는 진정한 범용 린터로 진화하고 있으며, 이는 TypeScript 개발자들에게 더 원활한 경험을 제공할 것입니다.

다음은 2025년 상반기에 TypeScript 구문 지원이 추가되거나 개선된 주요 코어 규칙들입니다:

* **v9.25.0**: `no-empty-function` 규칙은 새로운 TypeScript 특정 옵션인 `"privateConstructors"`, `"protectedConstructors"`, `"decoratedFunctions"`, `"overrideMethods"`를 `allow` 배열에 추가하여 TypeScript 환경에서 빈 함수 처리의 유연성을 증대시켰습니다. 또한 `no-invalid-this`, `no-loop-func`, `no-unused-expressions` 규칙들도 TypeScript 구문을 지원하게 되었습니다.
* **v9.27.0**: `max-params` 규칙은 TypeScript 구문을 완전히 지원하며, 새로운 TypeScript 특정 옵션인 `countVoidThis`를 포함합니다. 새로 추가된 `no-unassigned-vars` 규칙은 처음부터 TypeScript 구문을 지원하여 앰비언트 선언을 보고하지 않아 TypeScript 코드의 잠재적 버그를 사전 방지합니다.
* **v9.28.0**: `func-style` 규칙은 새로운 TypeScript 특정 옵션인 `"allowTypeAnnotation"`을 추가하고 오버로드된 함수 선언을 무시하도록 개선되었습니다. `no-magic-numbers` 규칙은 `"ignoreEnums"`, `"ignoreNumericLiteralTypes"`, `"ignoreReadonlyClassProperties"`, `"ignoreTypeIndexes"`와 같은 새로운 TypeScript 특정 옵션을 얻었습니다. `no-shadow` 규칙은 `"ignoreTypeValueShadow"` 및 `"ignoreFunctionTypeParameterNameValueShadow"`와 같은 TypeScript 특정 옵션을 포함하며, `"hoist"` 옵션도 새로운 TypeScript 특정 값을 허용합니다. `no-use-before-define` 규칙은 `"enums"`, `"typedefs"`, `"ignoreTypeReferences"`와 같은 새로운 TypeScript 특정 옵션을 추가했습니다. 마지막으로 `prefer-arrow-callback` 규칙도 TypeScript 지원을 포함하게 되었습니다.
* **v9.29.0**: `no-restricted-globals` 규칙은 타입 어노테이션 내 참조를 무시하도록 개선되었고, `no-var` 규칙은 전역 타입 선언 내 `var` 사용을 허용하도록 변경되었습니다.

이러한 변화를 통해 TypeScript 개발자는 `@typescript-eslint` 플러그인에 전적으로 의존하지 않고도, ESLint의 강력한 코어 규칙을 TypeScript 코드에 직접 적용할 수 있게 됩니다. 이는 거짓 양성(false positives) 또는 거짓 음성(false negatives)을 줄여 린팅의 정확성을 높이고, TypeScript 프로젝트의 코드 품질을 더욱 효과적으로 관리할 수 있게 합니다.

Table 2: 코어 규칙 개선 및 TypeScript 지원 현황

| 규칙명 (Rule Name)           | ESLint 버전 (ESLint Version) | 세부 변경사항 (Detailed Change)                                                                         | 코딩 구현 영향 (Impact on Coding Implementation)                       |
| :--------------------------- | :--------------------------- | :------------------------------------------------------------------------------------------------------ | :------------------------------------------------------------------- |
| `no-shadow-restricted-names` | v9.18.0, v9.26.0             | `import`, `class` 이름 및 `globalThis` 그림자 변수 검사 강화                                          | 혼란을 야기할 수 있는 변수명 사용 방지, 최신 JS 문법 지원 강화.      |
| `no-console`                 | v9.18.0                      | 허용된 console 메서드 명시 메시지 추가                                                              | 개발자가 허용된 대안을 쉽게 파악하여 코드 수정 시간 단축.            |
| `no-restricted-properties`   | v9.25.0, v9.29.0             | `allowObjects` 및 `allowProperties` 옵션 추가                                                         | 특정 객체에 대한 속성 사용을 세밀하게 제어, 엄격한 API 사용 패턴 강제. |
| `no-empty-function`          | v9.25.0                      | TypeScript 특정 옵션 추가(`privateConstructors`, `protectedConstructors`, 등)                         | TS 환경에서 빈 함수 처리 유연성 증대.                              |
| `no-unassigned-vars`         | v9.27.0                      | 새로운 규칙 도입 (TypeScript 지원)                                                                    | 선언되었지만 할당되지 않은 변수 사용으로 인한 잠재적 버그 사전 방지. |
| `max-params`                 | v9.27.0                      | TypeScript 구문 지원, `countVoidThis` 옵션 추가                                                       | TS 함수 매개변수 수 제한 규칙 강화.                                |
| `no-array-constructor`       | v9.27.0                      | 자동 수정(`autofixable`) 기능 추가                                                                    | `Array` 생성자 사용 관련 문제 자동 해결로 생산성 향상.             |
| `no-shadow`                  | v9.28.0                      | TypeScript 특정 옵션 추가(`ignoreTypeValueShadow`, 등)                                                | TS 코드에서 변수 그림자 현상 탐지 강화.                            |
| `no-use-before-define`       | v9.28.0                      | TypeScript 특정 옵션 추가(`enums`, `typedefs`, 등)                                                    | TS 코드에서 정의 전 사용 문제 탐지 강화.                           |
| `no-duplicate-imports`       | v9.30.0                      | `allowSeparateTypeImports` 옵션 추가                                                                | `import`와 `import type` 분리 허용 여부 제어.                      |

### B. 새로운 규칙 및 기존 규칙 옵션 개선

ESLint는 기존 규칙의 기능을 확장하고 새로운 규칙을 도입하여 코드 품질 검사의 정확성과 유연성을 높였습니다. 이러한 개선사항들은 개발자가 더욱 견고하고 가독성 높은 코드를 작성할 수 있도록 돕습니다.

#### `no-shadow-restricted-names` 규칙 개선

ESLint **v9.18.0**에서 `no-shadow-restricted-names` 규칙은 `import` 선언 및 `class` 이름(예: `import undefined from "foo"; class NaN {}`)에서도 제한된 이름 사용을 검사하도록 확장되었습니다. 이 규칙은 **`NaN`**, **`undefined`**와 같이 개발자에게 혼란을 줄 수 있는 내장된 전역 변수나 예약어의 섀도잉을 방지하는 데 목적이 있습니다. JavaScript가 `import` 구문, `class` 문법과 같은 새로운 문법 구조를 도입함에 따라, ESLint는 이러한 최신 문법에서도 개발자가 혼란스러운 변수명을 사용하거나 중요한 전역 객체를 실수로 섀도잉하여 예측 불가능한 동작을 유발하는 것을 방지하려는 의도를 보여줍니다.

또한, **v9.26.0**에서는 `reportGlobalThis` 옵션이 `true`로 설정될 경우 `globalThis`의 섀도잉(shadowing)을 감지하도록 지원이 추가되었습니다. 이 규칙의 지속적인 확장은 ESLint가 JavaScript 언어의 진화에 발맞춰 규칙을 능동적으로 업데이트하고 있음을 보여줍니다. 이는 ESLint가 단순히 정적인 코드 스타일을 검사하는 것을 넘어, 언어의 동적인 변화를 추적하고 개발자가 최신 문법을 사용할 때 발생할 수 있는 잠재적인 함정을 미리 방지하는 역할을 강화하고 있다는 증거입니다. 궁극적으로 코드의 가독성과 견고성을 직접적으로 향상시킵니다.

#### `no-console` 규칙 메시지 개선

**v9.18.0**부터 `no-console` 규칙은 문제를 보고할 때 허용된 console 메서드의 이름을 명시하도록 업데이트되었습니다. 예를 들어, `warn`과 `error`만 허용된 경우 "**Unexpected console statement. Only these console methods are allowed: warn, error.**"와 같이 메시지가 표시됩니다. 린팅 오류 메시지가 더욱 구체화되어 개발자가 문제의 원인을 빠르게 파악하고, 설정된 규칙에 따라 허용되는 대안을 즉시 인지하여 코드 수정 시간을 단축할 수 있습니다. 이는 개발자 경험(DX)을 크게 개선합니다.

#### `no-restricted-properties` 규칙의 새로운 옵션

**v9.25.0**에서 `no-restricted-properties` 규칙에 `allowObjects` 옵션이 추가되어 특정 속성을 전역적으로 제한하면서도 특정 객체(예: `router.push()`, `history.push()`)에서는 허용할 수 있게 되었습니다. 이어서 **v9.29.0**에서는 `allowProperties` 옵션이 추가되어 특정 속성을 제외한 모든 속성을 제한할 수 있게 되었습니다. 이 옵션들은 `push`와 같은 일반적인 메서드 이름이 특정 프레임워크나 라이브러리 객체에서만 사용되도록 강제하는 등, 코드베이스 내에서 특정 API 사용 패턴을 매우 세밀하게 제어할 수 있게 합니다. 이는 대규모 프로젝트에서 코드 일관성과 아키텍처 원칙을 유지하는 데 필수적입니다.

#### `no-unused-expressions` 규칙의 `ignoreDirectives` 옵션

**v9.26.0**에서 `no-unused-expressions` 규칙에 `ignoreDirectives` 옵션이 추가되어 ES3 코드베이스에서 `"use strict"`와 같은 지시문이 사용되지 않는 표현식으로 보고되는 것을 방지합니다. 이 옵션은 레거시 코드베이스나 특정 환경에서 ESLint를 사용할 때 불필요한 거짓 양성 오류를 줄여, 린팅의 정확성을 높이고 개발자의 피로도를 감소시킵니다.

#### `eqeqeq` 규칙의 제안 (Suggestions)

**v9.26.0**에서 `eqeqeq` 규칙에 제안(suggestions) 기능이 추가되었습니다. 이는 자동 수정(autofix)과 유사하게, 개발자가 동등 연산자 사용 관련 문제를 더 쉽게 해결할 수 있도록 돕습니다. 개발자는 린팅 오류를 발견했을 때, IDE나 CLI를 통해 제공되는 제안을 활용하여 `==`를 `===`로 변경하는 등 코드를 빠르게 수정할 수 있어 생산성이 향상됩니다.

#### 새로운 규칙 `no-unassigned-vars`

**v9.27.0**에서 `no-unassigned-vars`라는 새로운 코어 규칙이 추가되었습니다. 이 규칙은 `let` 또는 `var`로 선언되었지만 값이 할당되지 않은 채 읽히는 변수를 보고하여, 항상 `undefined`가 될 변수 사용으로 인한 잠재적인 프로그래밍 실수를 식별합니다. 이 규칙은 런타임에 `undefined` 오류를 유발할 수 있는 흔한 실수를 린팅 단계에서 미리 잡아내어, 코드의 견고성을 높이고 디버깅 시간을 단축시킵니다.

#### `no-useless-escape` 규칙의 `allowRegexCharacters` 옵션

**v9.27.0**에서 `no-useless-escape` 규칙에 `allowRegexCharacters` 옵션이 추가되어 정규식 리터럴 내에서 특정 문자에 대한 불필요한 이스케이프를 허용합니다. 이는 정규식의 특정 패턴이나 가독성을 위해 의도적으로 불필요한 이스케이프를 사용하는 경우에 유연성을 제공하여, 린터가 과도하게 엄격하게 적용되는 것을 방지합니다.

#### `no-array-constructor` 규칙의 자동 수정 (Autofixable)

**v9.27.0**부터 `no-array-constructor` 규칙이 보고하는 대부분의 문제가 `--fix` 명령줄 옵션을 통해 자동으로 수정될 수 있게 되었습니다. `new Array()`와 같이 잠재적으로 혼란을 줄 수 있는 `Array` 생성자 사용을 자동으로 `[]`와 같은 안전한 리터럴로 변경하여, 코드베이스를 빠르게 정리하고 일관성을 유지할 수 있습니다. 이는 개발자의 수동 수정 노력을 크게 줄여줍니다.

#### `no-duplicate-imports` 규칙의 `allowSeparateTypeImports` 옵션

**v9.30.0**에서 `no-duplicate-imports` 규칙에 `allowSeparateTypeImports` 옵션이 추가되었습니다. 이 옵션을 `true`로 설정하면, 동일한 모듈을 참조하더라도 `import`와 `import type`을 별개의 사용으로 간주하여 중복으로 보고하지 않습니다. TypeScript 프로젝트에서 `import`와 `import type`을 분리하여 사용하는 패턴을 따르는 경우, 이 옵션을 통해 불필요한 린팅 오류를 방지하고 코드의 가독성을 유지할 수 있습니다.

### C. 설정 및 CLI 도구 개선

ESLint는 개발자의 설정 관리 및 명령줄 인터페이스(CLI) 사용 경험을 개선하기 위한 여러 기능들을 도입했습니다. 이는 특히 대규모 프로젝트나 복잡한 CI/CD 환경에서 ESLint를 더욱 효율적으로 활용할 수 있도록 돕습니다.

#### 설정 객체에 `basePath` 속성 추가

**v9.30.0**에서 설정 객체에 `basePath` 속성이 도입되었습니다. 이 속성을 사용하면 설정 객체가 적용되어야 하는 하위 디렉토리를 지정할 수 있으며, `files` 및 `ignores`에 정의된 패턴은 이 `basePath`를 기준으로 평가됩니다. `basePath` 속성의 도입은 ESLint가 대규모 프로젝트 및 모노레포 환경에서의 설정 관리 복잡성을 해결하려는 중요한 시도임을 나타냅니다.

모노레포와 같은 대규모 프로젝트에서는 여러 개의 하위 프로젝트가 존재하며, 각 프로젝트마다 다른 린팅 규칙이나 무시 패턴이 필요할 수 있습니다. 기존에는 이를 위해 여러 개의 `.eslintrc` 파일을 관리하거나, 복잡한 상대 경로를 사용해야 했습니다. `basePath`를 사용하면, 단일 설정 파일 내에서 특정 서브디렉토리에만 적용되는 린팅 규칙을 명확하게 정의할 수 있습니다. 이는 설정 파일의 가독성을 높이고, 중복을 줄이며, 설정 변경 시 오류 발생 가능성을 낮춥니다. 이 기능은 ESLint가 단순히 개별 프로젝트의 린팅을 넘어, 엔터프라이즈급 규모의 복잡한 코드베이스 관리를 위한 도구로서의 역량을 강화하고 있음을 의미합니다.

#### `v10_config_lookup_from_file` 안정화 플래그

**v9.30.0**에서 실험적이었던 설정 파일 해석 기능이 `basePath` 속성 추가와 함께 최종 확정되었으며, 기존의 `unstable_config_lookup_from_file` 플래그가 `v10_config_lookup_from_file`로 이름이 변경되었습니다. 이 새로운 동작은 다음 주요 ESLint 릴리스에서 기본값이 될 예정입니다. 개발자들은 다음 주요 버전(v10)의 변경사항에 미리 대비하고 새로운 설정 해석 방식을 점진적으로 도입할 수 있습니다. 이는 향후 버전 업그레이드 시 발생할 수 있는 마찰을 최소화합니다.

#### `SourceCode#isGlobalReference(node)` 메서드 추가

**v9.29.0**에서 `SourceCode` 클래스에 `isGlobalReference(node)`라는 새로운 메서드가 추가되었습니다. 이 메서드는 전달된 `Identifier` 노드가 `languageOptions.globals`, `/* global */` 주석 또는 `ecmaVersion`을 통해 구성된 전역 변수를 참조하는지 여부를 `true`로 반환합니다. 이 기능은 ESLint 규칙 개발자들에게 유용합니다. 전역 변수 사용을 식별하는 로직을 단순화하여, 더 정교하고 정확한 커스텀 린팅 규칙을 개발할 수 있도록 지원합니다.

#### `--prune-suppressions` CLI 옵션 개선

**v9.29.0**에서 `--prune-suppressions` CLI 옵션이 존재하지 않는 파일에 대한 억제(suppression) 항목도 제거하도록 기능이 확장되었습니다. 억제 파일(`eslint-suppressions.json`)이 코드베이스의 변경에 따라 자동으로 정리되어, 수동으로 불필요한 항목을 제거하는 번거로움을 줄이고 억제 파일의 정확성을 유지하는 데 도움이 됩니다.

#### `includeIgnoreFile()` 헬퍼 함수 개선

**v9.29.0**에서 `includeIgnoreFile()` 헬퍼 함수가 두 번째 선택적 `name` 매개변수를 받아, 이 함수가 반환하는 설정 객체에 사용자 지정 이름을 설정할 수 있게 되었습니다. 프로그래밍 방식으로 ESLint 설정을 생성하거나 관리하는 경우, 설정 객체의 식별 및 구성이 더욱 용이해집니다.

#### MCP 서버 통합 및 분리 (Model Context Protocol Server Integration & Separation)

**v9.26.0**에서 ESLint는 MCP(Model Context Protocol) 서버 통합을 지원하기 시작했습니다. 이는 ESLint가 AI 모델 및 도구와 상호작용하여 린팅 및 코드 분석과 같은 작업을 수행할 수 있도록 합니다. `--mcp` CLI 플래그를 통해 서버를 시작할 수 있습니다. 이어서 **v9.27.0**에서는 MCP 서버가 `@eslint/mcp`라는 별도의 패키지로 분리되었습니다. 이는 ESLint 코어의 종속성 수를 줄이기 위한 조치이며, `--mcp` ESLint CLI 플래그는 여전히 작동합니다.

MCP 서버의 도입과 이후 별도 패키지 분리는 ESLint가 AI 기반 개발 도구와의 상호운용성을 전략적으로 모색하고 있으며, 동시에 코어 모듈의 경량화와 모듈성을 추구하고 있음을 보여줍니다. AI 기반 코딩 도구(LLM)의 부상은 소프트웨어 개발 방식에 큰 변화를 가져오고 있으며, 린터는 이러한 도구들이 코드 품질을 분석하고 개선하는 데 핵심적인 역할을 할 수 있습니다. MCP 서버는 ESLint가 AI 모델과 통신할 수 있는 표준화된 인터페이스를 제공하여, AI가 ESLint의 린팅 기능을 활용하여 코드 제안을 개선하거나, 코드 수정 시 린팅 규칙을 준수하도록 돕는 등의 시나리오를 가능하게 합니다. 별도 패키지 분리는 코어 ESLint의 크기를 불필요하게 늘리지 않으면서도, AI 통합 기능을 필요로 하는 사용자만 해당 패키지를 설치하도록 하여 모듈성을 유지합니다. 이 움직임은 ESLint가 단순히 정적 분석 도구를 넘어, 미래의 AI 중심 개발 환경에서 핵심적인 구성 요소가 되려는 장기적인 비전을 가지고 있음을 시사합니다.

#### `ESLINT_FLAGS` 환경 변수

**v9.27.0**부터 기능 플래그를 `ESLINT_FLAGS` 환경 변수를 사용하여 설정할 수 있게 되었습니다. CI/CD 파이프라인이나 자동화된 환경에서 ESLint를 실행할 때, 특정 기능 플래그를 일관되게 적용하는 것이 훨씬 용이해집니다. 이는 설정 관리의 유연성을 높이고 자동화된 린팅 프로세스를 간소화합니다.

#### `eslint-suppressions.json` 정렬

**v9.27.0**에서 억제 파일(`eslint-suppressions.json`)의 객체 키가 정렬되어 불필요한 버전 관리 시스템(Git) diff를 방지합니다. 팀 환경에서 억제 파일을 공유하고 관리할 때, 의미 없는 변경사항으로 인한 충돌이나 혼란을 줄여 협업 효율성을 높입니다.

#### `--pass-on-unpruned-suppressions` CLI 옵션

**v9.28.0**에서 `--pass-on-unpruned-suppressions` CLI 옵션이 추가되어, 더 이상 코드에 존재하지 않는 억제 항목이 발견되더라도 ESLint가 오류 코드 2로 종료되지 않도록 합니다. 대량 억제(bulk suppressions) 기능을 사용하는 프로젝트에서, 사용되지 않는 억제 항목이 CI/CD 빌드를 실패시키지 않도록 유연성을 제공합니다. 이는 다양한 팀의 억제 관리 워크플로우에 맞춰 린팅 프로세스를 조정할 수 있게 합니다.

### D. ECMAScript 최신 문법 및 전역 변수 지원

ESLint는 JavaScript 언어 표준의 최신 변화와 제안을 빠르게 수용하여, 개발자들이 새로운 언어 기능을 조기에 도입하고 활용할 수 있도록 지원합니다.

#### ECMAScript 2026 Explicit Resource Management (`using`/`await using`) 지원

**v9.29.0**의 기본 파서인 `espree`가 ECMAScript 2026의 새로운 `using` 및 `await using` 선언 구문을 지원합니다. 이 구문을 파싱하려면 `languageOptions.ecmaVersion`을 `2026` 또는 `"latest"`로 설정해야 합니다. ESLint가 ECMAScript의 최신 제안 단계(Stage 3) 문법까지 적극적으로 파싱 지원하는 것은 ESLint가 "**미래 지향적인 도구**"로서의 역할을 강화하고 있음을 보여줍니다.

ECMAScript 제안은 여러 단계를 거쳐 표준으로 채택됩니다. Stage 3는 최종 표준에 매우 근접한 단계이지만, 아직 변경될 가능성이 있습니다. 대부분의 툴링은 표준이 확정된 후에야 지원을 시작하는 경향이 있습니다. ESLint가 이러한 제안 단계의 문법을 조기에 지원함으로써, 개발자들은 정식 표준 채택 이전에 새로운 언어 기능을 프로젝트에 도입하고 실험할 수 있게 됩니다. 이는 개발자들이 최신 기술을 빠르게 탐색하고, 피드백을 제공하며, 미래의 언어 변화에 대비할 수 있도록 돕습니다. 린팅 오류 없이 새로운 문법을 사용할 수 있다는 것은 개발 생산성에 직접적인 영향을 미칩니다. 이처럼 ESLint가 ECMAScript 표준화 프로세스의 초기 단계부터 문법 지원을 통합하는 것은, ESLint가 단순히 "현재"의 코드 품질 검사 도구를 넘어 "미래"의 JavaScript 개발을 선도하고 지원하는 도구로서의 위상을 확립하려는 의지를 보여줍니다.

#### 새로운 ECMAScript 2025 전역 변수 지원

**v9.29.0**부터 `Float16Array` 및 `Iterator`와 같은 새로운 ECMAScript 2025 전역 변수가 `languageOptions.ecmaVersion`이 `2025` 또는 `"latest"`로 설정될 경우 자동으로 활성화됩니다. 최신 ECMAScript 표준에 추가된 새로운 전역 객체나 API를 사용할 때 ESLint가 이를 올바르게 인식하여 "정의되지 않은 변수"와 같은 거짓 양성 오류를 발생시키지 않습니다. 이는 개발자가 수동으로 전역 변수를 설정할 필요를 줄여줍니다.

#### `class-methods-use-this` 규칙의 클래스 자동 접근자(auto-accessors) 지원

**v9.29.0**에서 `class-methods-use-this` 규칙이 클래스 자동 접근자(auto-accessors)를 지원하게 되었습니다. 이 언어 기능은 데코레이터(Decorators) 제안의 일부이며, 현재 Stage 3에 있지만 TypeScript에서는 이미 해당 구문을 사용할 수 있습니다. 데코레이터 제안의 핵심 부분인 자동 접근자를 사용하는 TypeScript 코드에 대해 `class-methods-use-this` 규칙이 올바르게 작동하여, 최신 문법을 사용하는 코드의 린팅 정확성을 보장합니다.

---

## IV. 기타 주목할 만한 변경사항

핵심적인 코딩 구현 관련 변경사항 외에도, ESLint의 전반적인 생태계와 성능을 개선하기 위한 여러 중요한 업데이트가 있었습니다.

### `@eslint/eslintrc` 패키지 릴리스

ESLint의 설정 시스템의 기반이 되는 `@eslint/eslintrc` 패키지는 2025년 상반기 동안 두 차례의 업데이트를 거쳤습니다. 2025년 2월 21일에 **v3.3.0**이 릴리스되어 `package.json`에 타입 정의가 추가되었고, 3월 21일에는 **v3.3.1**이 릴리스되어 `package.json`의 `types` 필드 관련 버그가 수정되었습니다. 이러한 업데이트는 전반적인 설정 처리의 안정성과 타입 정의의 정확성을 향상시켜 ESLint 사용 경험의 견고성을 더합니다.

### 성능 개선

**v9.29.0**에서 `getLocFromIndex` 메서드의 시간 복잡도가 개선되었습니다. 린팅은 특히 대규모 코드베이스에서 상당한 CPU 자원과 시간을 소모할 수 있는 작업입니다. 개발 워크플로우에서 린팅은 자주 실행되며, CI/CD 파이프라인의 중요한 부분입니다. `getLocFromIndex`와 같은 내부 핵심 메서드의 성능 개선은 전체 린팅 프로세스의 속도 향상으로 이어집니다. 이는 개발자가 코드를 저장할 때마다 발생하는 자동 린팅의 지연 시간을 줄이고, CI/CD 빌드 시간을 단축시켜 전반적인 개발 생산성을 높입니다. 이처럼 특정 내부 메서드의 성능 개선에 대한 명시적인 언급은, ESLint 팀이 단순히 기능 추가에만 집중하는 것이 아니라, 도구의 핵심적인 성능과 효율성에도 꾸준히 투자하고 있음을 나타냅니다. 이는 ESLint가 대규모 엔터프라이즈 환경에서도 신뢰할 수 있고 효율적인 도구로 자리매김하려는 노력을 반영합니다.

### `SourceCode` 메서드 `getIndexFromLoc` 오류 처리 변경

**v9.30.0**부터 `SourceCode` 메서드 `getIndexFromLoc`는 인수의 `column` 속성이 음수 값을 지정할 경우 오류를 발생시키도록 변경되었습니다. 이는 특정 엣지 케이스에서 기존 동작에 의존하던 코드에 잠재적인 영향을 미칠 수 있지만, API의 견고성과 예측 가능성을 높여 잘못된 입력으로 인한 예기치 않은 동작이나 충돌을 방지합니다.

---

## V. 개발자를 위한 권장사항

2025년 상반기 ESLint의 변화는 개발 워크플로우를 최적화하고 코드 품질을 향상시킬 수 있는 중요한 기회를 제공합니다. 이러한 변화를 효과적으로 활용하기 위한 몇 가지 권장사항을 제시합니다.

### 업그레이드 고려사항 및 마이그레이션 팁

* **정기적인 업데이트**: ESLint는 2025년 상반기 동안 매우 활발하게 업데이트되었습니다. 새로운 기능, 개선된 성능, 그리고 버그 수정을 활용하기 위해 프로젝트의 ESLint 버전을 최신으로 유지하는 것을 적극 권장합니다. 특히 마이너 릴리스는 하위 호환성을 유지하면서도 중요한 기능을 추가하므로, 지속적인 업데이트 정책을 수립하는 것이 좋습니다.
* **TypeScript 프로젝트의 최적화**: TypeScript를 사용하는 프로젝트의 경우, ESLint v9.x 버전으로의 업그레이드는 특히 중요합니다. TypeScript 설정 파일 지원 및 코어 규칙의 TypeScript 구문 지원 확대로 인해, `@typescript-eslint/parser`와 함께 최신 ESLint를 사용하면 린팅의 정확성과 개발 경험이 크게 향상될 것입니다. 기존 `@typescript-eslint` 플러그인의 규칙 중 코어 ESLint 규칙과 중복되거나 이제 코어에서 더 잘 지원되는 부분이 있는지 검토하여 설정을 최적화할 수 있습니다.
* **향후 버전 대비**: v9.30.0에서 안정화된 `v10_config_lookup_from_file` 플래그는 ESLint v10의 기본 동작이 될 예정입니다. 미리 이 플래그를 적용하여 새로운 설정 해석 방식에 익숙해지고, 다음 주요 버전으로의 마이그레이션을 원활하게 준비하는 것을 고려하십시오.

### 새로운 기능 및 규칙 옵션 활용 전략

* **세분화된 규칙 제어**: `no-restricted-properties` 규칙의 `allowObjects` 및 `allowProperties`와 같은 새로운 옵션을 활용하여 코드베이스 내에서 특정 API 사용 패턴을 더욱 엄격하게 강제하고 코드 일관성을 높이십시오.
* **잠재적 버그 사전 방지**: 새로 추가된 `no-unassigned-vars` 규칙을 활성화하여 초기화되지 않은 변수 사용으로 인한 런타임 오류를 린팅 단계에서 미리 감지하고 수정하십시오.
* **자동 수정 기능 활용**: `no-array-constructor`와 같이 자동 수정 기능이 추가된 규칙들을 `--fix` CLI 옵션과 함께 사용하여 코드 스타일을 자동으로 일관성 있게 유지하고 수동 수정 시간을 절약하십시오.
* **AI 기반 개발 연동**: AI 기반 코딩 도구를 사용하거나 도입을 고려 중인 경우, `@eslint/mcp` 패키지를 탐색하여 ESLint를 AI 워크플로우에 통합하는 방안을 모색하십시오.

### 개선된 CLI 도구를 통한 워크플로우 최적화

* **모노레포 설정 간소화**: `basePath` 속성을 활용하여 모노레포나 복잡한 다중 프로젝트 환경에서 ESLint 설정 파일을 더욱 효율적으로 관리하고, 설정 중복을 줄이십시오.
* **억제 파일 관리**: `--prune-suppressions` 옵션을 사용하여 더 이상 존재하지 않는 파일에 대한 억제 항목을 자동으로 정리하고, `--pass-on-unpruned-suppressions` 옵션을 통해 CI/CD 환경에서 억제 파일 관리의 유연성을 확보하십시오.
* **CI/CD 환경 설정**: `ESLINT_FLAGS` 환경 변수를 사용하여 CI/CD 파이프라인에서 ESLint의 특정 기능 플래그를 일관되고 쉽게 관리하십시오.

---

## VI. 결론

2025년 상반기 ESLint는 TypeScript 통합을 전례 없이 강화하고, 기존 규칙에 대한 세분화된 제어 옵션을 대거 추가하며, 개발자 경험을 개선하는 CLI 및 설정 관리 도구의 발전을 이루었습니다. 특히 **TypeScript 설정 파일의 안정화**와 **수많은 코어 규칙에 대한 TypeScript 구문 지원 확대**는 ESLint가 현대 웹 개발의 주요 흐름인 TypeScript 생태계에 대한 깊이 있는 지원을 제공하려는 전략적 움직임을 명확히 보여줍니다. 이는 ESLint가 더 이상 JavaScript 전용 린터가 아니라, JavaScript와 TypeScript를 모두 포괄하는 진정한 범용 린터로 진화하고 있음을 의미합니다.

또한, ECMAScript 2026의 `using` 구문과 같은 최신 언어 제안에 대한 선제적 지원, 그리고 AI 기반 개발 환경과의 상호운용성을 위한 MCP 서버 통합은 ESLint가 단순히 현재의 코드 품질을 검사하는 도구를 넘어, 미래의 JavaScript 및 TypeScript 개발을 선도하고 지원하는 "**미래 지향적인 도구**"로서의 위상을 확립하려 하고 있음을 시사합니다. 내부 메서드 성능 개선과 같은 지속적인 효율성 최적화 노력 또한 ESLint가 대규모 엔터프라이즈 환경에서 신뢰할 수 있는 도구로 자리매김하려는 의지를 보여줍니다.

이러한 지속적인 업데이트와 혁신은 개발 생산성을 높이고, 코드 품질을 향상시키며, 복잡한 프로젝트 환경에서의 린팅 관리를 더욱 효율적으로 만들 것입니다. 개발자들은 ESLint의 최신 변경사항들을 적극적으로 이해하고 활용함으로써, 더욱 견고하고 유지보수하기 쉬운 코드를 작성하고 효율적인 개발 워크플로우를 구축할 수 있을 것입니다.
