# Vite 25H1 핵심 변경사항

-----

## I. 서론

Vite는 Evan You가 개발한 차세대 프론트엔드 빌드 도구로, \*\*개발 경험(DX)\*\*을 혁신하는 데 중점을 둡니다. 이는 네이티브 ES 모듈(ESM)을 활용하여 개발 서버 시작 속도와 HMR(Hot Module Replacement) 성능을 획기적으로 개선하며, 기존 번들러(예: Webpack)의 개발 병목 현상을 효과적으로 해결합니다. Vite는 Vue, React, Svelte, Preact, Lit Element 등 다양한 프레임워크와 Vanilla JavaScript 앱을 지원하는 **프레임워크 불가지론적(framework-agnostic)** 도구이며, TypeScript, JSX, CSS 전처리기 등 풍부한 기능을 내장하고 있습니다. 프로덕션 빌드 시에는 Rollup을 사용하여 코드를 최적화된 정적 자산으로 번들링합니다.

2025년 상반기(1월\~6월) 동안 Vite는 중요한 변화와 발전을 겪었습니다. 이 기간 동안 Vite는 단순한 빌드 도구를 넘어 현대 프론트엔드 생태계의 핵심 인프라로 자리매김했습니다. 주간 npm 다운로드 수가 3,100만 건에 달하며, 이는 지난 7개월 동안 1,400만 건 증가한 수치로, Vite의 광범위한 채택과 영향력을 보여줍니다. 이러한 성장은 Vite가 개발자들 사이에서 '**모던 React 애플리케이션의 필수 빌드 도구**'로 확고히 자리 잡았음을 의미합니다. Vite가 다양한 프레임워크와 도구에 걸쳐 공통 기반을 제공함으로써, 각 프로젝트 유지 관리자는 핵심 기능 개발에 더 집중하고 중복 작업을 줄일 수 있습니다. 이처럼 Vite의 발전은 전체 프론트엔드 개발 환경에 상당한 파급 효과를 미치며, 개발팀이 최신 웹 기술을 효과적으로 활용하고 애플리케이션 성능을 향상시키는 데 필수적인 요소가 됩니다.

본 보고서는 2025년 상반기 Vite에 적용된 모든 주요 변경사항을 종합적으로 분석하고, 특히 개발자의 코딩 구현 방식 및 프로젝트 설정에 직접적인 영향을 미치는 핵심 업데이트에 초점을 맞춰 상세히 설명합니다. 이를 통해 개발팀이 최신 Vite 환경에 효과적으로 적응하고, 잠재적인 마이그레이션 이슈를 해결하며, 새로운 기능을 활용하여 개발 효율성과 애플리케이션 성능을 향상시키는 데 필요한 정보를 제공하고자 합니다.

-----

## II. 2025년 상반기 주요 릴리스 및 마일스톤

2025년 상반기는 Vite에게 중요한 전환점이었습니다. 특히 **Vite 7.0.0의 공식 출시**와 함께 여러 핵심적인 업데이트와 생태계 프로젝트와의 긴밀한 통합이 이루어졌습니다.

### Vite 7.0.0 정식 출시

2025년 6월 24일, Vite 7.0.0이 공식적으로 출시되었습니다. 이는 2025년 상반기 중 가장 중요한 업데이트로, Vite의 핵심 아키텍처와 개발자 경험에 중대한 변화를 가져왔습니다. Vite 7.0.0은 **`vite` 코어 패키지**뿐만 아니라 **`plugin-legacy`**, **`create-vite`** 등 주요 관련 패키지들의 7.0.0 버전을 포함합니다. 이 메이저 릴리스는 Node.js 지원 정책 변경, 기본 브라우저 타겟 변경, 그리고 Rust 기반 번들러인 Rolldown의 통합을 위한 기반 마련 등 여러 핵심적인 변경사항을 포함합니다.

Vite의 메이저 릴리스는 일반적으로 Node.js의 EOL(End-of-Life) 일정과 연동되어 발표됩니다. Node.js 18이 2025년 4월 말에 EOL에 도달함에 따라, Vite 7.0.0이 6월 말에 출시된 것은 이러한 전략적 연동의 결과입니다. 이러한 접근 방식은 Vite가 항상 활발히 유지 관리되고 보안이 강화된 Node.js 버전을 기반으로 작동하도록 보장합니다. 또한, Node.js 20.19+ 및 22.12+ 버전의 네이티브 ESM(ECMAScript Modules) 지원을 활용하여 Vite 7.0이 ESM-only로 배포될 수 있도록 합니다. 이러한 전략적인 버전 관리는 Vite의 내부 코드베이스를 간소화하고(예: 이전 Node.js 버전에 대한 호환성 레이어 유지 불필요), 네이티브 기능을 활용하여 성능을 향상시키는 데 기여합니다. 개발자 입장에서는 Vite와 Node.js 환경 간의 명확한 업그레이드 경로를 제공하여 잠재적인 호환성 문제를 줄이는 이점이 있습니다.

### 주요 패치 및 마이너 업데이트 요약

Vite는 고정된 릴리스 주기 없이 필요에 따라 패치(일반적으로 주간) 및 마이너(일반적으로 격월 베타 포함) 릴리스를 진행합니다. 2025년 상반기 동안 Vite는 여러 보안 취약점에 대한 패치 릴리스를 포함하여 6.x 버전대의 지속적인 업데이트를 진행했습니다. 예를 들어, 5월 5일에는 **Vite 6.3.5**가 안정 버전으로 릴리스되었습니다. 또한, **`rolldown-vite` 패키지**도 5월 중 여러 패치 버전(예: v6.3.9, v6.3.10, v6.3.11, v6.3.12, v6.3.13, v6.3.14, v6.3.18)이 릴리스되며 활발히 개발되었습니다. 이는 Rolldown 통합의 실험적 특성과 지속적인 개선 노력을 반영합니다. 2025년 1월 9일에는 **`qmhc/vite-plugin-dts`의 v4.5.0**과 같은 플러그인 업데이트도 있었습니다.

### 관련 생태계 프로젝트 업데이트

Vite의 강력한 성능과 유연성은 다양한 프론트엔드 생태계 프로젝트의 채택과 발전을 이끌었습니다.

* **Aurelia 2**: 2025년 2월 5일, Aurelia 2는 Vite 플러그인을 통해 실험적인 단일 파일 컴포넌트(SFC) 지원을 발표했습니다. 이 지원은 HTML, CSS, JavaScript를 단일 파일로 결합하여 개발을 간소화하고 Vite의 성능 이점을 활용할 수 있게 합니다. 이는 Aurelia 개발자들에게 더욱 효율적인 워크플로우를 제공합니다.
* **Shopify Hydrogen**: 2025년 3월, Shopify Hydrogen은 Vite 5에서 Vite 6으로의 마이그레이션을 완료했으며, Remix 2.16.0 버전의 Vite 6 업그레이드를 따랐습니다. 이 마이그레이션은 Hydrogen 애플리케이션의 성능 향상과 HMR 개선을 가져왔습니다.
* **Vitest**: Vite 7.0.0 출시와 함께 Vitest는 3.2 버전부터 Vite 7.0을 지원하기 시작했습니다. 이는 Vite 기반 프로젝트의 테스트 환경을 안정적으로 유지하는 데 중요합니다.
* **Vue.js**: 2025년 6월 18일, Vue.js는 안정 버전 3.5.17을 릴리스했습니다. Vite는 Vue.js의 창시자인 Evan You에 의해 만들어졌으며, Vue.js 개발에 깊이 연관되어 있습니다.

이러한 주요 프레임워크 및 도구들의 Vite 통합 또는 마이그레이션은 단순한 개별 프로젝트의 선택을 넘어선 중요한 추세를 나타냅니다. Vite의 아키텍처와 성능 이점(빠른 HMR, 간소화된 개발)이 광범위하게 인정받고 있으며, 이는 Vite가 프론트엔드 빌드 도구로서의 입지를 더욱 공고히 하는 데 기여합니다. 이러한 강력한 통합은 상호 이익이 되는 관계를 형성합니다. Vite가 발전함에 따라, 이러한 프레임워크들은 새로운 기능과 성능 향상을 누릴 수 있습니다. 반대로, 이들 프레임워크의 광범위한 채택은 Vite 코어에 대한 추가 투자를 장려하여, 결과적으로 모든 사용자에게 더 강력하고 기능이 풍부한 도구를 제공합니다. 이러한 "**광범위한 생태계 지원**"은 유지 관리자들이 "**공통 기반을 공유하고 시간이 지남에 따라 함께 개선할 수 있다**"는 것을 의미하며, 이는 프론트엔드 기술 스택 전반에 걸쳐 지식과 모범 사례의 공유를 촉진합니다.

다음 표는 2025년 상반기 동안의 주요 Vite 릴리스 및 관련 업데이트를 요약한 것입니다.

### 표 1: 2025년 상반기 Vite 주요 릴리스 요약

| 릴리스 버전/이벤트            | 릴리스 날짜      | 유형             | 주요 변경사항/의미                                |
| :-------------------------- | :--------------- | :--------------- | :------------------------------------------------ |
| `qmhc/vite-plugin-dts` v4.5.0 | 2025년 1월 9일   | 생태계 플러그인  | 플러그인 업데이트                                   |
| Aurelia 2 SFC 지원          | 2025년 2월 5일   | 프레임워크 통합  | Vite 플러그인을 통한 실험적 단일 파일 컴포넌트(SFC) 지원 도입 |
| Shopify Hydrogen Vite 6 마이그레이션 | 2025년 3월      | 프레임워크 통합  | Vite 5에서 Vite 6으로 마이그레이션 완료, 성능 및 HMR 개선 |
| Vite 6.3.5                  | 2025년 5월 5일   | 코어 패치/마이너 | 안정 버전 릴리스                                   |
| `rolldown-vite` v6.3.x 패치   | 2025년 5월 11일 \~ 6월 5일 | 코어 패치/마이너 | Rolldown 통합의 지속적인 실험 및 개선             |
| Vue.js 3.5.17               | 2025년 6월 18일  | 프레임워크 업데이트 | Vue.js 안정 버전 릴리스                             |
| Vite 7.0.0                  | 2025년 6월 24일  | 메이저 릴리스    | Node.js 18 EOL, Baseline 브라우저 타겟 변경, Rolldown 통합 기반 마련 |
| `plugin-legacy` 7.0.0       | 2025년 6월 24일  | 코어 패키지      | Vite 7.0.0과 함께 릴리스된 레거시 플러그인 업데이트 |
| `create-vite` 7.0.0         | 2025년 6월 24일  | 코어 패키지      | Vite 7.0.0과 함께 릴리스된 프로젝트 스캐폴딩 도구 업데이트 |
| Vitest 3.2+                 | 2025년 6월 24일  | 생태계 도구      | Vite 7.0 호환성 지원 시작                         |

-----

## III. 코딩 구현에 영향을 미치는 핵심 변경사항

2025년 상반기 Vite의 변경사항 중 개발자의 코딩 구현 방식과 프로젝트 설정에 직접적인 영향을 미치는 핵심 사항들을 자세히 살펴봅니다. 다음 표는 이러한 핵심 변경사항들을 요약한 것입니다.

### 표 2: 코딩 구현 관련 핵심 변경사항 요약

| 변경사항                  | 영향 영역                          | 핵심 내용                                         | 개발자 시사점                                     |
| :---------------------- | :--------------------------------- | :------------------------------------------------ | :------------------------------------------------ |
| Node.js 지원 정책 변경  | 개발 환경, 호환성                  | Node.js 18 지원 종료 및 필수 버전 20.19+ 또는 22.12+로 상향, Vite 7.0의 ESM-only 배포 | Node.js 업그레이드 필수, CommonJS 의존성 검토     |
| 기본 브라우저 타겟 변경  | 빌드 출력, 호환성                  | `build.target`이 'modules'에서 'baseline-widely-available'로 전환, 최신 브라우저 버전 지원 | 구형 브라우저 지원 시 `build.target` 명시적 조정 필요, `plugin-legacy` 역할 변화 |
| 코어 현대화: Rolldown 통합 | 빌드 프로세스, 성능, 개발자 경험   | Rust 기반 차세대 번들러, 빌드 시간 단축, `rolldown-vite` 패키지 실험적 사용 | 대규모 앱 빌드 최적화 가능성, `vite.config.js` 빌드 설정 검토 |
| Vite DevTools 도입      | 개발자 경험, 디버깅                | 모듈 그래프, 번들 최적화, HMR 흐름 등 심층 디버깅 및 분석 도구 제공 | 새로운 디버깅 워크플로우 학습, 성능 문제 진단 용이 |
| 플러그인 API 및 설정 변경 | API, 설정                          | `enforce` 대신 `order`, `transform` 대신 `handler` 사용 권장, `optimizeDeps.entries`의 glob 패턴 처리, 일부 API 속성 및 타입 제거 | 기존 커스텀 플러그인 및 설정 업데이트 필요, SSR 설정 영향 |
| 보안 취약점 패치        | 보안, 개발 서버                    | CVE-2025-31125 및 CVE-2025-31486 임의 파일 읽기 취약점 패치 | 즉각적인 보안 패치 적용, 개발 서버 노출 시 보안 강화 |
| 프레임워크별 통합 및 개선 | 프레임워크 통합, 성능              | React 앱에서 SWC 활용 (`@vitejs/plugin-react-swc`), Aurelia 2의 단일 파일 컴포넌트(SFC) 지원, Vitest 7.0 호환성 | 프레임워크별 플러그인 및 설정 업데이트, 새로운 기능 활용 |

### Node.js 지원 정책 변경

Vite 7.0부터는 **Node.js 20.19+ 또는 22.12+ 버전이 필수로 요구됩니다.** 이는 Node.js 18이 2025년 4월 말에 EOL(End-of-Life)에 도달함에 따라 Vite가 해당 버전 지원을 중단한 결과입니다. 이러한 변경은 개발 환경에서 Node.js 버전을 업데이트해야 함을 의미합니다. 기존 Node.js 18 환경에서 Vite 7.0으로 업그레이드할 경우 빌드 또는 개발 서버 실행 시 오류가 발생할 수 있으므로, **`package.json`의 `engines` 필드 업데이트**를 고려하여 프로젝트의 Node.js 요구 사항을 명확히 하는 것이 권장됩니다.

Node.js 20.19+ 및 22.12+ 버전의 네이티브 ESM(ECMAScript Modules) 지원을 활용하여, Vite 7.0은 **ESM-only로 배포됩니다.** 이는 추가적인 플래그 없이 Node.js의 `require(esm)` 지원을 활용하기 위함입니다. 대부분의 최신 프로젝트는 이미 ESM 기반으로 구성되어 있어 큰 영향이 없을 수 있습니다. 그러나 CommonJS(CJS) 모듈에 의존하는 특정 라이브러리나 커스텀 스크립트가 있는 경우, ESM 호환성 문제를 검토하고 필요에 따라 트랜스파일링 또는 번들링 설정을 조정해야 할 수 있습니다. 이러한 모듈 로딩 방식의 근본적인 변화는 프론트엔드 생태계 전반의 ESM 전환을 가속화하는 중요한 단계입니다. Vite와 같은 주요 빌드 도구가 ESM-only 배포를 채택함으로써, 개발자와 라이브러리 유지 관리자들은 코드베이스의 ESM 호환성을 보장하도록 강력하게 권장됩니다. 이는 CJS/ESM 이중 패키지 관리의 복잡성을 줄이고 모듈 해결을 간소화하여, 트리 쉐이킹(tree-shaking) 및 코드 분할과 같은 최적화 기능을 더욱 효과적으로 활용할 수 있게 합니다. 결과적으로 더 통일되고 효율적인 JavaScript 모듈 시스템으로 나아가며, 개발자들은 더 예측 가능하고 현대적인 모듈 로딩 경험을 얻게 될 것입니다.

### 기본 브라우저 타겟 변경

Vite 7.0은 `build.target`의 기본값을 기존 'modules'에서 '**baseline-widely-available**'로 변경했습니다. 이 새로운 타겟은 Baseline 이니셔티브와 연동되어, 주요 브라우저에서 최소 30개월 이상 널리 지원되는 웹 플랫폼 기능을 기준으로 합니다. 업데이트된 기본 브라우저 버전은 Chrome 87 → 107, Edge 88 → 107, Firefox 78 → 104, Safari 14.0 → 16.0 등으로, 이는 2022년 11월 1일 이전에 출시된 브라우저 버전을 의미합니다.

이 변경은 Vite가 생성하는 번들된 코드의 JavaScript 구문 및 API 호환성에 직접적인 영향을 미칩니다. 'baseline-widely-available'은 더 최신 JavaScript 기능을 활용할 수 있음을 의미하므로, 구형 브라우저를 지원해야 하는 경우 `build.target`을 명시적으로 'es2015' 또는 'esnext'와 같이 조정해야 할 수 있습니다. 만약 `plugin-legacy`를 사용하여 구형 브라우저를 지원하고 있었다면, 이 변경으로 인해 `plugin-legacy`의 동작 방식이나 필요성이 달라질 수 있습니다. `plugin-legacy`는 Vite 7.0.0과 함께 7.0.0 버전으로 릴리스되었습니다.

이러한 변화는 웹 표준 준수 및 개발 복잡성 감소를 위한 생태계 전반의 노력을 반영합니다. Vite는 'baseline-widely-available'을 채택함으로써, 널리 지원되는 현대 웹 표준의 사용을 적극적으로 장려하고, 대부분의 사용자에게 이미 광범위하게 사용 가능한 기능에 대한 폴리필(polyfill)이나 트랜스파일링(transpiling)에 대한 의존도를 줄입니다. 이는 기본 빌드 출력의 복잡성을 줄여 잠재적으로 번들 크기를 줄이고 최신 브라우저에서 실행 속도를 높일 수 있습니다. 또한, 개발자들이 대부분의 사용자를 위해 더 현대적인 JavaScript/CSS 기능을 사용할 수 있게 하여 개발을 간소화합니다. 진정으로 레거시 브라우저를 지원해야 하는 경우, `plugin-legacy`를 포함하는 것이 명시적인 선택이 되도록 합니다. 이러한 Vite의 움직임은 상시 업데이트되는 브라우저를 수용하고, 웹 개발 노력을 현대 웹 API에 집중하는 광범위한 산업 추세를 반영합니다. 이는 궁극적으로 더 빠르고, 견고하며, 유지 관리하기 쉬운 웹을 구축하는 데 기여합니다.

### 코어 현대화: Rolldown 통합

VoidZero 팀이 개발 중인 **Rolldown은 Rust로 작성된 차세대 번들러**입니다. 이 프로젝트는 Vite의 코어를 현대화하려는 노력의 핵심이며, 향후 Vite의 기본 번들러가 될 예정입니다. Rolldown의 목표는 속도(Rust 기반), 기존 Rollup 플러그인과의 호환성, 그리고 esbuild 및 Rollup을 넘어서는 최적화 기능(예: 고급 청크 분할 제어, 내장 HMR, Module Federation)을 제공하는 것입니다.

Vite는 현재 개발 시 esbuild를, 프로덕션 빌드 시 Rollup을 사용합니다. Rolldown은 이 두 가지를 단일 고성능 번들러로 통합하여 복잡성을 줄이고 빌드 시간을 크게 단축시키는 것을 목표로 합니다. 특히 대규모 프로젝트에서 빌드 시간 감소가 두드러질 것으로 예상됩니다. Rolldown 통합은 개발 및 프로덕션 환경 간의 일관된 동작, 페이지 새로고침 시 네트워크 오버헤드 감소, ESM 출력 기반의 효율적인 HMR 유지 등 "**Full Bundle Mode**"를 가능하게 할 것입니다.

현재 Rolldown 기반 Vite는 \*\*`rolldown-vite`\*\*라는 별도 패키지로 제공됩니다. `package.json`에서 `vite`를 `rolldown-vite`로 alias하여 드롭인 대체로 사용할 수 있습니다. `rolldown-vite`는 실험적 단계이며, 패치 버전 내에서도 호환성 문제가 발생할 수 있습니다. 향후 이 기능은 Vite 메인 저장소로 병합될 예정입니다. 개발자는 `rolldown-vite`를 사용하여 프로젝트의 빌드 성능을 테스트하고 피드백을 제공할 수 있습니다. 이는 특히 대규모 애플리케이션의 빌드 시간을 최적화하려는 경우 유용합니다.

`vite.config.js`에서 `rollupOptions`를 통해 수동 청크 분할(`manualChunks`)을 제어하는 등의 빌드 최적화 설정은 Rolldown 통합 후에도 중요하게 유지될 수 있습니다.

Rust 기반 도구의 프론트엔드 빌드 생태계 침투 가속화는 Rolldown 통합의 중요한 측면입니다. Rolldown은 Rust로 작성되었으며 (esbuild는 Go), 이는 성능에 민감한 웹 개발 도구들이 Rust나 Go와 같은 저수준의 더 빠른 언어로 재작성되는 광범위한 추세의 일부입니다. 이러한 추세는 현대 웹 애플리케이션의 복잡성과 규모가 증가함에 따라 JavaScript 네이티브 도구들이 성능 한계에 도달하면서 가속화되고 있습니다. Vite의 Rolldown 채택은 이러한 추세를 크게 가속화할 것입니다. 이는 대규모 애플리케이션에 필수적인 "**속도**"와 "**최적화**" 원칙을 직접적으로 다룹니다. 개발자는 특히 대규모 프로젝트에서 빌드 시간이 크게 단축되는 것을 경험하게 될 것이며, 이는 개발자 경험(DX) 향상으로 직접 연결됩니다. 이는 또한 개발자가 주로 JavaScript/TypeScript를 작성하더라도, 저수준 언어로 구축된 도구 체인의 근본적인 변화를 인지해야 함을 의미합니다. 프론트엔드 도구의 미래는 고수준 언어(애플리케이션 로직)와 저수준 언어(성능에 민감한 인프라)의 하이브리드 형태가 될 가능성이 높습니다.

### Vite DevTools 도입

VoidZero와 NuxtLabs의 전략적 파트너십을 통해 Anthony Fu가 **Vite DevTools** 개발을 주도하고 있습니다. 이 도구는 모든 Vite 기반 프로젝트 및 프레임워크에 대해 더 깊고 통찰력 있는 디버깅 및 분석 기능을 제공하여 개발 경험을 향상시킬 것입니다. 새로운 DevTools는 개발자가 애플리케이션의 모듈 그래프, 번들 최적화, HMR 흐름 등을 시각적으로 이해하고 문제를 진단하는 데 도움을 줄 것입니다. 이는 복잡한 애플리케이션에서 성능 병목 현상을 식별하고 해결하는 데 특히 유용할 수 있으며, 전반적인 디버깅 워크플로우를 개선하여 개발 생산성을 향상시킬 것으로 기대됩니다.

Vite는 항상 개발자 경험(DX)을 최우선으로 여겨왔습니다. 즉각적인 서버 시작, 번개처럼 빠른 HMR, 그리고 최소한의 설정은 Vite의 핵심 DX 기능입니다. 전용 DevTools의 도입은 이러한 철학의 자연스러운 확장으로, 단순히 빌드 속도를 넘어 전체 개발 수명 주기를 포괄합니다. 빠른 빌드 시간도 중요하지만, 빌드 프로세스가 왜 느린지 또는 내부적으로 어떻게 작동하는지 이해하려면 종종 전문화된 도구가 필요합니다. DevTools는 이러한 격차를 메워 개발자가 코드와 구성을 더 효과적으로 최적화할 수 있도록 합니다. 이는 개발자에게 가해지는 인지 부하를 줄여주는 DX에 대한 선제적인 접근 방식입니다. 이러한 추세는 현대 프론트엔드 개발에서 "**개발자 경험**"이 더 이상 빠른 도구에만 국한되지 않고, 포괄적인 통찰력과 디버깅 기능을 제공하는 것을 포함한다는 것을 강조합니다. 애플리케이션의 복잡성이 증가함에 따라, 그 동작을 쉽게 이해하고 최적화하는 능력이 빌드 시스템의 순수한 속도만큼 중요해지고 있습니다.

### 플러그인 API 및 설정 변경

Vite 6에서 `enforce` 대신 \*\*`order`\*\*를, `transform` 대신 \*\*`handler`\*\*를 사용하도록 변경되었습니다. 이는 Rollup의 객체 훅 인터페이스와 정렬하기 위함입니다. 기존 `vite.config.js` 파일에서 커스텀 플러그인을 사용하고 있거나 특정 플러그인 설정이 `enforce` 또는 `transform` 속성을 사용하는 경우, 이를 `order` 및 `handler`로 업데이트해야 합니다.

`optimizeDeps.entries`는 이제 리터럴 문자열 경로 대신 항상 **glob 패턴으로 처리됩니다.** `optimizeDeps.entries`를 사용하여 종속성 사전 번들링 대상을 명시적으로 지정하는 경우, 이제 해당 경로를 glob 패턴 형식으로 작성해야 합니다. 예를 들어, `['./src/main.js']` 대신 `['./src/**/*.js']` 또는 `['./src/main.js']`처럼 단일 파일도 glob 패턴으로 인식됩니다.

Vite 6에서 더 이상 사용되지 않는 `legacy.proxySsrExternalModules` 속성이 제거되었습니다. 또한, `ModuleRunnerOptions.root`, `ViteDevServer._importGlobMap`, `ResolvePluginOptions.isFromTsImporter`, `ResolvePluginOptions.getDepsOptimizer`, `ResolvePluginOptions.shouldExternalize`, `ResolvePluginOptions.ssrConfig`와 같은 타입 전용 속성 및 `HMRBroadcaster`, `HMRBroadcasterClient`, `ServerHMRChannel`, `HMRChannel`과 같은 HotBroadcaster 관련 타입이 제거되었습니다. 이러한 제거된 속성이나 타입을 직접적으로 사용하고 있던 프로젝트는 해당 부분을 업데이트하거나 대체 로직을 구현해야 합니다. 특히 커스텀 플러그인이나 복잡한 SSR(Server-Side Rendering) 설정에서 영향을 받을 수 있습니다.

일부 미들웨어(middleware)가 `configureServer` 및 `configurePreviewServer` 훅 이전에 적용되도록 변경되었습니다. `server.cors` 또는 `preview.cors` 옵션이 특정 경로에 적용되지 않도록 하려면, 응답에서 관련 헤더를 직접 제거해야 할 수 있습니다. 이는 커스텀 서버 미들웨어를 사용하는 경우 주의가 필요합니다.

이러한 API 및 설정 변경은 Vite의 API 설계가 성숙해지고 있음을 나타냅니다. Rollup과의 일관성을 추구함으로써, Vite는 두 도구를 모두 사용하는 개발자들의 인지 부하를 줄입니다. 또한, 더 이상 사용되지 않거나 기능하지 않는 기능을 제거함으로써 코드베이스를 간소화하여 장기적으로 유지 관리, 디버깅 및 확장을 용이하게 합니다. 이러한 변경이 기존 구성에 대한 호환성을 깨뜨릴 수 있지만, 이는 더 견고하고 예측 가능한 시스템으로 나아가는 과정입니다. 이 추세는 Vite가 더 안정적이고 확고한 API 표면으로 이동하고 있음을 시사하며, 이는 특정 영역에서 향후 호환성을 깨뜨리는 변경의 가능성을 줄입니다. 개발자 입장에서는 초기 마이그레이션에 약간의 노력이 필요할 수 있지만, 장기적인 이점은 더 신뢰할 수 있고 이해하기 쉬운 구성 및 플러그인 생태계입니다. 이는 또한 내부 코드 품질 및 유지 관리성에 대한 약속을 의미하며, 이는 간접적으로 Vite의 전반적인 안정성과 성능에 기여합니다.

### 보안 취약점 패치

2025년 상반기 동안 Vite 개발 서버에서 두 가지 중요한 **임의 파일 읽기(Arbitrary File Read) 취약점**이 발견 및 패치되었습니다. 이러한 취약점은 Vite 개발 서버가 `--host` 또는 `server.host` 설정을 통해 네트워크에 노출된 애플리케이션에 영향을 미칩니다. 기본적으로 Vite 개발 서버는 \*\*`localhost-only`\*\*로 설정되어 있어 로컬 환경에서는 안전합니다.

* **CVE-2025-31125 (3월 31일 패치)**:
    이 취약점은 Vite 개발 서버가 `?inline&import` 또는 `?raw?import` 쿼리 파라미터를 사용하여 허용되지 않는 파일의 내용을 노출할 수 있게 합니다. 이는 공격자가 서버의 민감한 파일을 읽을 수 있도록 허용하여 자격 증명 유출이나 추가 보안 위협으로 이어질 수 있습니다.

  * **영향받는 버전**: Vite 6.2.0-6.2.3, 6.1.0-6.1.2, 6.0.0-6.0.12, 5.0.0-5.4.15, 그리고 4.5.11 이전 버전.
  * **패치 버전**: 6.2.4, 6.1.3, 6.0.13, 5.4.16, 4.5.11.

* **CVE-2025-31486 (4월 8일 패치)**:
    이 취약점은 Vite 개발 서버가 URL 요청을 처리할 때 경로를 엄격하게 검증하지 않아, `.svg` 파일이나 상대 경로를 사용하여 `server.fs.deny` 제한을 우회하고 임의 파일을 읽을 수 있게 합니다. 이 또한 민감한 정보 유출로 이어질 수 있습니다.

  * **영향받는 버전**: Vite 6.2.0-6.2.4, 6.1.0-6.1.3, 6.0.0-6.0.13, 5.0.0-5.4.16, 그리고 4.5.11 이전 버전.
  * **패치 버전**: Vite \>= 6.2.5, 6.1.4 \<= Vite \< 6.2.0, 6.0.14 \<= Vite \< 6.1.0, 5.4.17 \<= Vite \< 6.0.0, 4.5.12 \<= Vite \< 5.0.0.

### 표 3: 보안 취약점 및 패치 버전

| CVE ID          | 취약점 유형    | 발견/패치 날짜 | 영향받는 버전                                                | 패치된 버전                                                | 권장 조치                       |
| :-------------- | :------------- | :------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :------------------------------ |
| CVE-2025-31125  | 임의 파일 읽기 | 2025년 3월 31일 | 6.2.0-6.2.3, 6.1.0-6.1.2, 6.0.0-6.0.12, 5.0.0-5.4.15, \<= 4.5.10 | 6.2.4, 6.1.3, 6.0.13, 5.4.16, 4.5.11                         | 즉시 업그레이드, 개발 서버 네트워크 접근 제한 |
| CVE-2025-31486  | 임의 파일 읽기 | 2025년 4월 8일  | 6.2.0-6.2.4, 6.1.0-6.1.3, 6.0.0-6.0.13, 5.0.0-5.4.16, \<= 4.5.11 | \>= 6.2.5, 6.1.4 \<= Vite \< 6.2.0, 6.0.14 \<= Vite \< 6.1.0, 5.4.17 \<= Vite \< 6.0.0, 4.5.12 \<= Vite \< 5.0.0 | 즉시 업그레이드, 개발 서버 네트워크 접근 제한 |

**코딩 구현 시 영향 및 권장 조치:**

* **즉시 업그레이드**: 영향을 받는 버전을 사용하는 모든 사용자는 가능한 한 빨리 패치된 버전으로 업그레이드해야 합니다.
* **네트워크 접근 제한**: 개발 서버를 외부에 노출해야 하는 경우가 아니라면, `--host` 또는 `server.host`를 `localhost`로 설정하여 외부 접근을 제한하는 것이 가장 강력한 임시 보호 조치입니다.
* **파일 권한 강화**: 운영 체제 수준에서 민감한 파일이 Vite 프로세스에 의해 읽히지 않도록 파일 권한을 강화해야 합니다.

### 프레임워크별 통합 및 개선

Vite는 다양한 프론트엔드 프레임워크와의 긴밀한 통합을 통해 개발자 경험을 지속적으로 향상시키고 있습니다.

#### React 앱에서의 SWC 활용 (Utilizing SWC in React Applications)

2025년 기준, React 애플리케이션에서 Vite를 사용할 때 Babel 대신 \*\*SWC(Rust 기반 컴파일러)\*\*를 사용하는 것이 가장 영향력 있는 최적화 방법으로 자리 잡았습니다. SWC는 Babel보다 훨씬 빠른 컴파일 및 핫 모듈 리로드(HMR)를 제공합니다.

**코딩 구현 시 영향**: React 프로젝트에서 SWC를 사용하려면 `@vitejs/plugin-react-swc` 패키지를 설치하고 `vite.config.js`에 다음과 같이 설정해야 합니다:

```javascript
// vite.config.js
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react-swc'; // SWC 플러그인 임포트

export default defineConfig({
  plugins: [react()],
});
```

이 변경은 React 개발자에게 더욱 빠르고 효율적인 개발 환경을 제공합니다.

#### Aurelia 2의 단일 파일 컴포넌트(SFC) 지원 (Single File Component (SFC) Support in Aurelia 2)

2025년 2월 5일, Aurelia 2는 새로운 Vite 플러그인을 통해 실험적인 단일 파일 컴포넌트(SFC) 지원을 발표했습니다. 이 기능은 HTML, CSS, JavaScript를 단일 **`.au` 파일**로 결합하여 개발을 간소화하고, Vite의 성능 이점을 활용하며, 코드베이스의 모듈성과 유지 관리성을 향상시킵니다.

**코딩 구현 시 영향**: Aurelia 개발자는 이제 `.au` 파일을 사용하여 컴포넌트를 정의하고, Vite 플러그인이 이를 Aurelia 호환 컴포넌트로 변환합니다. 여기에는 가상 모듈 처리, 자동 컴포넌트 구성, 그리고 `scoped` 속성 사용 시 CSS 격리(고유한 `data` 속성 부여)가 포함됩니다.

**제한사항**: 현재 SFC는 `main.ts` 또는 `main.js` 파일에 등록되어야 하고, 단일 루트 요소 템플릿이 가장 잘 작동하며, 템플릿 수준 타입 검사 및 템플릿 전처리기(Pug, Haml 등)는 지원되지 않습니다. Aurelia 팀은 TypeScript 통합 개선, 템플릿 기능 확장, VSCode 확장 지원, 성능 최적화를 위해 노력하고 있습니다.

#### Vitest 호환성 업데이트 (Vitest Compatibility Updates)

Vite 7.0.0 출시와 함께 Vitest는 3.2 버전부터 Vite 7.0을 지원하기 시작했습니다. 이는 Vite를 사용하는 프로젝트에서 테스트 환경을 최신 Vite 버전과 호환되도록 유지하는 데 중요합니다. 개발자는 Vitest 버전을 3.2 이상으로 업데이트하여 최신 Vite 환경에서 안정적인 테스트를 수행할 수 있습니다.

-----

## IV. 개발자를 위한 시사점 및 권장사항

2025년 상반기의 Vite 변경사항은 프론트엔드 개발 환경에 상당한 영향을 미치며, 개발팀은 이러한 변화에 적극적으로 대응해야 합니다.

### 기존 프로젝트 마이그레이션 가이드

* **Node.js 버전 업그레이드**: Vite 7.0으로 업그레이드하기 전에 Node.js 버전을 20.19+ 또는 22.12+로 업데이트해야 합니다. 이는 ESM-only 배포로의 전환과도 관련이 있으므로, 기존 CommonJS 기반의 의존성이 있는 경우 호환성 문제를 검토하고 필요에 따라 조치해야 합니다.
* **`vite.config.js` 설정 검토 및 업데이트**:
  * **브라우저 타겟**: `build.target`이 'baseline-widely-available'로 변경되었으므로, 구형 브라우저를 지원해야 하는 경우 `build.target`을 명시적으로 설정해야 합니다.
  * **플러그인 API**: 커스텀 플러그인이나 특정 플러그인 설정에서 `enforce` 및 `transform` 속성을 사용하고 있다면, 각각 `order` 및 `handler`로 업데이트해야 합니다.
  * **`optimizeDeps.entries`**: 이 설정에 경로를 지정하는 경우, 이제 항상 glob 패턴으로 작성해야 합니다.
  * **제거된 API**: `legacy.proxySsrExternalModules` 및 기타 제거된 API 속성이나 타입을 사용하고 있다면 해당 코드를 업데이트하거나 대체 로직을 구현해야 합니다.
* **보안 패치 적용**: CVE-2025-31125 및 CVE-2025-31486 취약점에 노출된 버전을 사용하고 있다면, 즉시 패치된 버전으로 업그레이드해야 합니다. 개발 서버를 네트워크에 노출하는 경우 `--host` 또는 `server.host`를 `localhost`로 설정하여 외부 접근을 제한하는 것이 중요합니다.
* **프레임워크별 플러그인 업데이트**: React 프로젝트의 경우 `@vitejs/plugin-react-swc`로 전환하여 빌드 및 HMR 성능을 최적화하는 것을 고려해야 합니다. Vitest 사용자는 Vitest 3.2 이상 버전으로 업데이트하여 Vite 7.0과의 호환성을 확보해야 합니다.

### 새 프로젝트 개발 시 고려사항

* **최신 Vite 스캐폴드 활용**: 새로운 React 프로젝트를 시작할 때 Vite의 공식 스캐폴드(`npm create vite@latest my-react-app -- --template react`)를 사용하여 최신 모범 사례를 따르는 것이 가장 간소화된 경험을 제공합니다.
* **Rolldown 통합 실험**: 대규모 애플리케이션의 빌드 시간 최적화에 관심이 있다면, `rolldown-vite` 패키지를 실험적으로 사용하여 Rolldown 기반 빌드를 테스트하고 피드백을 제공하는 것을 고려할 수 있습니다. 이는 향후 Vite의 기본 번들러가 될 예정이므로 미리 경험해 보는 것이 좋습니다.
* **Vite DevTools 활용 준비**: Vite DevTools가 출시되면 이를 활용하여 애플리케이션의 성능 병목 현상을 진단하고 디버깅 워크플로우를 개선할 수 있도록 준비해야 합니다.

### 성능 최적화 및 보안 모범 사례

* **플러그인 사용 제한**: 과도한 플러그인 사용은 개발 서버 속도를 저하시킬 수 있으므로, 필요한 플러그인만 최소한으로 유지하는 것이 좋습니다.
* **브라우저 캐싱 활성화**: Vite는 모듈 로딩 성능을 위해 캐싱에 크게 의존하므로, 개발 도구에서 캐싱을 비활성화하지 않도록 주의해야 합니다.
* **트리 쉐이킹 가능한 라이브러리 사용**: `lodash` 대신 `lodash-es`와 같이 최신 ES 모듈 기반 라이브러리를 선호하여 효율적인 코드 분할 및 트리 쉐이킹을 보장해야 합니다.
* **개발 서버 보안**: Vite 개발 서버를 프로덕션 환경에 노출하지 않아야 합니다. 필수적으로 노출해야 하는 경우, 방화벽 규칙, VPN, 인증 등의 추가적인 보안 조치를 반드시 적용해야 합니다. OS 수준에서 민감한 파일에 대한 접근 권한을 제한하는 것도 중요합니다.

-----

## V. 결론

2025년 상반기 Vite는 프론트엔드 개발 생태계에서 그 영향력을 더욱 공고히 하며 중요한 변화들을 선보였습니다. Vite 7.0.0의 공식 출시는 Node.js 지원 정책의 현대화와 브라우저 타겟의 Baseline 이니셔티브와의 연동을 통해 개발 환경의 기반을 강화했습니다. 특히 Rust 기반 번들러인 **Rolldown의 통합**은 빌드 성능을 획기적으로 개선하고 개발 및 프로덕션 환경의 일관성을 높이는 중요한 진전을 예고합니다. 또한, **Vite DevTools의 도입**은 개발자에게 심층적인 디버깅 및 분석 기능을 제공하여 개발자 경험(DX)을 한 단계 더 끌어올릴 것입니다. 이와 더불어, 상반기 동안 발견된 임의 파일 읽기 보안 취약점에 대한 신속한 패치는 Vite의 보안에 대한 지속적인 노력을 보여줍니다.

이러한 변화들은 Vite가 단순히 빠른 빌드 도구를 넘어, 현대 웹 애플리케이션 개발의 복잡성을 관리하고 성능을 최적화하며 개발자의 생산성을 극대화하는 데 필수적인 기반 도구로 진화하고 있음을 시사합니다. Vite의 발전은 프론트엔드 생태계 전반의 ESM 전환을 가속화하고, Rust와 같은 저수준 언어 기반 도구의 채택을 촉진하는 등 기술적 트렌드를 주도하고 있습니다. 개발팀은 이러한 변화에 발맞춰 Node.js 환경을 업데이트하고, `vite.config.js` 설정을 조정하며, 최신 플러그인과 보안 패치를 적용하는 등 적극적인 마이그레이션 전략을 수립해야 합니다. 새로운 프로젝트에서는 Vite의 최신 기능을 적극적으로 활용하고, 성능 및 보안 모범 사례를 준수하여 더욱 견고하고 효율적인 애플리케이션을 구축할 수 있습니다.

Vite는 앞으로도 성능, 개발자 경험, 그리고 생태계 통합에 중점을 두며 지속적으로 발전할 것으로 예상됩니다. 이는 프론트엔드 개발의 미래를 형성하는 데 있어 Vite가 핵심적인 역할을 계속 수행할 것임을 의미합니다.
