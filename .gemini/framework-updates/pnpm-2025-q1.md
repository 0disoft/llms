# pnpm 2025년 1분기 주요 업데이트 분석

## 서론

본 보고서는 2025년 1분기(1월 1일부터 3월 31일까지) pnpm 릴리즈 분석 요청에 따라 작성되었습니다. 해당 기간 공식적으로 문서화된 릴리즈는 없었으나, 개발자에게 가장 유용하고 실질적인 정보를 제공하기 위해 문서화된 최신 주요 릴리즈인 v10.12.x 시리즈의 변경사항에 초점을 맞춰 분석을 진행합니다. 이 버전들은 현재 개발 환경에 직접적인 영향을 미치는 중요한 아키텍처 변화, 새로운 기능, 안정성 향상 위한 핵심적인 수정 사항들을 포함합니다.

pnpm은 속도, 디스크 공간 효율성, 엄격한 의존성 관리라는 핵심 가치를 바탕으로 성장해왔습니다. 최신 업데이트 동향을 살펴보면, pnpm은 단순히 빠른 패키지 설치 도구를 넘어, 대규모 모노레포(monorepo) 환경의 복잡성을 해결하기 위한 포괄적인 관리 툴킷으로 진화하고 있음을 명확히 알 수 있습니다.

본 보고서는 다음과 같은 세 가지 주요 부분으로 구성됩니다.

1. pnpm의 사용 방식을 근본적으로 변화시킬 수 있는 주요 아키텍처 및 워크플로우의 진화를 다룹니다.
2. 개발자의 일상적인 작업에 직접적인 영향을 미치는 필수 명령어 및 설정 업데이트를 살펴봅니다.
3. 시스템의 안정성과 예측 가능성을 보장하는 중요 버그 수정 및 안정성 개선 사항을 상세히 분석하여 개발자가 안정적인 최신 버전으로 업데이트해야 하는 이유를 설명합니다.

---

## Part 1: 주요 아키텍처 및 워크플로우 변화

최근 pnpm 업데이트에서 가장 주목할 만한 변화는 대규모 엔터프라이즈급 모노레포를 직접적으로 겨냥하고 있다는 점입니다. 새롭게 도입된 '글로벌 가상 스토어'와 '카탈로그' 기능의 강화는 pnpm이 자체적으로 완결된 플랫폼으로 나아가고 있음을 시사합니다.

### 1.1. 글로벌 가상 스토어: 새로운 의존성 관리 패러다임

pnpm 버전 10.12.1에서 실험적으로 도입된 `enableGlobalVirtualStore` 기능은 의존성 관리의 새로운 패러다임을 제시합니다. 기존에는 각 프로젝트의 `node_modules` 내부에 `.pnpm`이라는 가상 스토어가 개별적으로 생성되었지만, 이 새로운 기능을 활성화하면 여러 프로젝트가 중앙의 단일 가상 스토어(기본값: `<store-path>/links`)를 향한 심볼릭 링크를 공유하게 됩니다.

이 접근 방식은 개발자에게 다음과 같은 실질적인 이점을 제공합니다.

* 설치 속도 향상: 캐시가 준비된 상태(warm cache)에서는 새로운 프로젝트를 구성할 때 거의 즉각적으로 의존성 설치가 완료될 수 있습니다.
* 디스크 공간 효율 극대화: 패키지 콘텐츠뿐만 아니라 가상 스토어 구조 자체의 중복까지 제거하여 효율성을 높입니다.

이 기능을 활성화하려면 프로젝트 루트의 `pnpm-workspace.yaml` 파일에 `enableGlobalVirtualStore: true`를 추가하거나, 다음 명령어를 통해 전역으로 설정할 수 있습니다.

```bash
pnpm config -g set enable-global-virtual-store true
````

한 가지 중요한 점은, 이 기능은 아직 실험 단계에 있어 CI(지속적 통합) 환경에서는 안전을 위해 자동으로 비활성화된다는 것입니다.

이러한 혁신적인 기능 도입은 pnpm의 빠른 개발 속도를 보여주지만, 동시에 안정성과의 균형점을 시사하기도 합니다. 실제로 v10.12.1에서 이 기능 도입 직후, `v10.12.2`에서 호이스팅(hoisting) 관련 버그가 수정되었고, 이는 또 다른 회귀(regression)를 유발하여 선택적 피어 의존성(optional peer dependencies) 관련 문제를 낳았으며, `v10.12.3`과 `v10.12.4`에서 다시 해결되었습니다. 이러한 일련의 과정은 최신 기능을 사용하는 개발자들이 사실상 베타 테스터 역할을 할 수 있음을 보여줍니다. 따라서 프로덕션 환경이나 CI/CD 파이프라인에서는 `latest`와 같은 유동적인 태그 대신, `corepack use pnpm@10.12.4`와 같이 특정 안정화 버전을 고정하여 사용하는 것이 예기치 않은 문제로부터 프로젝트를 보호하는 훨씬 안전한 전략입니다.

### 1.2. 향상된 카탈로그 기능으로 모노레포 마스터하기

카탈로그(Catalogs)는 모노레포 내에서 발생할 수 있는 의존성 버전 파편화를 방지하고, 업그레이드 과정을 단순화하며, 병합 충돌(merge conflicts)을 최소화하기 위한 강력한 기능입니다. 최근 업데이트는 이 기능을 더욱 정교하게 다듬어 팀의 워크플로우에 맞춰 세밀하게 제어할 수 있는 방법을 제공합니다.

`v10.12.1`에서 새로 추가된 `catalogMode` 설정은 카탈로그의 적용 방식을 팀의 정책에 맞게 조절할 수 있게 해줍니다.

| `catalogMode` 설정 | 동작 방식 | 권장 사용 사례 |
|---|---|---|
| `strict` | `pnpm add` 실행 시 의존성이 카탈로그에 명시된 버전 범위 내에 없으면 설치를 중단시킴. | 보안이 중요하거나 규제가 엄격한 환경에서 최대한의 버전 통제가 필요할 때. |
| `prefer` | 카탈로그에 버전이 있으면 해당 버전을 우선 사용하고, 없으면 직접 의존성으로 설치를 진행함. | 카탈로그 도입을 점진적으로 진행하거나 약간의 유연성이 필요한 팀에 적합. |
| `manual` (기본값) | 개발자가 직접 카탈로그를 관리해야 함. 기존의 기본 동작 방식. | 카탈로그를 수동으로 엄격하게 관리하고자 할 때. |

또한, `pnpm add` 명령어에 `--save-catalog`와 `--save-catalog-name` 플래그가 추가되어 워크플로우가 획기적으로 개선되었습니다. 이제 개발자가 새로운 의존성을 추가할 때 이 플래그를 사용하면, 해당 의존성이 `pnpm-workspace.yaml` 파일에 자동으로 추가되고, 프로젝트의 `package.json` 파일에는 `catalog:` 프로토콜을 사용하여 참조됩니다. 이로써 여러 단계를 거쳐야 했던 수동적인 카탈로그 관리 작업이 단일 명령어로 간소화되었습니다.

가장 중요한 개선 사항 중 하나는 `pnpm update` 명령어가 이제 카탈로그 의존성을 지원한다는 점입니다. 이전에는 카탈로그에 정의된 의존성을 업데이트하려면 `pnpm-workspace.yaml` 파일을 직접 수정해야 하는 번거로움이 있었습니다. 하지만 이제 `pnpm update`를 실행하면 카탈로그 파일의 버전이 자동으로 업데이트되어, 모노레포 전체의 의존성 업데이트 워크플로우가 극적으로 단순화되었습니다.

## Part 2: 개발자가 반드시 알아야 할 명령어 및 설정 변경사항

pnpm의 최신 변경사항들은 도구의 성숙도를 보여주며, npm 생태계의 관행에서 벗어나 독자적인 컨벤션을 구축하려는 의도를 드러냅니다. 개발자는 이러한 변화를 숙지하여 기존 워크플로우를 최적화하고 잠재적인 문제를 예방해야 합니다.

### 2.1. 중대한 변화: `npm_config_`에서 `pnpm_config_`로의 전환

pnpm은 이제 환경 변수를 해석할 때 `npm_config_` 접두사보다 `pnpm_config_` 접두사를 우선적으로 사용합니다. 이는 사소해 보일 수 있지만, 특히 CI/CD 환경에서 심각한 문제를 유발할 수 있는 매우 중요한 변경 사항입니다.

많은 CI/CD 파이프라인은 비공개 레지스트리 인증 토큰과 같은 민감한 정보를 `NPM_CONFIG_` 관련 환경 변수를 통해 전달하도록 설정되어 있습니다. pnpm을 최신 버전으로 업데이트한 후 이러한 설정을 변경하지 않으면, 인증이 조용히 실패하거나 잘못된 자격 증명을 사용하여 빌드가 중단될 수 있습니다. 따라서 모든 개발팀은 즉시 관련 시스템을 점검하고 마이그레이션해야 합니다.

| 이전 변수 | 새로운 변수 | 조치 사항 | 비고 |
|---|---|---|---|
| `NPM_CONFIG_TOKEN` | `PNPM_CONFIG_TOKEN` | CI/CD 시스템의 시크릿 변수 이름을 업데이트 | 비공개 레지스트리 인증에 영향을 줌 |
| `NPM_CONFIG_REGISTRY` | `PNPM_CONFIG_REGISTRY` | `.npmrc` 파일 또는 CI/CD 환경 변수 업데이트 | 사용할 레지스트리 주소를 지정 |
| `NPM_CONFIG_...` | `PNPM_CONFIG_...` | 모든 `npm_config_` 관련 변수를 `pnpm_config_`로 변경 | 전반적인 설정 호환성을 위해 필수 |

### 2.2. 제어력 강화를 위한 새로운 플래그: `pnpm audit` 및 `pnpm init`

개발자의 편의성과 제어력을 높이기 위한 새로운 플래그들이 추가되었습니다.

* `pnpm audit`: 보안 취약점 검사를 더 유연하게 관리할 수 있는 `--ignore`와 `--ignore-unfixable` 플래그가 추가되었습니다.
  * `--ignore-unfixable`: 수정 불가능한 취약점이 발견되더라도 CI 파이프라인이 중단되지 않도록 허용합니다.
  * `--ignore=<CVE-ID>`: 팀에서 위험도가 낮다고 판단하여 공식적으로 수용한 특정 취약점을 무시 목록에 추가하여 빌드 실패를 방지할 수 있습니다.
* `pnpm init`: `init-type: 'module'` 설정과 `--type=module` 플래그가 추가되어, ECMAScript Modules (ESM) 기반의 현대적인 프로젝트 생성을 간소화합니다. 이는 Node.js 생태계의 ESM 우선 추세에 발맞춘 편리한 기능입니다.

### 2.3. 워크스페이스 작업 간소화: `pnpm -r pack` 명령어

모노레포 환경에서의 작업을 더욱 효율적으로 만들기 위해, 워크스페이스 내의 모든 프로젝트에 대해 재귀적으로 `pnpm pack`을 실행하는 기능이 추가되었습니다.

이전에는 모든 패키지의 tarball 아티팩트를 생성하기 위해 복잡한 쉘 스크립트를 작성해야 했지만, 이제는 `pnpm -r pack`이라는 단일 명령어로 동일한 작업을 수행할 수 있습니다. 이 기능은 `Changesets`와 같은 릴리즈 관리 도구와 함께 사용할 때 특히 강력한 시너지를 발휘합니다. 예를 들어, `pnpm changeset version`으로 버전을 올리고, `pnpm install`로 의존성을 맞춘 뒤, `pnpm -r pack`으로 배포용 아티팩트를 생성하고, 마지막으로 `pnpm publish -r`로 게시하는 일련의 과정을 매끄럽게 자동화할 수 있습니다.

## Part 3: 핵심 버그 수정 및 안정성 향상

최신 pnpm 릴리즈는 새로운 기능 도입만큼이나 안정성 강화에 집중하고 있습니다. 특히 의존성 해결, 잠금 파일(lockfile)의 결정성, 그리고 배포 명령어의 신뢰성과 관련된 미묘하지만 치명적인 엣지 케이스들이 다수 수정되었습니다. 이러한 수정 사항들은 "내 컴퓨터에서는 잘 됐는데"와 같은 고질적인 문제를 해결하고, pnpm을 더욱 신뢰할 수 있는 도구로 만듭니다. 최신 패치 버전으로 업데이트하는 것은 단순히 새로운 기능을 얻는 것을 넘어, 프로젝트의 안정성과 빌드의 예측 가능성을 확보하는 중요한 과정입니다.

### 3.1. 피어 의존성 및 호이스팅 불안정성 해결

* 피어 의존성 해결 중 교착 상태(Deadlock) 수정: 복잡하게 얽힌 피어 의존성 관계에서 설치 프로세스가 멈추는 교착 상태 문제가 해결되었습니다.
* 호이스팅 관련 회귀 및 수정: v10.12.2부터 v10.12.4에 걸쳐 호이스팅 로직과 관련된 여러 회귀 문제가 발생하고 수정되었습니다. 이 문제들은 선택적 피어 의존성이 올바르게 설치되지 않아 런타임 오류를 유발할 수 있었습니다. 누적된 수정 사항이 모두 포함된 최신 버전(v10.12.4 이상)을 사용하는 것이 가장 안정적입니다.
* `strictPeerDependencies` 규칙 개선: `peerDependencyRules`를 통해 특정 피어 의존성 문제를 무시하도록 설정했음에도 불구하고 설치가 실패하는 버그가 수정되었습니다.

### 3.2. 결정성 보장: 잠금 파일 및 배포 관련 수정

* 잠금 파일 일관성: `pnpm update --lockfile-only` 명령어가 일반 `pnpm update`와 다른 `pnpm-lock.yaml` 파일을 생성하던 회귀 문제가 해결되었습니다. 이는 CI의 한 단계에서 의존성을 미리 해결하고 다음 단계에서 사용하는 워크플로우에서 진정한 결정성을 보장하는 데 필수적인 수정입니다.
* `pnpm deploy` 신뢰성 향상: 프로덕션 빌드를 생성하는 핵심 명령어인 `pnpm deploy`의 여러 버그가 수정되었습니다.
  * `overrides`된 의존성이 피어 의존성을 가질 때 배포가 실패하는 문제 수정.
  * `overrides`와 `inject-workspace-packages=true`가 함께 사용될 때 배포가 실패하는 문제 수정.
  * `pnpm deploy --legacy` 사용 시 예기치 않은 디렉토리가 생성되는 문제 수정.
        이러한 수정들은 배포 파이프라인의 안정성을 크게 향상시킵니다.

### 3.3. 명령어별 수정으로 예측 가능한 도구 환경 구축

* `pnpm ls`: `pnpm ls --filter=not-exist --json` 명령어가 유효한 빈 JSON 배열(`[]`) 대신 아무것도 출력하지 않던 버그가 수정되었습니다. 이는 JSON 출력을 파싱하는 자동화 스크립트의 안정성을 위해 중요한 수정입니다.
* `pnpm licenses`: 로컬 의존성에 대해 `licenses` 명령어가 제대로 동작하지 않던 문제와, JSON 출력 시 의존성 경로가 잘못 표시되던 문제가 해결되었습니다.
* `pnpm create`: `--help` 및 `-h` 플래그가 기대대로 작동하지 않던 문제가 수정되어 도구의 일관성과 개발자 경험이 향상되었습니다.

## 결론 및 실행 가능한 권장 사항

본 보고서에서 분석한 pnpm의 최신 업데이트는 세 가지 핵심적인 흐름을 보여줍니다. 첫째, pnpm은 엔터프라이즈급 모노레포 관리 플랫폼으로 전략적으로 진화하고 있습니다. 둘째, 독자적인 설정과 명령어를 강화하며 자체적으로 완결된 생태계로 성숙하고 있습니다. 마지막으로, 빠른 혁신과 안정성 확보 사이의 역동적인 균형을 유지하며 발전하고 있습니다.

이러한 변화에 효과적으로 대응하기 위해 개발자는 다음의 조치들을 즉시 실행할 것을 권장합니다.

* 업그레이드: 모든 핵심 버그 수정과 안정성 개선의 혜택을 받기 위해, 지금 바로 pnpm을 최신 안정화 패치 릴리즈로 업데이트하십시오 (`pnpm self-update` 또는 `corepack use pnpm@<최신-안정-버전>`).
* CI/CD 감사: 모든 CI/CD 설정 파일(`.yml`, `.sh` 등)과 로컬 `.npmrc` 파일을 검토하여 `npm_config_` 접두사를 사용하는 환경 변수를 찾아 `pnpm_config_`로 마이그레이션하십시오. 이는 예기치 않은 빌드 실패를 방지하는 가장 중요한 조치입니다.
* 버전 고정: 프로덕션 빌드 환경에서는 안정성을 극대화하기 위해 `latest` 태그 대신 `pnpm@10.12.4`와 같이 특정 버전을 명시적으로 고정하여 사용하십시오.
* 모노레포 기능 탐색: 모노레포 환경에서 작업 중이라면, `catalogMode: 'prefer'`로 시작하여 `catalogs` 기능을 점진적으로 도입하고, `pnpm add --save-catalog` 워크플로우를 채택하여 의존성 관리를 간소화하십시오.
* 스크립트 간소화: `package.json`의 스크립트들을 검토하고, 복잡한 사용자 정의 로직을 `pnpm -r pack`과 같은 새로운 네이티브 명령어로 대체할 수 있는 부분을 찾아 리팩토링하십시오.
