# Zig 프로그래밍 언어 2025년 1분기 주요 변경사항: 개발자 필수 가이드

이 문서는 2025년 1분기(1월 1일 ~ 3월 31일) 동안 발표된 Zig 프로그래밍 언어의 주요 변경사항과 패치노트를 한국인 개발자들이 이해하기 쉽도록 설명합니다. 특히 기존 코드의 호환성, 새로운 기능 활용, 개발 워크플로우 개선에 필요한 핵심 변경사항에 초점을 맞췄습니다. Zig를 사용하여 시스템 프로그래밍, 임베디드 개발, 고성능 애플리케이션을 개발하는 현직 개발자 및 학습하려는 개발자에게 유용할 것입니다.

---

2025년 1분기는 Zig 프로젝트에 매우 중요한 시기로, 특히 **Zig 0.14.0** 릴리즈에 대한 활발한 개발 및 논의가 이루어졌습니다. 0.14.0 마일스톤은 2025년 3월 3일 마감 예정이었으며, 핵심 변경사항들은 1분기 내에 확정되고 공개 논의되었습니다. 공식 릴리즈 노트는 2025년 7월 7일에 업데이트되었지만, 주요 내용은 1분기에 확정되어 Daily.dev를 통해 발표되었습니다. 이는 Zig의 릴리즈 프로세스가 장기간의 개발과 점진적인 기능 확정 및 문서화 과정을 거친다는 점을 시사합니다.

---

Zig 0.14.0은 9개월간 251명의 기여자, 3,467개의 커밋을 통해 이루어진 대규모 업데이트입니다. 이번 업데이트는 **개발 주기의 지연 시간(latency)을 줄이는 데 중점**을 두었습니다. 이는 증분 컴파일 및 고속 x86 백엔드와 같은 장기적인 투자로 이어졌습니다. 이러한 개선은 단순히 성능 개선을 넘어, 개발자의 생산성과 만족도를 직접적으로 향상시키는 전략적 투자로 볼 수 있습니다. 컴파일 시간이 길어지면 개발자의 집중력이 저하되고 작업 흐름이 끊기기 때문입니다.

---

다음 표는 2025년 1분기 동안 Zig 프로젝트에서 발생한 중요한 개발로그 업데이트를 시간 순서대로 보여줍니다. 이 표는 0.14.0 릴리즈 외에 어떤 추가적인 개발 진전이 있었는지 한눈에 파악할 수 있게 하여, 릴리즈 노트에 직접 포함되지 않은, 그러나 개발자에게 중요한 맥락과 도구 개선 사항들을 강조합니다.

표 1: 2025년 1분기 Zig 개발로그 주요 업데이트

| 날짜       | 주요 내용 요약                                                                                              |
| :--------- | :---------------------------------------------------------------------------------------------------------- |
| 2025년 1월 24일 | Zig 디버깅 지원 개선을 위한 LLDB 포크 발표. 특히 자체 호스팅 백엔드 사용 시 유용.                          |
| 2025년 2월 7일 | Zig의 디버그 할당자(Debug Allocator) 대규모 재작업으로 성능 개선. No-Libc Zig가 Glibc Zig 성능을 능가하기 시작. |
| 2025년 2월 24일 | zig cc로 C 코드 컴파일 시 UBSan(Undefined Behavior Sanitizer) 오류 메시지 대폭 개선.                     |
| 2025년 3월 3일 | Zig 0.14.0 릴리즈 임박 상태 업데이트. 주요 기능 확정 및 릴리즈 노트 마무리 중.                            |

---

## 핵심 개발자 경험 개선

2025년 1분기에 발표된 Zig의 주요 변경사항 중 개발자의 일상적인 코딩 및 빌드 경험에 직접적인 영향을 미치는 개선사항들이 두드러집니다. 특히 0.14.0 릴리즈는 컴파일 속도와 빌드 시스템 효율성 향상에 중점을 두었습니다.

### 컴파일 속도 및 효율성 향상

Zig의 개발팀은 개발 주기의 지연 시간을 줄이는 데 크게 기여하는 컴파일러 및 빌드 시스템 개선에 집중했습니다. 이는 개발자가 코드를 수정하고 결과를 확인하는 반복적인 과정(edit-compile-debug loop)의 효율성을 직접적으로 개선합니다.

#### 점진적 컴파일 (Incremental Compilation)

`--fincremental` 플래그와 `--watch` 옵션을 함께 사용하면 점진적 컴파일 기능을 활성화할 수 있습니다. 이 기능은 재분석 시간을 획기적으로 줄여줍니다. 예를 들어, 50만 라인 규모의 코드베이스에서 재분석 시간이 14초에서 **63밀리초로 단축**되었다는 보고가 있습니다. 이 기능은 특히 디버그 모드에서 컴파일 오류에 대한 빠른 피드백을 제공하므로, 개발 워크플로우를 크게 개선합니다.

#### 멀티스레드 백엔드 (Multithreaded Backend)

일부 컴파일러 백엔드(예: x86 백엔드)는 이제 코드 생성(codegen)을 별도의 스레드에서 실행할 수 있도록 **멀티스레딩을 지원**합니다. 이로 인해 컴파일러 빌드 시간이 12.8초에서 **8.57초로 단축**되었습니다. 이 개선은 주로 컴파일러 자체의 성능 향상이지만, 결과적으로 개발자가 Zig 프로젝트를 빌드하는 데 걸리는 전체 시간을 줄여줍니다.

#### x86 백엔드 개선 (x86 Backend Improvements)

Zig의 자체 x86 백엔드가 LLVM과의 **98% 호환성**을 달성하며 거의 완성 단계에 이르렀습니다. 이는 컴파일 속도를 극적으로 향상시키고 디버거 지원을 개선합니다. 다음 릴리즈 주기에는 디버그 모드의 기본 백엔드가 될 것으로 예상됩니다. x86 백엔드의 발전은 디버그 빌드의 속도를 크게 높여 개발자가 더 빠르게 테스트하고 반복할 수 있게 합니다.

---

### 빌드 시스템 업데이트

Zig는 개발자 경험(DX)을 최우선으로 고려하는 성숙한 생태계로 진화하고 있음을 빌드 시스템 개선을 통해 보여줍니다. 이는 특히 대규모 프로젝트에서 개발자의 생산성을 극대화하고, Zig의 엔터프라이즈 채택을 가속화할 잠재력을 가집니다.

#### 파일 시스템 감시 (`--watch` CLI 옵션) (File System Watching)

새로운 `--watch` CLI 옵션이 추가되어 소스 파일이 수정될 때마다 프로젝트를 지속적으로 재빌드합니다. 이 기능은 개발자가 수동으로 빌드 명령을 실행할 필요 없이, 코드 변경 시 즉각적인 피드백을 받을 수 있게 하여 개발 워크플로우를 간소화합니다. 특히 `--fincremental` 플래그와 함께 사용하면 더욱 강력한 개발 경험을 제공합니다. 50만 라인 코드베이스에서 재분석 시간이 14초에서 63ms로 줄어든다는 수치는 이러한 개선이 단순한 편의 기능이 아니라, 개발자의 일일 생산성에 지대한 영향을 미칠 수 있음을 시사합니다.

#### 새로운 패키지 해시 형식 (New Package Hash Format)

패키지 관리 시스템에 **새로운 해시 형식**이 도입되었습니다. 이 형식은 이름, 버전, ID 구성 요소, 총 압축 해제 크기 등 상세한 메타데이터를 포함하여, 기존의 이해하기 어려운 문자열보다 **읽고 이해하기 쉽습니다**. 이 변경은 패키지 의존성 관리를 더 투명하고 사용자 친화적으로 만듭니다.

#### 빌드 API 변경사항 (예: `UpdateSourceFiles`, `addLibrary`) (Build API Changes)

빌드 시스템 API에 중요한 변경사항이 있었습니다. `Compile.installHeader` 및 `b.addInstallHeaderFile`과 같은 함수는 이제 `LazyPath` 매개변수를 요구합니다. 기존의 `WriteFile` 스텝은 `UpdateSourceFiles` 스텝으로 대체되었고, `RemoveDir` 스텝은 `const u8` 대신 `LazyPath`를 받도록 변경되었습니다. 또한, `addSharedLibrary`와 `addStaticLibrary`를 대체하는 새로운 `addLibrary` 함수가 추가되어, 링킹 모드 변경을 용이하게 합니다. 기존 빌드 스크립트는 이러한 API 변경에 맞춰 업데이트해야 합니다.

---

## 언어 및 표준 라이브러리 주요 변경사항

Zig 0.14.0 릴리즈를 통해 도입된 핵심 언어 기능 및 표준 라이브러리 변경사항은 개발자의 코드 작성 방식, 메모리 관리 전략, 그리고 기존 코드의 수정 필요성에 직접적인 영향을 미칩니다.

### 새로운 언어 기능 및 구문

#### 레이블드 스위치 문 (Labeled Switch Statements)

`switch` 문에 레이블을 붙이고 `continue` 문으로 해당 레이블을 대상으로 할 수 있게 되었습니다. 이는 특히 **유한 상태 머신(Finite State Automata)을 설계할 때 구문을 명확하게** 하고, 핫 루프(hot loops)에서 CPU 분기 예측(branch prediction)을 개선하여 **성능을 13% 향상**시키는 데 기여했습니다. 이 기능은 상태 머신 구현 시 가독성과 성능을 동시에 개선할 수 있는 강력한 기능입니다.

#### `@branchHint` 내장 함수 (Replacing `@setCold`)

새로운 `@branchHint(comptime hint: std.builtin.BranchHint)` 내장 함수가 도입되어, 옵티마이저에게 어떤 분기가 더 가능성이 높은지 힌트를 줄 수 있게 되었습니다. 기존의 `@setCold` 내장 함수는 제거되었습니다. 이는 성능 튜닝을 위한 더 세밀한 제어를 제공하며, 컴파일러가 더 최적화된 기계 코드를 생성하는 데 도움을 주어 런타임 성능을 향상시킬 수 있습니다.

#### `@export` 및 `@ptrCast` 사용법 변경

`@export` 내장 함수의 첫 번째 피연산자가 이제 내보낼 데이터에 대한 포인터가 됩니다. 이는 사용법을 단순화하고 일관성을 높입니다. `@ptrCast` 내장 함수는 이제 슬라이스(slice)의 길이를 변경하는 것을 허용합니다. `@export`를 사용하여 외부 시스템에 데이터를 노출하는 경우, 코드 수정이 필요합니다. `@ptrCast`의 변경은 특정 메모리 조작 시 더 유연한 타입을 허용하지만, 여전히 안전하지 않은 연산이므로 주의 깊게 사용해야 합니다.

#### 익명 구조체 타입 제거 및 튜플 통합 (Removal of Anonymous Struct Types, Unifying Tuples)

익명 구조체 타입이 제거되고, 튜플(tuple)이 구조적 동등성(structural equivalence)을 사용하며 더 엄격한 제약을 갖도록 단순화되었습니다. 익명 구조체를 사용하던 기존 코드는 명명된 구조체로 변경하거나 튜플의 새로운 규칙에 맞춰야 합니다. 이는 코드의 명확성을 높이고 잠재적인 모호성을 제거하는 데 기여합니다.

#### `std.builtin.Type` 필드 이름 변경 (Renaming `std.builtin.Type` Fields)

`std.builtin.Type` 태그 유니온의 필드 이름이 명명 규칙을 따르도록 소문자로 변경되었습니다. 이로 인해 키워드에 대해서는 "따옴표 식별자(quoted identifier)" 구문이 필요할 수 있습니다. `std.builtin.Type`을 사용하여 타입 정보를 쿼리하는 메타프로그래밍 코드에서 필드 이름 업데이트가 필요합니다.

#### `@FieldType` 내장 함수 도입 (Introduction of `@FieldType` Builtin)

새로운 `@FieldType` 내장 함수가 도입되었습니다. 이는 `std.meta.FieldType`과 동일한 목적으로, 주어진 타입과 필드 이름을 통해 필드의 타입을 반환합니다. `std.meta.FieldType`을 사용하던 코드를 `@FieldType`으로 전환하여 더 직접적인 접근 방식을 사용할 수 있습니다.

#### 기타 언어 변경 사항

* **Decl Literals**: "enum literal" 구문(`.foo`)이 대상 타입의 모든 선언을 참조할 수 있는 "decl literals"로 확장되었습니다. 이는 구조체 필드 초기화에 유용하며, 함수 호출도 지원합니다.
* **`@splat` 배열 지원**: `@splat` 내장 함수가 벡터뿐만 아니라 배열에도 적용되어, 상수 값으로 배열을 초기화하는 것을 가능하게 합니다.
* **전역 변수 상호 주소 초기화**: 전역 변수가 서로의 주소로 초기화될 수 있게 되었습니다.
* **`@fence` 제거**: `@fence` 내장 함수가 복잡성으로 인해 제거되었습니다.
* **Packed Struct 동등성 및 아토믹 연산**: Packed struct가 `@bitCast` 없이 직접 비교되거나 아토믹 연산에 사용될 수 있습니다.

---

### 메모리 관리 도구 및 API 개선

#### `DebugAllocator` 및 `SmpAllocator`

`GeneralPurposeAllocator`가 `DebugAllocator`로 재작성되어, 더 나은 성능과 더 적은 활성 매핑을 제공합니다. 이제 내장 스택 트레이싱 및 메모리 누수 감지 기능을 포함하며, `zig ast-check`의 벽시계 시간을 **10.1% 단축**시켰습니다. 새로운 `SmpAllocator`는 멀티스레딩이 가능한 ReleaseFast 최적화 모드를 위해 도입되었으며, `glibc`의 `malloc`과 경쟁할 만한 성능을 제공합니다.

#### `std.mem.Allocator` API의 `remap` 함수

`std.mem.Allocator.VTable`에 새로운 `remap` 함수가 추가되어, 메모리 재할당 시 재배치(relocation)를 통해 더 효율적인 크기 조절을 가능하게 합니다. 이는 기존의 `resize` 함수와 함께 사용됩니다. 동적으로 크기가 변경되는 데이터 구조를 다룰 때 `remap` 함수를 활용하여 메모리 효율성을 높일 수 있습니다.

#### 런타임 페이지 크기 (`std.heap.pageSize()`)

컴파일 타임에 알려지던 `std.mem.page_size`가 제거되고, 런타임에 알 수 있는 `std.heap.pageSize()` 함수와 컴파일 타임에 알 수 있는 경계값 `std.heap.page_size_min`, `std.heap.page_size_max`로 대체되었습니다. 페이지 크기에 의존하는 코드는 `std.heap.pageSize()`를 사용하여 런타임 값을 얻도록 수정해야 합니다. 이는 다양한 플랫폼에서의 유연성을 높입니다.

---

### 데이터 처리 및 기타 표준 라이브러리 변경

#### ZON (Zig Object Notation) 지원

표준 라이브러리가 **ZON (Zig Object Notation)을 지원**하게 되었습니다. `std.zon.parse`를 통해 ZON을 Zig 구조체로 파싱하고, `std.zon.stringify`를 통해 데이터를 직렬화할 수 있습니다. 또한 `std.zig.ZonGen`은 복잡한 스키마 매핑을 위한 트리 구조 생성을 지원합니다. ZON은 Zig 프로젝트 내에서 설정 파일, 데이터 직렬화 등 다양한 용도로 활용될 수 있는 강력한 도구입니다.

#### `std.hash_map`의 `rehash` 메서드

`std.hash_map`에 `rehash` 메서드가 추가되어, 요소 제거로 인해 발생할 수 있는 성능 문제를 해결합니다. `std.hash_map`을 사용하여 빈번하게 요소를 추가/제거하는 경우, `rehash`를 적절히 호출하여 해시 맵의 성능을 최적화할 수 있습니다.

#### "Unmanaged" 스타일 컨테이너 권장

`std.ArrayList`와 같은 "관리형(Managed)" 컨테이너 변형이 "비관리형(Unmanaged)" 변형(예: `std.ArrayListUnmanaged`)을 선호하는 방식으로 **권장되지 않게 되었습니다**. 이는 비관리형 컨테이너가 더 나은 빌딩 블록으로 간주되기 때문입니다. Zig의 명시적인 메모리 관리 철학에 따라, 개발자는 이제 컨테이너에 할당자를 직접 전달해야 합니다. 이는 자원 관리에 있어 투명성과 제어를 촉진합니다.

---

## 플랫폼 지원 및 툴체인 개선

Zig 0.14.0은 광범위한 타겟 지원 강화와 디버깅 환경 개선을 통해 언어가 단순한 시스템 언어를 넘어 다양한 임베디드 및 저수준 시스템 개발을 위한 강력한 도구로 자리매김하고 있음을 보여줍니다.

### 확장된 타겟 지원 및 티어 시스템

#### 확장된 지원

Zig 0.14.0은 올바른 크로스 컴파일 및 실행을 위한 타겟 목록을 크게 확장하여 **타겟 지원을 현저히 개선**했습니다. 이는 `arm/thumb`, `mips/mips64`, `powerpc/powerpc64`, `riscv32/riscv64`, 또는 `s390x`를 타겟팅할 때 발생하는 일반적인 툴체인 문제를 해결합니다. 이러한 광범위한 지원은 Zig의 적용 가능성을 넓히며, 특히 임베디드 및 저수준 시스템 개발자들에게 더 나은 안정성을 제공합니다.

#### 티어 시스템

Zig는 타겟 지원 수준을 네 가지 티어로 분류합니다:

* **티어 1**: 모든 비실험적 언어 기능이 작동하고, 컴파일러는 LLVM 없이도 기계 코드를 생성할 수 있습니다.
* **티어 2**: 표준 라이브러리의 크로스 플랫폼 추상화가 구현되어 있고, 디버그 정보 기능이 있어 스택 트레이스를 생성합니다.
* **티어 3**: 컴파일러가 LLVM과 같은 외부 백엔드를 사용하여 기계 코드를 생성할 수 있습니다.
* **티어 4**: 컴파일러가 LLVM과 같은 외부 백엔드를 통해 어셈블리 소스 코드를 생성할 수 있으며, 이 타겟은 실험적일 수 있습니다.

이 티어 시스템은 개발자가 특정 플랫폼에 대한 Zig의 지원 수준을 명확히 이해하는 데 도움을 줍니다.

---

### 디버깅 및 언디파인드 비헤이비어 개선

#### LLDB 포크 (LLDB Fork for Zig)

Jacob은 Zig 언어에 특화된 개선 사항을 포함하는 **LLDB 포크**를 통해 Zig의 디버깅 지원을 향상시키는 작업을 진행했습니다. 이 포크는 주로 Zig의 자체 호스팅 백엔드와 함께 사용하도록 설계되었으며, 위키 페이지가 생성되어 빌드 및 사용 지침을 제공합니다. Zig는 "프로그래밍 언어 지식 디버깅보다 애플리케이션 디버깅에 집중"이라는 철학을 가지고 있으며, 이 LLDB 포크는 이 철학과 일치합니다.

#### UBSan 오류 메시지 개선 (Improved UBSan Error Messages)

`zig cc`로 C 코드를 컴파일할 때 **UBSan(Undefined Behavior Sanitizer) 오류 메시지가 크게 개선**되었습니다. 이전에는 UBSan이 감지한 정의되지 않은 동작이 도움이 되지 않는 `SIGILL` 오류로 이어졌으나, 새로운 UBSan 런타임 통합으로 오류 메시지가 훨씬 더 유익해졌습니다. 예를 들어, 부호 있는 정수 오버플로우는 정확한 위치와 함께 무엇이 잘못되었는지 명확히 알려줍니다. 이는 `zig cc`로 컴파일된 C 코드에서 정의되지 않은 동작을 훨씬 쉽게 진단할 수 있게 하여 디버깅 시간을 단축시킵니다.

---

### 툴체인 구성 요소 업데이트

Zig는 주요 툴체인 구성 요소들의 지속적인 업데이트를 통해 최신 생태계 표준 및 보안 패치와 보조를 맞추고 있습니다. 이는 Zig 프로젝트의 활발한 유지보수와 안정성에 대한 노력을 반영하며, 개발자들이 최신 환경에서 안전하고 효율적으로 작업할 수 있도록 지원합니다.

* **LLVM 19**: Clang, libc++, libc++abi, libunwind, libtsan을 포함한 LLVM 19.1.7으로 업그레이드되었습니다.
* **musl 1.2.5**: CVE 완화 패치 및 타겟별 패치를 포함한 musl v1.2.5 소스 코드가 함께 제공됩니다.
* **glibc 2.41**: glibc 버전 2.40 및 2.41이 크로스 컴파일을 위해 제공되며, 실행 파일 및 스텁 심볼에 대한 중요한 수정 사항이 포함됩니다.
* **Linux 6.13.4 Headers**: Linux 커널 헤더 버전 6.13.4가 포함됩니다.
* **Darwin libSystem 15.1**: Xcode SDK 버전 15.1용 Darwin libSystem 심볼이 포함됩니다.
* **MinGW-w64**: 번들된 MinGW-w64 복사본이 업데이트되었으며, `thumb-windows-gnu` 크로스 컴파일을 지원하는 `winpthreads` 라이브러리가 포함됩니다.
* **wasi-libc**: 번들된 `wasi-libc` 복사본이 업데이트되었습니다.

---

## 결론 및 권고 사항

2025년 1분기는 Zig 프로그래밍 언어에 있어 중요한 발전의 시기였습니다. 이 기간 동안의 주요 변경사항은 **개발자 경험, 언어 기능, 표준 라이브러리, 그리고 플랫폼 지원 전반에 걸쳐 상당한 개선**을 가져왔습니다. 핵심적으로, Zig는 컴파일 속도와 빌드 시스템의 효율성을 극대화하여 개발 주기의 지연 시간을 줄이는 데 집중했습니다. 점진적 컴파일, 멀티스레드 백엔드, 개선된 x86 백엔드, 그리고 파일 시스템 감시와 같은 기능들은 개발자의 생산성을 직접적으로 향상시키는 데 기여합니다.

---

언어 및 표준 라이브러리 측면에서는 **레이블드 스위치 문과 `@branchHint`와 같은 새로운 기능이 코드의 표현력과 성능 제어를 강화**했습니다. 메모리 관리 도구인 `DebugAllocator`와 `SmpAllocator`의 개선은 메모리 관련 문제 진단과 고성능 멀티스레드 애플리케이션 최적화를 용이하게 합니다. 또한, **ZON 지원과 "비관리형" 컨테이너 권장은 Zig의 명시적인 메모리 관리 철학을 강화**하며, 더 견고하고 예측 가능한 애플리케이션 개발을 유도합니다.

---

플랫폼 지원의 확장과 툴체인 개선은 Zig의 적용 범위를 넓히고, 특히 임베디드 및 저수준 시스템 개발자들에게 더 안정적인 환경을 제공합니다. LLDB 포크와 UBSan 오류 메시지 개선은 디버깅 과정을 크게 간소화하여, 개발자가 언어 지식보다는 실제 애플리케이션 문제 해결에 집중할 수 있도록 돕습니다. Zig의 지속적인 진화, 특히 개발 지연 시간 단축과 디버깅 도구 강화에 대한 집중은 시스템 프로그래밍을 위한 매우 생산적이고 신뢰할 수 있는 언어로서의 입지를 확고히 합니다.

---

이러한 변경사항을 바탕으로, Zig 개발자들에게 다음 사항들을 권고합니다.

* **최신 릴리즈 노트 및 개발로그 지속 확인**: Zig의 릴리즈 주기가 길고, 주요 기능이 점진적으로 공개되므로, GitHub 릴리즈 페이지, 공식 개발로그, 커뮤니티 채널을 꾸준히 확인하여 최신 변경사항을 파악하는 것이 중요합니다.
* **기존 코드베이스 검토 및 업데이트**: 빌드 시스템 API, `@export` 내장 함수, `std.builtin.Type` 필드 이름 변경 등은 기존 코드의 수정이 필요할 수 있습니다. 마이그레이션 가이드를 참조하여 점진적으로 코드를 업데이트하는 것을 권장합니다.
* **새로운 기능 적극 활용**: 점진적 컴파일, 파일 시스템 감시, 레이블드 스위치 문, `DebugAllocator`와 같은 새로운 기능들을 적극적으로 활용하여 개발 효율성과 코드 품질을 향상시키십시오.
* **커뮤니티 참여**: Zig 커뮤니티는 활발합니다. 문제 발생 시 커뮤니티 포럼이나 이슈 트래커를 통해 도움을 얻고, 개인 프로젝트를 통해 기여하는 것도 좋은 방법입니다.
* **메모리 안전성 유의**: Zig는 C보다 안전한 코드를 작성하는 데 도움이 되지만, 완전한 메모리 안전성을 보장하지는 않습니다. 개발자는 여전히 메모리 관리에 대한 깊은 이해를 바탕으로 주의 깊게 코드를 작성하고, `DebugAllocator`와 같은 도구를 활용하여 메모리 관련 오류를 적극적으로 찾아내야 합니다.
