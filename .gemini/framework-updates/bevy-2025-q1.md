# Bevy 2025년 1분기 주요 업데이트 분석: Bevy 0.16 마이그레이션 가이드

## 서론: Bevy 0.16의 진화와 1분기 핵심 요약

Bevy 0.16은 엔진의 핵심 철학을 한 단계 발전시킨 중대한 릴리즈입니다. 2025년 1분기(1월~3월) 내내 활발한 개발이 진행되었고, 4월 말에 최종 버전이 공식 출시되었습니다. 따라서 본 보고서는 2025년 1분기 Bevy 개발 동향의 핵심 결과물인 0.16 버전으로의 마이그레이션에 초점을 맞춥니다.

본 보고서는 Bevy 0.15에서 0.16으로 프로젝트를 이전하는 개발자를 위한 포괄적이고 실용적인 지침서를 목표로 합니다. 각 변경 사항이 '왜' 도입되었는지, 그리고 기존 코드와 향후 개발 사고방식에 어떤 영향을 미치는지 심도 있게 분석합니다.

Bevy 0.16의 수많은 변화는 크게 세 가지 핵심 축을 중심으로 요약될 수 있습니다: GPU 기반 렌더링(GPU-Driven Rendering), ECS 관계(ECS Relationships) 시스템, 그리고 통합 에러 핸들링(Unified Error Handling). 이 세 가지는 각각 성능, 데이터 구조, 코드 안정성이라는 게임 엔진의 근간을 이룹니다.

---

## 1부: 핵심 패러다임 전환: 모든 개발자가 반드시 이해해야 할 3가지 주요 변경점

Bevy 0.16의 주요 변경점들은 엔진의 근본적인 작동 방식을 바꾸는 '패러다임의 전환'에 가깝습니다. 통합 에러 핸들링은 코드의 '흐름'을, ECS 관계 시스템은 데이터의 '구조'를, 그리고 GPU 기반 렌더링은 성능의 '모델'을 재정의합니다.

### 1.1. 통합 에러 핸들링(Unified Error Handling): `panic!`과의 작별과 `Result`를 반환하는 시스템

* 변경 내용: Bevy 0.16부터 시스템(systems), 옵저버(observers), 커맨드(commands)에서 표준 Rust의 `Result<(), BevyError>` 타입을 반환하는 것이 공식적으로 지원됩니다. 이로 인해 이전에 `panic`을 일으켰던 수많은 핵심 API (특히 `Query::single`, `Query::single_mut` 등)가 이제 `panic` 대신 `Result`를 반환하도록 변경되었습니다.
* 변경 이유: 코드의 안정성과 예측 가능성을 높이기 위함입니다. `panic!` 남용을 줄이고, 개발자에게 에러를 명시적으로 처리하도록 강제하여 코드의 견고함을 향상시킵니다. `BevyError`는 다양한 에러 타입을 담을 수 있으며 디버깅에 유용한 고품질 백트레이스를 자동으로 캡처합니다.
* 개발자 필수 조치:
  * `Result` 처리: `Query::single_mut()`와 같이 `Result`를 반환하는 함수를 호출하는 모든 곳에서 에러 처리가 필요합니다. Rust의 `let-else` 구문이 유용합니다.

        ```rust
        // 0.15: 쿼리 결과가 1개가 아니면 panic 발생
        // let mut player_transform = query.single_mut();
        // 0.16: Result를 명시적으로 처리해야 함
        fn player_system(mut query: Query<&mut Transform, With<Player>>) {
            let Ok(mut player_transform) = query.get_single_mut() else {
                // 플레이어가 없거나 여러 명일 경우, 시스템을 조용히 종료
                return;
            };
            //... 로직 계속
        }
        ```

  * `?` 연산자 활용: 시스템 함수 시그니처를 `fn my_system() -> Result<(), BevyError>`로 변경하면, 시스템 내에서 `?` 연산자를 사용하여 에러를 간결하게 전파할 수 있습니다.
  * Deprecated API 교체: 기존의 `Query::get_single()` 및 관련 메소드들은 deprecated 되었으므로, `Query::get_single()`과 `Query::get_single_mut()`을 사용해야 합니다. `unwrap()` 남용을 지양해야 합니다.

### 1.2. ECS 관계(Relationships) 시스템: 새로운 계층 구조와 엔티티 연결 방식

* 변경 내용: Bevy 0.16은 엔티티 간의 연결을 표현하는 방식을 재설계했습니다. 기존의 부모-자식 계층 구조는 `Parent`와 `Children` 특수 컴포넌트 대신, `Relationship`과 `RelationshipTarget`이라는 일반화된 컴포넌트를 기반으로 재구축되었습니다. 기존의 부모-자식 관계는 `ChildOf`라는 `Relationship`과 `Children`이라는 `RelationshipTarget`으로 구현됩니다. 즉, `Parent` 컴포넌트는 `ChildOf`로 이름이 변경되었습니다.
* 변경 이유: 기존 계층 구조 시스템은 핵심 ECS 데이터 모델과 분리되어 재사용이 어렵고 데이터 무결성 보장을 위해 비용이 비쌌습니다. 새로운 관계 시스템은 엔티티 간 연결을 일반적인 ECS 기능으로 통합하여 유연성, 재사용성, 성능 향상으로 이어집니다.
* 개발자 필수 조치:
  * 자식 엔티티 추가 방식 변경: 더 이상 부모 엔티티에 `with_children`을 사용하는 것이 유일한 방법이 아닙니다. 이제 자식 엔티티를 생성할 때 `ChildOf(parent_entity)` 컴포넌트를 직접 삽입하여 관계를 설정하는 것이 기본 방식입니다.

        ```rust
        // 0.15: ChildBuilder를 사용
        // commands.spawn(SpriteBundle::default()).with_children(|parent| {
        //     parent.spawn(SpriteBundle::default());
        // });
        // 0.16: 자식에게 ChildOf 컴포넌트를 직접 삽입
        let parent = commands.spawn(SpriteBundle::default()).id();
        commands.spawn(SpriteBundle::default()).insert(ChildOf(parent));
        ```

  * 계층적 비활성화(Despawning) 로직 변경:
    * `despawn_recursive()`는 이제 `despawn()`으로 이름이 변경되었습니다. 부모 엔티티에 `commands.entity(parent).despawn()`을 호출하면, 기본적으로 모든 자손 엔티티가 함께 제거됩니다.
    * 자손들만 제거하고 부모는 남겨두고 싶다면, `commands.entity(parent).despawn_related::<Children>()`을 사용해야 합니다.
    * 부모만 제거하고 자식들은 월드에 남겨두려면, `despawn()`을 호출하기 전에 먼저 `commands.entity(parent).remove::<Children>()`을 호출하여 관계를 끊어야 합니다.
  * 커스텀 관계 정의: `#[derive(Component)]`와 함께 `#[relationship]` 속성을 사용하여 자신만의 관계를 정의할 수 있습니다.

        ```rust
        #[derive(Component)]
        struct Ship;
        #[derive(Component)]
        struct AttachedTo(Entity); // 포탑이 이 컴포넌트를 가짐

        struct ShipAttachments(Vec<Entity>); // 함선이 이 컴포넌트를 가짐
        ```

### 1.3. GPU 기반 렌더링(GPU-Driven Rendering)으로의 전환: 원리와 개발자에게 미치는 영향

* 변경 내용: Bevy 0.16은 렌더링 파이프라인에서 GPU 기반 렌더링을 도입했습니다. CPU는 최소한의 정보만 GPU에 전달하고, GPU가 컬링, 데이터 조회, 렌더링까지 대부분의 작업을 주도적으로 처리합니다.
* 변경 이유: 특히 수천, 수만 개의 오브젝트가 존재하는 대규모 씬에서 CPU의 렌더링 준비 작업 병목 현상을 해결하여 성능을 향상시키기 위함입니다. 실제 테스트에서 Bevy 0.16은 0.15 대비 약 3배의 렌더링 성능 향상을 보여주었습니다.
* 개발자 필수 조치:
  * 자동 적용: 표준 `PbrBundle`을 사용하는 대부분의 3D 메쉬 렌더링은 지원되는 플랫폼에서 자동으로 GPU 기반 렌더링 파이프라인을 타게 됩니다.
  * 커스텀 셰이더의 경우: WGSL을 사용하여 자신만의 커스텀 머티리얼과 셰이더를 작성했다면 `AsBindGroup` derive 매크로에 새로운 `#[bindless]` 속성을 사용해야 할 수 있습니다. 사용하지 않으면 이전 방식의 CPU 기반 렌더링으로 폴백(fallback)될 수 있습니다.
* 현재 제한 사항: 3D 메쉬 렌더링 파이프라인에만 적용되며, 2D 스프라이트, UI, 모프 타겟 등은 아직 지원되지 않습니다. 또한, Multi-draw indirect(MDI)를 지원하지 않는 일부 플랫폼(예: WebGL 2)에서는 기능이 제한됩니다.

---

## 2부: ECS 심층 분석: API 변경 및 마이그레이션 상세 가이드

1부에서 설명한 핵심 패러다임 전환은 Bevy의 ECS(Entity Component System) 전반에 걸쳐 구체적인 API 변경으로 나타났습니다.

### 2.1. 개선된 스폰(Spawn) API: `children!` 및 `related!` 매크로 활용법

* 변경 내용: 엔티티 계층과 관계를 생성하는 방식이 더욱 직관적이고 데이터 중심으로 개선되었습니다. 새로운 Relationship 시스템 도입의 직접적인 결과로, 기존의 `with_children` 클로저 방식과 더불어 `children!` 및 `related!` 매크로를 사용하여 엔티티 계층과 관계를 선언적으로 생성할 수 있게 되었습니다.
* 마이그레이션 예시:
  * 0.15 및 0.16에서 모두 유효한 방식:

        ```rust
        commands.spawn(ParentBundle).with_children(|parent| {
            parent.spawn(ChildBundle1);
            parent.spawn(ChildBundle2);
        });
        ```

  * 0.16의 새로운 방식: `push_children`과 배열 사용

        ```rust
        commands.spawn(ParentBundle).push_children(&[]);
        ```

  * 0.16의 `children!` 매크로를 사용한 가장 선언적인 방식 (가상 코드):

        ```rust
        commands.spawn((
            ParentBundle,
            SpatialBundle::default(),
            // children!()
        ));
        ```

* 핵심: 이 새로운 스폰 API는 1.2절에서 설명한 Relationship 시스템과 직접적으로 연동됩니다. `children!` 매크로는 내부적으로 `ChildOf` 관계를 설정해주며, `related!` 매크로는 개발자가 정의한 커스텀 관계(예: `AttachedTo`)를 설정하는 데 사용됩니다.

### 2.2. 엔티티 비활성화 및 기본 쿼리 필터(Default Query Filters): `Disabled` 컴포넌트의 도입

* 변경 내용: Bevy 0.16은 엔티티에 `Disabled`라는 새로운 마커 컴포넌트를 추가하면, 해당 엔티티는 기본적으로 대부분의 쿼리에서 자동으로 제외되도록 했습니다. 이는 엔티티를 `despawn`하고 다시 `spawn`하는 비싼 비용 없이, 오브젝트를 일시적으로 숨기거나 게임 로직에서 제외하는 효율적인 방법을 제공합니다.
* 개발자 필수 조치:
  * `insert_or_spawn` 계열 함수의 Deprecation: 성능 문제로 인해 `Commands::insert_or_spawn_batch()`와 같은 함수들이 deprecated 되었습니다.
  * `Disabled` 컴포넌트 활용: 이제 엔티티를 재사용해야 하는 경우, `despawn` 후 `spawn`하는 대신 `Disabled` 컴포넌트를 추가하거나 제거하는 방식이 권장됩니다.

        ```rust
        // 총알 비활성화
        commands.entity(bullet_entity).insert(Disabled);
        // 총알 재활성화
        commands.entity(bullet_entity).remove::<Disabled>();
        ```

  * 쿼리 필터 주의: 이 기능은 모든 `Query`에 암묵적으로 `Without<Disabled>` 필터가 추가된 것과 같은 효과를 가집니다. 비활성화된 엔티티를 명시적으로 찾아야 한다면, 쿼리에 `With<Disabled>` 필터를 직접 추가해야 합니다.

### 2.3. 엔티티 복제, 불변 컴포넌트, 그리고 기타 주요 ECS 변경 사항

Bevy 0.16의 ECS는 데이터 관리의 편의성과 안정성을 높이는 여러 중요한 기능들을 추가했습니다.

* 엔티티 복제(Entity Cloning): 이제 엔티티와 그 컴포넌트들을 복제하는 기능이 공식적으로 지원됩니다. 복제하고 싶은 컴포넌트에 `#[derive(Clone)]` 속성을 추가한 뒤, `World::clone_entity` 또는 `Commands::clone_entity`를 사용하여 엔티티의 복사본을 생성할 수 있습니다.
* 불변 컴포넌트(Immutable Components): 특정 컴포넌트가 일단 엔티티에 추가된 후에는 그 내용이 변경될 수 없도록 강제하는 기능이 도입되었습니다.
* 기타 주요 API 이름 변경: 마이그레이션 시 컴파일러가 지적할 몇 가지 중요한 API 이름 변경 사항들이 있습니다.
  * `EventWriter::send()`가 `EventWriter::write()`로 변경되었습니다.
  * `Query::to_readonly()`가 `Query::as_readonly()`로 변경되었습니다.
  * 옵저버(Observer)에서 사용되는 `Trigger::entity()`가 `Trigger::target()`으로 변경되었습니다.
  * `MapEntities` 트레잇이 기존의 `VisitEntities`를 대체합니다.

---

## 3부: 렌더링 및 코어 엔진 변경 사항

Bevy 0.16의 변화는 ECS에만 국한되지 않습니다. 렌더링 파이프라인과 엔진의 가장 근본적인 구조에도 중요한 변경이 있었습니다.

### 3.1. 새로운 내장 기능: 절차적 대기 산란과 데칼

Bevy 0.16은 개발자들이 외부 플러그인 없이도 고품질의 시각 효과를 구현할 수 있도록 두 가지 강력한 렌더링 기능을 내장했습니다.

* 절차적 대기 산란(Procedural Atmospheric Scattering):
  * 이전에는 복잡한 커스텀 셰이더나 서드파티 에셋을 통해서만 가능했던 물리 기반의 사실적인 대기 효과를 이제 엔진 자체에서 지원합니다.
  * 카메라 엔티티에 `Atmosphere` 컴포넌트를 추가하는 것만으로 지구와 유사한 하늘, 사실적인 일출과 일몰, 대기 원근 효과 등을 시뮬레이션할 수 있습니다.
  * `DirectionalLight`를 태양으로 간주하며, HDR 렌더링과 함께 사용할 때 최상의 결과를 보여줍니다.
* 데칼(Decals):
  * 렌더링된 3D 메쉬 표면 위에 동적으로 텍스처를 덧입히는 기능입니다.
  * Bevy 0.16은 하드웨어 호환성이 넓은 포워드 데칼(Forward Decals)과 품질이 더 높은 클러스터드 데칼(Clustered Decals) 두 가지 방식을 제공합니다.

### 3.2. `no_std` 지원과 `bevy_platform` 크레이트의 도입

* 변경 내용: Bevy 0.16의 가장 근본적인 아키텍처 변화는 `no_std` 환경 지원입니다. 이는 Bevy를 게임보이 어드밴스와 같은 임베디드 시스템이나 레트로 콘솔에서도 사용할 수 있게 만듦을 의미합니다. `no_std` 환경에서는 Rust의 표준 라이브러리를 사용할 수 없으므로, 엔진의 내부 의존성을 대대적으로 재구성해야 했습니다.
  * 기존에 다양한 유틸리티성 기능을 담고 있던 `bevy_utils`와 `bevy_core` 크레이트가 해체되고, 그 기능들이 여러 개의 작고 전문화된 크레이트로 분리 및 재배치되었습니다.
  * 특히, 표준 라이브러리에 의존하는 컬렉션 타입(예: `HashMap`)과 플랫폼별 API를 처리하기 위해 `bevy_platform`이라는 새로운 크레이트가 도입되었습니다.
* 개발자 필수 조치: 이 구조 변경은 `bevy::prelude::*`를 사용하지 않고 개별 타입을 직접 `use` 구문으로 가져와 사용하던 거의 모든 프로젝트에 영향을 미칩니다. 마이그레이션 시 수많은 "unresolved import" 또는 "not found in this scope" 에러를 마주하게 될 것입니다.
  * 주요 타입 경로 변경 표:

        | 기능/타입 | 이전 경로 (Bevy 0.15 Path) | 새로운 경로 (Bevy 0.16 Path) |
        |---|---|---|
        | `HashMap`, `HashSet`, etc. | `bevy_utils::collections` | `bevy_platform::collections` |
        | `Time`, `Timer` | `bevy_core::time` | `bevy_time` |
        | `Name` | `bevy_core` | `bevy_ecs::name` |
        | `TaskPool` | `bevy_core::task` | `bevy_tasks` |
        | `FrameCount` | `bevy_core` | `bevy_app` |
        | `CoreSet` | `bevy_core::CoreSet` | `bevy_app::AppSet` |

### 3.3. 에셋 및 기타 코어 API 마이그레이션

`no_std` 리팩토링 외에도 코어 엔진과 에셋 시스템에 몇 가지 주목할 만한 변경 사항이 있습니다.

* 에셋(Assets): `AssetChanged` 쿼리 필터가 새로 추가되었습니다. 이 필터를 사용하면 `Handle<T>`가 가리키는 에셋의 내용이 변경되었을 때 이를 감지하는 시스템을 매우 쉽게 작성할 수 있습니다.
* 오디오(Audio): 오디오 재생을 더 세밀하게 제어할 수 있는 기능들이 추가되었습니다.
  * `AudioSinkPlayback::toggle()` 메소드가 `toggle_playback()`으로 이름이 변경되었습니다.
  * `Volume` 타입이 이제 선형(Linear) 값뿐만 아니라 데시벨(Decibels) 단위로도 볼륨을 설정할 수 있는 `enum`으로 변경되었습니다.
* Rust 2024 Edition으로 업그레이드: Bevy 엔진 자체가 Rust 2024 Edition을 사용하도록 업그레이드되었습니다.

---

## 4부: 주요 생태계 플러그인 마이그레이션

Bevy의 활발한 커뮤니티 생태계는 엔진 자체의 변경 사항만큼이나 중요합니다. 이 섹션에서는 가장 널리 사용되는 물리 및 UI 플러그인의 0.16 마이그레이션 가이드를 제공합니다.

### 4.1. `bevy_rapier`: 물리 엔진 업데이트 가이드

`bevy_rapier`는 Bevy에서 가장 널리 사용되는 물리 엔진 플러그인입니다. Bevy 0.16의 대대적인 ECS 변경으로 인해, `bevy_rapier` 또한 상당한 수정이 필요했습니다.

* 호환성 및 버전 관리: Bevy 0.16 릴리즈 시 호환되는 `bevy_rapier` 공식 버전이 즉시 출시되지 않았을 수 있습니다. 이때는 `Cargo.toml`에 다음과 같이 직접 `git` 저장소를 의존성으로 추가하여 개발을 이어나갈 수 있습니다. 현재는 crates.io에 Bevy 0.16과 호환되는 공식 버전이 릴리즈되었습니다.

      ```ini
      # 예시: 공식 릴리즈가 없을 때 임시로 사용하는 방법
      # bevy_rapier3d = { git = "[https://github.com/dimforge/bevy_rapier.git](https://github.com/dimforge/bevy_rapier.git)", rev = "..." }
      ```

* 주요 변경 사항:
  * `RapierContext` 접근 방식 변경: 이전에는 `Res<RapierContext>` 또는 `ResMut<RapierContext>`를 사용했습니다. 이제는 `ReadDefaultRapierContext`와 `WriteDefaultRapierContext`라는 새로운 시스템 파라미터 타입을 사용해야 합니다.
  * `RapierConfiguration` 리소스 통합: 이전 버전에서 별도의 리소스로 존재했던 `Gravity`와 `RapierPhysicsScale`이 `RapierConfiguration`이라는 단일 리소스로 통합되었습니다.
  * API 이름 변경: 일부 API의 이름이 변경되었습니다. 예를 들어, 충돌 쌍을 가져오는 `contacts_with` 메소드는 `contact_pairs_with`으로 이름이 바뀌었습니다.

### 4.2. `bevy_egui` 및 `bevy-inspector-egui`: UI 및 디버깅 툴 업데이트

`bevy_egui`는 즉시 모드 GUI(Immediate Mode GUI)를 통합하기 위한 플러그인이며, `bevy-inspector-egui`는 디버깅 도구입니다.

* `bevy_egui` 업데이트: Bevy 0.16에 맞춰 `bevy_egui`는 0.34.0 버전으로 업데이트되었습니다.
  * `EguiSettings`가 전역 리소스(Resource)에서 컴포넌트(Component)로 변경되었습니다.
  * `EguiSet::BeginFrame` 시스템 셋(System Set)의 이름이 `EguiSet::BeginPass`로 변경되었습니다.
* `bevy-inspector-egui`의 대대적인 변경:
  * 플러그인 경로 변경: `WorldInspectorPlugin`은 `quick::WorldInspectorPlugin`으로, `InspectorPlugin`은 `quick::ResourceInspectorPlugin`으로 경로가 변경되었습니다.
  * `Inspectable`에서 `Reflect`로 전환: 이전에는 `#[derive(Inspectable)]`을 사용하고 `app.register_inspectable::<MyType>()`을 호출했습니다. 이제 Bevy의 내장 리플렉션 시스템을 활용합니다. `#`를 사용하고, `app.register_type::<MyType>()`을 호출해야 합니다. `ResourceInspectorPlugin`은 더 이상 리소스를 자동으로 월드에 추가하지 않으므로, `app.init_resource::<MyType>()`을 별도로 호출해야 합니다.

        ```rust
        // 0.15 방식
        // #
        // struct MyData { /* ... */ }
        // app.register_inspectable::<MyData>();

        // 0.16 방식
        #
        struct MyData { /* ... */ }
        app.init_resource::<MyData>()
          .register_type::<MyData>()
          .add_plugins(bevy_inspector_egui::quick::ResourceInspectorPlugin::<MyData>::new());
        ```

---

## 5부: 성능에 대한 고찰: 렌더링 향상과 알려진 ECS 회귀 문제

성능은 모든 게임 엔진의 핵심적인 관심사입니다. Bevy 0.16의 성능 프로필은 '양면성'을 가지고 있습니다.

### 렌더링 성능의 비약적 향상

Bevy 0.16의 가장 큰 성과는 렌더링 성능의 최적화입니다.

* GPU 기반 렌더링: 1.3절에서 설명했듯이, 렌더링의 주도권을 CPU에서 GPU로 넘김으로써 대규모 3D 씬의 CPU 오버헤드가 크게 감소했습니다.
* 병렬화된 Transform 전파: 엔티티의 Transform이 변경될 때, 자식 엔티티들의 GlobalTransform을 재계산하는 과정이 병렬화되어 속도가 크게 향상되었습니다.

### 알려진 ECS 성능 회귀(Regression) 문제

* 이슈 발견: Bevy 0.16.0 릴리즈 후, 일부 핵심 ECS 연산(컴포넌트 가져오는 `get` 연산, 컴포넌트 추가하는 `insertion` 연산)에서 성능 저하(regression)가 발견되었습니다.
* 원인과 상황: 새로운 Relationship 시스템 도입과 같은 ECS 내부 아키텍처 변경 과정에서 발생한 부작용으로 추정됩니다. 이 문제는 GitHub에서 공개적으로 추적되고 있으며 (이슈 `#19504`), 후속 패치 릴리즈에서 개선될 가능성이 높습니다.
* 개발자에게 미치는 영향: 렌더링 부하가 큰(GPU-bound) 프로젝트는 전반적인 FPS가 향상될 가능성이 높습니다. 그러나 CPU 집약적인 ECS 로직을 가진 프로젝트(수십만 개의 엔티티가 빈번하게 읽고 쓰는 시뮬레이션 게임 등)는 이 ECS 성능 저하를 체감할 수도 있습니다.

---

## 결론: Bevy 0.16 마이그레이션 요약 및 다음 단계

Bevy 0.16은 엔진의 성숙도를 한 단계 끌어올린 기념비적인 업데이트입니다. GPU 기반 렌더링, 일반화된 ECS 관계, 통합 에러 핸들링과 같은 근본적인 아키텍처 개선은 개발자에게 더 나은 성능, 향상된 유연성, 그리고 견고한 코드 작성 환경을 제공합니다.

### 마이그레이션 핵심 요약

Bevy 0.15에서 0.16으로의 마이그레이션 작업은 크게 세 가지 영역에 집중됩니다.

1. 에러 핸들링 로직 수정: `panic!`을 유발하던 수많은 함수가 이제 `Result`를 반환합니다. `?` 연산자나 `let-else` 구문을 사용하여 모든 실패 가능한 호출을 명시적으로 처리해야 합니다.
2. 계층 구조 코드 수정: `Parent`가 `ChildOf`로 변경되고, 엔티티를 `despawn`하는 로직이 변경되었습니다. 자식을 추가하고 제거하는 모든 코드를 새로운 관계 시스템의 규칙에 맞게 수정해야 합니다.
3. `use` 구문 수정: `no_std` 지원을 위한 대규모 리팩토링으로 `bevy_utils`와 `bevy_core`가 해체되었습니다. 이로 인해 수많은 타입의 경로가 변경되었으므로, 컴파일러가 "unresolved import" 에러를 뱉어내는 부분을 본 보고서의 3.2절에 있는 표를 참조하여 수정해야 합니다.

### 0.16으로 업그레이드해야 하는 이유

마이그레이션의 수고로움에도 불구하고 Bevy 0.16으로 업그레이드하는 것은 강력하게 권장됩니다. 향상된 렌더링 성능은 즉각적인 이점을 제공하며, 새롭게 정립된 ECS 아키텍처는 향후 더 복잡하고 규모 있는 게임을 개발할 수 있는 견고한 토대가 됩니다. 최신 버전을 꾸준히 따라가는 것이 Bevy 생태계의 최신 기술과 커뮤니티의 지원을 최대한 활용하는 길입니다.

### 다음 단계

성공적인 마이그레이션을 위해 다음 자료들을 적극적으로 활용할 것을 권장합니다.

* 공식 문서 참조: Bevy 공식 웹사이트에 게시된 "0.15 to 0.16 Migration Guide"는 가장 정확하고 상세한 정보를 담고 있는 최종 권위 자료입니다.
* 공식 예제 학습: Bevy의 공식 예제들은 항상 최신 버전에 맞춰 업데이트됩니다. 새로운 API나 기능의 사용법이 궁금할 때, 관련 예제 코드를 분석하는 것이 가장 빠르고 효과적인 학습 방법입니다.
* 커뮤니티 활용: Bevy 공식 Discord 서버나 GitHub Discussions를 통해 질문하고 도움을 받을 수 있습니다.

Bevy 0.16은 단순한 변화를 넘어, Bevy가 지향하는 '데이터 중심' 철학의 진화를 보여줍니다. 이 변화의 흐름에 동참함으로써, 개발자는 더 강력하고 표현력 있는 도구를 손에 넣게 될 것입니다.
