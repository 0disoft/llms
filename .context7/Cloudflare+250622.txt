TITLE: Handling Requests with Fetch Handler in JavaScript
DESCRIPTION: This JavaScript snippet demonstrates the basic `fetch` handler for Cloudflare Workers. It asynchronously processes incoming requests and returns a simple 'Hello World!' `Response` object. This is the default entry point for Workers written in ES modules syntax.
SOURCE: https://github.com/cloudflare/cloudflare-docs/blob/production/src/content/partials/workers/compute-per-request.mdx#_snippet_0

LANGUAGE: JavaScript
CODE:
```
export default {
	async fetch(request, env, ctx) {
		return new Response('Hello World!');
	},
};
```

----------------------------------------

TITLE: Converting Documents to Markdown using Workers AI Binding (TypeScript)
DESCRIPTION: This TypeScript snippet demonstrates how to use the `env.AI.toMarkdown()` utility in Cloudflare Workers AI to convert documents fetched from R2 storage into Markdown. It shows fetching a PDF and a JPEG image, then passing them as Blobs to the `toMarkdown` function, which automatically detects and summarizes the image content.
SOURCE: https://github.com/cloudflare/cloudflare-docs/blob/production/src/content/changelog/workers-ai/2025-03-20-markdown-conversion.mdx#_snippet_0

LANGUAGE: typescript
CODE:
```
import { Env } from "./env";

export default {
	async fetch(request: Request, env: Env, ctx: ExecutionContext) {
		// https://pub-979cb28270cc461d94bc8a169d8f389d.r2.dev/somatosensory.pdf
		const pdf = await env.R2.get("somatosensory.pdf");

		// https://pub-979cb28270cc461d94bc8a169d8f389d.r2.dev/cat.jpeg
		const cat = await env.R2.get("cat.jpeg");

		return Response.json(
			await env.AI.toMarkdown([
				{
					name: "somatosensory.pdf",
					blob: new Blob([await pdf.arrayBuffer()], {
						type: "application/octet-stream"
					})
				},
				{
					name: "cat.jpeg",
					blob: new Blob([await cat.arrayBuffer()], {
						type: "application/octet-stream"
					})
				}
			])
		);
	}
};
```

----------------------------------------

TITLE: Implementing a Hibernatable WebSocket Server in TypeScript
DESCRIPTION: This TypeScript code provides a type-safe implementation of a `WebSocketHibernationServer` Durable Object. It includes an `Env` interface for Durable Object namespace binding and demonstrates the same hibernatable WebSocket server logic as the JavaScript example, handling connection acceptance, message echoing, and client disconnections with proper type annotations.
SOURCE: https://github.com/cloudflare/cloudflare-docs/blob/production/src/content/docs/durable-objects/best-practices/websockets.mdx#_snippet_1

LANGUAGE: TypeScript
CODE:
```
import { DurableObject } from "cloudflare:workers";

export interface Env {
	WEBSOCKET_HIBERNATION_SERVER: DurableObjectNamespace<WebSocketHibernationServer>;
}

// Durable Object
export class WebSocketHibernationServer extends DurableObject {
	async fetch(request: Request): Promise<Response> {
		// Creates two ends of a WebSocket connection.
		const webSocketPair = new WebSocketPair();
		const [client, server] = Object.values(webSocketPair);

		// Calling `acceptWebSocket()` informs the runtime that this WebSocket is to begin terminating
		// request within the Durable Object. It has the effect of "accepting" the connection,
		// and allowing the WebSocket to send and receive messages.
		// Unlike `ws.accept()`, `state.acceptWebSocket(ws)` informs the Workers Runtime that the WebSocket
		// is "hibernatable", so the runtime does not need to pin this Durable Object to memory while
		// the connection is open. During periods of inactivity, the Durable Object can be evicted
		// from memory, but the WebSocket connection will remain open. If at some later point the
		// WebSocket receives a message, the runtime will recreate the Durable Object
		// (run the `constructor`) and deliver the message to the appropriate handler.
		this.ctx.acceptWebSocket(server);

		return new Response(null, {
			status: 101,
			webSocket: client,
		});
	}

	async webSocketMessage(ws: WebSocket, message: ArrayBuffer | string) {
		// Upon receiving a message from the client, the server replies with the same message,
		// and the total number of connections with the "[Durable Object]: " prefix
		ws.send(
			`[Durable Object] message: ${message}, connections: ${this.ctx.getWebSockets().length}`,
		);
	}

	async webSocketClose(
		ws: WebSocket,
		code: number,
		reason: string,
		wasClean: boolean,
	) {
		// If the client closes the connection, the runtime will invoke the webSocketClose() handler.
		ws.close(code, "Durable Object is closing WebSocket");
	}
}
```

----------------------------------------

TITLE: Updating Apache LogFormat for Original IP
DESCRIPTION: This updated LogFormat entry replaces %h with %a in apache.conf. The %a directive ensures that the client's IP address, as determined by mod_remoteip from the CF-Connecting-IP header, is logged instead of the Cloudflare IP.
SOURCE: https://github.com/cloudflare/cloudflare-docs/blob/production/src/content/docs/support/troubleshooting/restoring-visitor-ips/restoring-original-visitor-ips.mdx#_snippet_3

LANGUAGE: apache config
CODE:
```
LogFormat "%a %l %u %t \"%r\" %>s %O \"%{Referer}i\" \"%{User-Agent}i\"" combined
```

----------------------------------------

TITLE: Querying a Vectorize Index with a Basic Vector - TypeScript
DESCRIPTION: This snippet demonstrates how to perform a basic vector search on a Vectorize index. It initializes a query vector as an array of numbers and uses the `query()` method on the index to find the nearest vectors. The query vector's dimensions must match the index's dimensions.
SOURCE: https://github.com/cloudflare/cloudflare-docs/blob/production/src/content/docs/vectorize/best-practices/query-vectors.mdx#_snippet_0

LANGUAGE: TypeScript
CODE:
```
// query vector dimensions must match the Vectorize index dimension being queried
let queryVector = [54.8, 5.5, 3.1, ...];
let matches = await env.YOUR_INDEX.query(queryVector);
```

----------------------------------------

TITLE: Defining a Cloudflare Workflow in TypeScript
DESCRIPTION: This TypeScript code defines a basic Cloudflare Workflow, extending `WorkflowEntrypoint` and implementing a `run` method. It demonstrates defining user-defined parameters, executing asynchronous steps with `step.do()`, introducing delays with `step.sleep()`, and configuring custom retry strategies for potentially failing operations. The `fetch` handler also shows how to interact with the Workflow binding to create new instances or retrieve existing instance statuses.
SOURCE: https://github.com/cloudflare/cloudflare-docs/blob/production/src/content/docs/workflows/get-started/cli-quick-start.mdx#_snippet_1

LANGUAGE: ts
CODE:
```
import { WorkflowEntrypoint, WorkflowStep, WorkflowEvent } from 'cloudflare:workers';

type Env = {
	// Add your bindings here, e.g. Workers KV, D1, Workers AI, etc.
	MY_WORKFLOW: Workflow;
};

// User-defined params passed to your workflow
type Params = {
	email: string;
	metadata: Record<string, string>;
};

export class MyWorkflow extends WorkflowEntrypoint<Env, Params> {
	async run(event: WorkflowEvent<Params>, step: WorkflowStep) {
		// Can access bindings on `this.env`
		// Can access params on `event.payload`

		const files = await step.do('my first step', async () => {
			// Fetch a list of files from $SOME_SERVICE
			return {
				files: [
					'doc_7392_rev3.pdf',
					'report_x29_final.pdf',
					'memo_2024_05_12.pdf',
					'file_089_update.pdf',
					'proj_alpha_v2.pdf',
					'data_analysis_q2.pdf',
					'notes_meeting_52.pdf',
					'summary_fy24_draft.pdf',
				],
			};
		});

		const apiResponse = await step.do('some other step', async () => {
			let resp = await fetch('https://api.cloudflare.com/client/v4/ips');
			return await resp.json<any>();
		});

		await step.sleep('wait on something', '1 minute');

		await step.do(
			'make a call to write that could maybe, just might, fail',
			// Define a retry strategy
			{
				retries: {
					limit: 5,
					delay: '5 second',
					backoff: 'exponential',
				},
				timeout: '15 minutes',
			},
			async () => {
				// Do stuff here, with access to the state from our previous steps
				if (Math.random() > 0.5) {
					throw new Error('API call to $STORAGE_SYSTEM failed');
				}
			},
		);
	}
}

export default {
	async fetch(req: Request, env: Env): Promise<Response> {
		let id = new URL(req.url).searchParams.get('instanceId');

		// Get the status of an existing instance, if provided
		if (id) {
			let instance = await env.MY_WORKFLOW.get(id);
			return Response.json({
				status: await instance.status(),
			});
		}

		// Spawn a new instance and return the ID and status
		let instance = await env.MY_WORKFLOW.create();
		return Response.json({
			id: instance.id,
			details: await instance.status(),
		});
	},
};
```

----------------------------------------

TITLE: Configuring Microsoft 365 Tenant Control - Policy 2 (Office365 Application) - Cloudflare Gateway Policy
DESCRIPTION: This policy allows access to the Microsoft Office365 application and enforces tenant restrictions using custom headers. It requires `Restrict-Access-To-Tenants` and `Restrict-Access-Context` headers, both set to the organization's domain, to ensure users only access corporate accounts. This policy follows the `login.live.com` policy in precedence.
SOURCE: https://github.com/cloudflare/cloudflare-docs/blob/production/src/content/docs/cloudflare-one/policies/gateway/http-policies/tenant-control.mdx#_snippet_1

LANGUAGE: Cloudflare Gateway Policy
CODE:
```
Policy Rule: Application in Microsoft Office365
Action: Allow
Untrusted certificate action: Block
Custom Header: Restrict-Access-To-Tenants: Your organization's domain
Custom Header: Restrict-Access-Context: Your organization's domain
```

----------------------------------------

TITLE: Generating a Cryptographically Secure Shared Secret (Shell)
DESCRIPTION: This shell command uses `openssl` to generate a 32-byte (64-character hex string) cryptographically secure random string. This string is intended to be used as a shared secret for authenticating clients with the Cloudflare Worker.
SOURCE: https://github.com/cloudflare/cloudflare-docs/blob/production/src/content/docs/queues/examples/publish-to-a-queue-over-http.mdx#_snippet_1

LANGUAGE: sh
CODE:
```
openssl rand -hex 32
```

----------------------------------------

TITLE: Access and Query Database using Hyperdrive Binding in Pages Function
DESCRIPTION: These code examples demonstrate how to access a Hyperdrive binding, named `HYPERDRIVE`, from `context.env` within a Cloudflare Pages Function. It shows how to establish a connection to a PostgreSQL database using `postgres.js` and perform a `SELECT` query, returning the results as JSON or handling errors.
SOURCE: https://github.com/cloudflare/cloudflare-docs/blob/production/src/content/docs/pages/functions/bindings.mdx#_snippet_14

LANGUAGE: javascript
CODE:
```
import postgres from "postgres";

export async function onRequest(context) {
	// create connection to postgres database
	const sql = postgres(context.env.HYPERDRIVE.connectionString);

	try {
		const result = await sql`SELECT id, name, value FROM records`;

		return Response.json({result: result})
	} catch (e) {
		return Response.json({error: e.message, {status: 500}});
	}
}
```

LANGUAGE: typescript
CODE:
```
import postgres from "postgres";

interface Env {
	HYPERDRIVE: Hyperdrive;
}

type MyRecord = {
	id: number;
	name: string;
	value: string;
};

export const onRequest: PagesFunction<Env> = async (context) => {
	// create connection to postgres database
	const sql = postgres(context.env.HYPERDRIVE.connectionString);

	try {
		const result = await sql<MyRecord[]>`SELECT id, name, value FROM records`;

		return Response.json({result: result})
	} catch (e) {
		return Response.json({error: e.message, {status: 500}});
	}
};
```

----------------------------------------

TITLE: Implement Next.js Sign-in and User Profile Page
DESCRIPTION: This TypeScript code provides a complete `page.ts` file for a Next.js application, implementing a basic sign-in interface using Resend for email-based authentication and a user profile management section. It integrates with `auth.js`, `@auth/d1-adapter` for database updates, and `@opennextjs/cloudflare` for Cloudflare context, allowing users to sign in, view details, update their name, and sign out.
SOURCE: https://github.com/cloudflare/cloudflare-docs/blob/production/src/content/docs/developer-spotlight/tutorials/fullstack-authentication-with-next-js-and-cloudflare-d1.mdx#_snippet_22

LANGUAGE: ts
CODE:
```
import { redirect } from 'next/navigation';
import { signIn, signOut, auth } from './auth';
import { updateRecord } from '@auth/d1-adapter';
import { getCloudflareContext } from '@opennextjs/cloudflare';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Card, CardContent, CardDescription, CardHeader, CardTitle, CardFooter } from '@/components/ui/card';
import { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/avatar';
import { Label } from '@/components/ui/label';

async function updateName(formData: FormData): Promise<void> {
	'use server';
	const session = await auth();
	if (!session?.user?.id) {
		return;
	}
	const name = formData.get('name') as string;
	if (!name) {
		return;
	}
	const query = `UPDATE users SET name = $1 WHERE id = $2`;
	await updateRecord((await getCloudflareContext({async: true})).env.DB, query, [name, session.user.id]);
	redirect('/');
}

export default async function Home() {
	const session = await auth();
	return (
		<main className="flex items-center justify-center min-h-screen bg-background">
			<Card className="w-full max-w-md">
				<CardHeader className="space-y-1">
					<CardTitle className="text-2xl font-bold text-center">{session ? 'User Profile' : 'Login'}</CardTitle>
					<CardDescription className="text-center">
						{session ? 'Manage your account' : 'Welcome to the auth-js-d1-example demo'}
					</CardDescription>
				</CardHeader>
				<CardContent>
					{session ? (
						<div className="space-y-4">
							<div className="flex items-center space-x-4">
								<Avatar>
									<AvatarImage src={session.user?.image || ''} alt={session.user?.name || ''} />
									<AvatarFallback>{session.user?.name?.[0] || 'U'}</AvatarFallback>
								</Avatar>
								<div>
									<p className="font-medium">{session.user?.name || 'No name set'}</p>
									<p className="text-sm text-muted-foreground">{session.user?.email}</p>
								</div>
							</div>
							<div>
								<p className="text-sm font-medium">User ID: {session.user?.id}</p>
							</div>
							<form action={updateName} className="space-y-2">
								<Label htmlFor="name">Update Name</Label>
								<Input id="name" name="name" placeholder="Enter new name" />
								<Button type="submit" className="w-full">
									Update Name
								</Button>
							</form>
						</div>
					) : (
						<form
							action={async (formData) => {
								'use server';
								await signIn('resend', { email: formData.get('email') as string });
							}}
							className="space-y-4"
						>
							<div className="space-y-2">
								<Input
									type="email"
									name="email"
									placeholder="Email"
									autoCapitalize="none"
									autoComplete="email"
									autoCorrect="off"
									required
								/>
							</div>
							<Button className="w-full" type="submit">
								Sign in with Resend
							</Button>
						</form>
					)}
				</CardContent>
				{session && (
					<CardFooter>
						<form
							action={async () => {
								'use server';
								await signOut();
								Response.redirect('/');
							}}
						>
							<Button type="submit" variant="outline" className="w-full">
								Sign out
							</Button>
						</form>
					</CardFooter>
				)}
			</Card>
		</main>
	);
}
```

----------------------------------------

TITLE: Python: Extracting Structured Data into JSON using DeepSeek Coder
DESCRIPTION: This example illustrates how to instruct the DeepSeek Coder model to extract specific data from a natural language prompt and format it as a JSON object according to a predefined JSON schema. It demonstrates constructing a system prompt that includes the JSON schema, guiding the model to return only JSON, and then sending a user prompt for data extraction. The code makes an API call to Cloudflare's AI platform and displays the resulting JSON output.
SOURCE: https://github.com/cloudflare/cloudflare-docs/blob/production/public/workers-ai-notebooks/deepseek-coder-exploration.ipynb#_snippet_10

LANGUAGE: python
CODE:
```
model = "@hf/thebloke/deepseek-coder-6.7b-instruct-awq"

# Learn more at https://json-schema.org/
json_schema = """
{
  "title": "User",
  "description": "A user from our example app",
  "type": "object",
  "properties": {
    "firstName": {
      "description": "The user's first name",
      "type": "string"
    },
    "lastName": {
      "description": "The user's last name",
      "type": "string"
    },
    "numKids": {
      "description": "Amount of children the user has currently",
      "type": "integer"
    },
    "interests": {
      "description": "A list of what the user has shown interest in",
      "type": "array",
      "items": {
        "type": "string"
      }
    },
  },
  "required": [ "firstName" ]
}
"""

system_prompt = f"""
The user is going to discuss themselves and you should create a JSON object from their description to match the json schema below. 

<BEGIN JSON SCHEMA>
{json_schema}
<END JSON SCHEMA>

Return JSON only. Do not explain or provide usage examples.
"""

prompt = """Hey there, I'm Craig Dennis and I'm a Developer Educator at Cloudflare. My email is craig@cloudflare.com. 
            I am very interested in AI. I've got two kids. I love tacos, burritos, and all things Cloudflare"""

response = requests.post(
    f"https://api.cloudflare.com/client/v4/accounts/{account_id}/ai/run/{model}",
    headers={"Authorization": f"Bearer {api_token}"},
    json={"messages": [
        {"role": "system", "content": system_prompt},
        {"role": "user", "content": prompt}
    ]}
)
inference = response.json()
response = inference["result"]["response"]
display(Markdown(f"""
```json
{response.strip()}
```
"""))

```

----------------------------------------

TITLE: Accessing Bindings in Top-Level Scope - Cloudflare Workers - JavaScript
DESCRIPTION: This snippet demonstrates how to import `env` from `cloudflare:workers` to access environment variables (`API_KEY`, `LOG_LEVEL`) directly in the top-level scope of a Cloudflare Worker. This allows for initial setup and configuration of resources like an `ApiClient` before any requests are handled, improving code organization and reusability.
SOURCE: https://github.com/cloudflare/cloudflare-docs/blob/production/src/content/changelog/workers/2025-03-17-importable-env.mdx#_snippet_0

LANGUAGE: JavaScript
CODE:
```
import { env } from "cloudflare:workers";
import ApiClient from "example-api-client";

// API_KEY and LOG_LEVEL now usable in top-level scope
const apiClient = ApiClient.new({ apiKey: env.API_KEY });
const LOG_LEVEL = env.LOG_LEVEL || "info";

export default {
	fetch(req) {
		// you can use apiClient or LOG_LEVEL, configured before any request is handled
	},
};
```

----------------------------------------

TITLE: Accessing Bindings in Nested Functions - Cloudflare Workers - JavaScript
DESCRIPTION: This snippet illustrates how to import `env` from `cloudflare:workers` within a helper function (`getValue`) to access bindings (like `KV_PREFIX` and `KV` for KV store operations) without explicitly passing `env` as an argument. This simplifies code in complex codebases by allowing direct access to environment variables and KV namespaces from any part of the application.
SOURCE: https://github.com/cloudflare/cloudflare-docs/blob/production/src/content/changelog/workers/2025-03-17-importable-env.mdx#_snippet_1

LANGUAGE: JavaScript
CODE:
```
// helpers.js
import { env } from "cloudflare:workers";

// env is *not* an argument to this function
export async function getValue(key) {
	let prefix = env.KV_PREFIX;
	return await env.KV.get(`${prefix}-${key}`);
}
```

----------------------------------------

TITLE: Failing Open with passThroughOnException in Cloudflare Workers (JavaScript)
DESCRIPTION: This snippet illustrates the use of `ctx.passThroughOnException()` to configure a Worker to 'fail open'. If an unhandled exception occurs within the Worker's `fetch` handler, the request will be passed through to the origin server instead of the Worker returning an error. This example explicitly throws an error to demonstrate the fail-open behavior.
SOURCE: https://github.com/cloudflare/cloudflare-docs/blob/production/src/content/docs/workers/runtime-apis/context.mdx#_snippet_1

LANGUAGE: JavaScript
CODE:
```
export default {
  async fetch(request, env, ctx) {
    // Proxy to origin on unhandled/uncaught exceptions
    ctx.passThroughOnException();
    throw new Error('Oops');
  }
};
```

----------------------------------------

TITLE: Python: Extracting Data into JSON using DeepSeek Coder and JSON Schema
DESCRIPTION: This example illustrates how to use DeepSeek Coder to extract structured data into a JSON object based on a provided JSON schema. It defines a `json_schema` and constructs a `system_prompt` to instruct the model to return JSON only, adhering to the schema. A user prompt is then sent to the Cloudflare AI endpoint, and the model's JSON response is displayed.
SOURCE: https://github.com/cloudflare/cloudflare-docs/blob/production/public/workers-ai/static/documentation/notebooks/deepseek-coder-exploration.ipynb#_snippet_10

LANGUAGE: python
CODE:
```
model = "@hf/thebloke/deepseek-coder-6.7b-instruct-awq"

# Learn more at https://json-schema.org/
json_schema = """
{
  "title": "User",
  "description": "A user from our example app",
  "type": "object",
  "properties": {
    "firstName": {
      "description": "The user's first name",
      "type": "string"
    },
    "lastName": {
      "description": "The user's last name",
      "type": "string"
    },
    "numKids": {
      "description": "Amount of children the user has currently",
      "type": "integer"
    },
    "interests": {
      "description": "A list of what the user has shown interest in",
      "type": "array",
      "items": {
        "type": "string"
      }
    }
  },
  "required": [ "firstName" ]
}
"""

system_prompt = f"""
The user is going to discuss themselves and you should create a JSON object from their description to match the json schema below. 

<BEGIN JSON SCHEMA>
{json_schema}
<END JSON SCHEMA>

Return JSON only. Do not explain or provide usage examples.
"""

prompt = """Hey there, I'm Craig Dennis and I'm a Developer Educator at Cloudflare. My email is craig@cloudflare.com. 
            I am very interested in AI. I've got two kids. I love tacos, burritos, and all things Cloudflare"""

response = requests.post(
    f"https://api.cloudflare.com/client/v4/accounts/{account_id}/ai/run/{model}",
    headers={"Authorization": f"Bearer {api_token}"},
    json={"messages": [
        {"role": "system", "content": system_prompt},
        {"role": "user", "content": prompt}
    ]}
)
inference = response.json()
response = inference["result"]["response"]
display(Markdown(f"""
```json
{response.strip()}
```
"""))

```

----------------------------------------

TITLE: Scheduling Tasks in Cloudflare AI Agents (TypeScript)
DESCRIPTION: This code demonstrates the scheduling capabilities of Cloudflare AI Agents, allowing tasks to be executed at future times. It illustrates how to schedule tasks using a delay (seconds), a specific Date object, or a cron string, passing custom data to the scheduled function. Scheduled tasks can invoke any regular method on the Agent.
SOURCE: https://github.com/cloudflare/cloudflare-docs/blob/production/src/content/partials/prompts/base-prompt.txt#_snippet_22

LANGUAGE: TypeScript
CODE:
```
  // Scheduling APIs
  // An Agent can schedule tasks to be run in the future by calling this.schedule(when, callback, data), where when can be a delay, a Date, or a cron string; callback the function name to call, and data is an object of data to pass to the function.
  //
  // Scheduled tasks can do anything a request or message from a user can: make requests, query databases, send emails, read+write state: scheduled tasks can invoke any regular method on your Agent.
  async scheduleExamples() {
  	// schedule a task to run in 10 seconds
  	let task = await this.schedule(10, "someTask", { message: "hello" });

  	// schedule a task to run at a specific date
  	let task = await this.schedule(new Date("2025-01-01"), "someTask", {});

  	// schedule a task to run every 10 seconds
  	let { id } = await this.schedule("*/10 * * * *", "someTask", { message: "hello" });
```

----------------------------------------

TITLE: Streaming Workers AI Responses in Agents (TypeScript)
DESCRIPTION: This example illustrates how to call a Workers AI model from an Agent's `onRequest` handler and stream the response back to the client. By setting `stream: true`, the Agent avoids buffering the entire response, which is crucial for larger or reasoning models that require more time to generate a full response.
SOURCE: https://github.com/cloudflare/cloudflare-docs/blob/production/src/content/docs/agents/api-reference/using-ai-models.mdx#_snippet_1

LANGUAGE: TypeScript
CODE:
```
import { Agent } from "agents";

interface Env {
	AI: Ai;
}

export class MyAgent extends Agent<Env> {
	async onRequest(request: Request) {
		const response = await env.AI.run(
			"@cf/deepseek-ai/deepseek-r1-distill-qwen-32b",
			{
				prompt: "Build me a Cloudflare Worker that returns JSON.",
				stream: true, // Stream a response and don't block the client!
			},
		);

		// Return the stream
		return new Response(answer, {
			headers: { "content-type": "text/event-stream" },
		});
	}
}
```

----------------------------------------

TITLE: Performing Playwright Assertions in Cloudflare Worker (TypeScript)
DESCRIPTION: This snippet demonstrates how to use Playwright's `expect()` assertions within a Cloudflare Worker to test a web page. It shows launching a browser, navigating to a URL, interacting with elements (filling and pressing Enter), and then asserting the count and text content of elements. It highlights the integration of `@cloudflare/playwright` for browser automation and testing.
SOURCE: https://github.com/cloudflare/cloudflare-docs/blob/production/src/content/docs/browser-rendering/platform/playwright.mdx#_snippet_3

LANGUAGE: typescript
CODE:
```
import { launch, type BrowserWorker } from "@cloudflare/playwright";
import { expect } from "@cloudflare/playwright/test";

interface Env {
	MYBROWSER: BrowserWorker;
}

export default {
	async fetch(request: Request, env: Env) {
		const browser = await launch(env.MYBROWSER);
		const page = await browser.newPage();

		await page.goto("https://demo.playwright.dev/todomvc");

		const TODO_ITEMS = [
			"buy some cheese",
			"feed the cat",
			"book a doctors appointment"
		];

		const newTodo = page.getByPlaceholder("What needs to be done?");
		for (const item of TODO_ITEMS) {
			await newTodo.fill(item);
			await newTodo.press("Enter");
		}

		await expect(page.getByTestId("todo-title")).toHaveCount(TODO_ITEMS.length);

		await Promise.all(
			TODO_ITEMS.map((value, index) =>
				expect(page.getByTestId("todo-title").nth(index)).toHaveText(value)
			)
		);
	},
};
```

----------------------------------------

TITLE: Developing Cloudflare Worker Locally with Wrangler (CLI)
DESCRIPTION: This command starts a local development server for the Cloudflare Worker, typically accessible at `localhost:8787`. It allows developers to test their Worker and interact with local D1 databases without deploying to production, providing a rapid iteration cycle. This is essential for local debugging and development.
SOURCE: https://github.com/cloudflare/cloudflare-docs/blob/production/src/content/docs/d1/get-started.mdx#_snippet_13

LANGUAGE: sh
CODE:
```
npx wrangler dev
```

----------------------------------------

TITLE: TypeScript Worker: Handle OAuth Callback for Selective Paths
DESCRIPTION: An example TypeScript Worker script designed to handle an OAuth callback for a specific path. It exchanges an authorization code for a token, stores the session, and redirects the user, setting a session cookie. This Worker only executes for the configured selective paths.
SOURCE: https://github.com/cloudflare/cloudflare-docs/blob/production/src/content/docs/workers/static-assets/routing/worker-script.mdx#_snippet_3

LANGUAGE: ts
CODE:
```
import { WorkerEntrypoint } from "cloudflare:workers";

export default class extends WorkerEntrypoint<Env> {
	async fetch(request: Request) {
		// The only thing this Worker script does is handle an OAuth callback.
		// All other requests either serve an asset that matches or serve the index.html fallback, without ever hitting this code.
		const url = new URL(request.url);
		const code = url.searchParams.get("code");
		const state = url.searchParams.get("state");

		const accessToken = await exchangeCodeForToken(code, state);
		const sessionIdentifier = await storeTokenAndGenerateSession(accessToken);

		// Redirect back to the index, but set a cookie that the front-end will use.
		return new Response(null, {
			headers: {
				"Location": "/",
				"Set-Cookie": `session_token=${sessionIdentifier}; HttpOnly; Secure; SameSite=Lax; Path=/`
			}
		});
	}
}
```

----------------------------------------

TITLE: Protecting against Timing Attacks with timingSafeEqual in Python
DESCRIPTION: This snippet shows how to implement timing-safe comparison in a Cloudflare Worker using Python. It utilizes `js.TextEncoder` and `crypto.subtle.timingSafeEqual` to compare an incoming authorization token with a stored secret, ensuring that the comparison time is constant regardless of the input values.
SOURCE: https://github.com/cloudflare/cloudflare-docs/blob/production/src/content/docs/workers/examples/protect-against-timing-attacks.mdx#_snippet_1

LANGUAGE: Python
CODE:
```
from workers import Response
from js import TextEncoder, crypto

async def on_fetch(request, env):
    auth_token = request.headers["Authorization"] or ""
    secret = env.MY_SECRET_VALUE

    if secret is None:
        return Response("Missing secret binding", status=500)

    if len(auth_token) != len(secret):
        return Response("Unauthorized", status=401)

    encoder = TextEncoder.new()
    a = encoder.encode(auth_token)
    b = encoder.encode(secret)

    if a.byteLength != b.byteLength:
        return Response("Unauthorized", status=401)

    if not crypto.subtle.timingSafeEqual(a, b):
        return Response("Unauthorized", status=401)

    return Response("Welcome!")
```

----------------------------------------

TITLE: Handling Incoming HTTP Requests in Cloudflare Workers - JavaScript
DESCRIPTION: This snippet demonstrates a basic Cloudflare Worker `fetch` handler. It shows how the `Request` object is received as a parameter for incoming HTTP requests, allowing the worker to process and respond to them. The example returns a simple 'Hello World!' response.
SOURCE: https://github.com/cloudflare/cloudflare-docs/blob/production/src/content/docs/workers/runtime-apis/request.mdx#_snippet_0

LANGUAGE: JavaScript
CODE:
```
export default {
	async fetch(request, env, ctx) {
		return new Response('Hello World!');
	},
};
```

----------------------------------------

TITLE: Uploading Transformed Image to R2 using Cloudflare Worker (JavaScript)
DESCRIPTION: This Cloudflare Worker handles POST requests to process image uploads. It parses form data to extract the image, fetches a watermark from assets, applies the watermark, converts the image to AVIF format using Cloudflare Images, and finally uploads the transformed image to an R2 bucket with a timestamped filename. It also includes a GET request handler for serving HTML and an `assetUrl` helper function.
SOURCE: https://github.com/cloudflare/cloudflare-docs/blob/production/src/content/docs/images/tutorials/optimize-user-uploaded-image.mdx#_snippet_5

LANGUAGE: JavaScript
CODE:
```
var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });

function assetUrl(request, path) {
	const url = new URL(request.url);
	url.pathname = path;
	return url;
}
__name(assetUrl, "assetUrl");

export default {
  async fetch(request, env) {
    if (request.method === "GET") {
      return new Response(html, {headers:{'Content-Type':'text/html'},})
    }
    if (request.method === "POST") {
      try {
        // Parse form data
        const formData = await request.formData();
        const file = formData.get("image");
        if (!file || typeof file.arrayBuffer !== "function") {
          return new Response("No image file provided", { status: 400 });
        }

        // Read uploaded image as array buffer
        const fileBuffer = await file.arrayBuffer();

	      // Fetch image as watermark
        let watermarkStream = (await env.ASSETS.fetch(assetUrl(request, "watermark.png"))).body;

        // Apply watermark and convert to AVIF
        const imageResponse = (
          await env.IMAGES.input(fileBuffer)
              // Draw the watermark on top of the image
              .draw(
                env.IMAGES.input(watermarkStream)
                  .transform({ width: 100, height: 100 }),
                { bottom: 10, right: 10, opacity: 0.75 }
              )
              // Output the final image as AVIF
              .output({ format: "image/avif" })
          ).response();

          // Add timestamp to file name
          const fileName = `image-${Date.now()}.avif`;

          // Upload to R2
          await env.R2.put(fileName, imageResponse.body)

          return new Response(`Image uploaded successfully as ${fileName}`, { status: 200 });
      } catch (err) {
        console.log(err.message)
      }
    }
  }
}
```

----------------------------------------

TITLE: Default Cloudflare Workers Fetch Handler (JavaScript)
DESCRIPTION: This multi-module Cloudflare Worker demonstrates a basic `fetch` handler. It imports content from `welcome.html`, logs 'Hello Cloudflare Workers!' to the console, and returns an HTML response. The `fetch` handler receives `Request`, `Env`, and `ExecutionContext` parameters, with types defined via JSDoc.
SOURCE: https://github.com/cloudflare/cloudflare-docs/blob/production/src/content/docs/workers/playground.mdx#_snippet_0

LANGUAGE: JavaScript
CODE:
```
import welcome from "welcome.html";

/**
 * @typedef {Object} Env
 */

export default {
	/**
	 * @param {Request} request
	 * @param {Env} env
	 * @param {ExecutionContext} ctx
	 * @returns {Response}
	 */
	fetch(request, env, ctx) {
		console.log("Hello Cloudflare Workers!");

		return new Response(welcome, {
			headers: {
				"content-type": "text/html"
			}
		});
	}
};
```

----------------------------------------

TITLE: Implementing A/B Testing with Cloudflare Workers Middleware in JavaScript
DESCRIPTION: This snippet demonstrates how to set up A/B testing using Cloudflare Workers middleware. It checks for an existing A/B test cookie, redirects users to a new homepage path if they are part of the 'new' test group, or randomly assigns them to 'current' or 'new' versions, setting a cookie accordingly. It leverages `context.env.ASSETS.fetch` to serve static assets and `context.next()` to pass requests through the middleware chain.
SOURCE: https://github.com/cloudflare/cloudflare-docs/blob/production/src/content/docs/pages/functions/examples/ab-testing.mdx#_snippet_0

LANGUAGE: JavaScript
CODE:
```
const cookieName = "ab-test-cookie";
const newHomepagePathName = "/test";

const abTest = async (context) => {
	const url = new URL(context.request.url);
	// if homepage
	if (url.pathname === "/") {
		// if cookie ab-test-cookie=new then change the request to go to /test
		// if no cookie set, pass x% of traffic and set a cookie value to "current" or "new"

		let cookie = request.headers.get("cookie");
		// is cookie set?
		if (cookie && cookie.includes(`${cookieName}=new`)) {
			// pass the request to /test
			url.pathname = newHomepagePathName;
			return context.env.ASSETS.fetch(url);
		} else {
			const percentage = Math.floor(Math.random() * 100);
			let version = "current"; // default version
			// change pathname and version name for 50% of traffic
			if (percentage < 50) {
				url.pathname = newHomepagePathName;
				version = "new";
			}
			// get the static file from ASSETS, and attach a cookie
			const asset = await context.env.ASSETS.fetch(url);
			let response = new Response(asset.body, asset);
			response.headers.append("Set-Cookie", `${cookieName}=${version}; path=/`);
			return response;
		}
	}
	return context.next();
};

export const onRequest = [abTest];
```

----------------------------------------

TITLE: Deploying Cloudflare Application (Shell)
DESCRIPTION: This command deploys the Cloudflare application to the Cloudflare Workers platform. It handles the building, asset uploading, and deployment of the worker and its associated Durable Objects, making the application accessible publicly.
SOURCE: https://github.com/cloudflare/cloudflare-docs/blob/production/src/content/docs/durable-objects/tutorials/build-a-seat-booking-app/index.mdx#_snippet_11

LANGUAGE: sh
CODE:
```
npm run deploy
```

----------------------------------------

TITLE: Wrangler CLI: Initialize New Project
DESCRIPTION: The `wrangler init` command creates a new Cloudflare Workers project using the create-cloudflare-cli (C3) tool. It supports various web frameworks and templates, installs dependencies, and offers an option for immediate deployment. This command is essential for setting up new Worker projects.
SOURCE: https://github.com/cloudflare/cloudflare-docs/blob/production/src/content/docs/workers/wrangler/commands.mdx#_snippet_3

LANGUAGE: txt
CODE:
```
wrangler init [<NAME>] [OPTIONS]
```

LANGUAGE: APIDOC
CODE:
```
Parameters:
  NAME (string, optional): The name of the Workers project. Defaults to the name of the working directory. This name is used for both the directory and the 'name' property in the generated Wrangler configuration.
  --yes (boolean, optional): Answers yes to any prompts for new projects, automating the setup.
  --from-dash (string, optional): Fetches a Worker initialized from the Cloudflare dashboard. Usage: `wrangler init --from-dash <WORKER_NAME>`. Note: This command will not automatically sync changes made to the dashboard after the command is used; therefore, it is recommended that you continue using the CLI.
```

----------------------------------------

TITLE: Conditional Response Handling in Python
DESCRIPTION: This Python Cloudflare Worker snippet illustrates how to implement conditional responses. It checks for blocked hostnames, specific file extensions, and HTTP methods to return different responses or block requests. The snippet uses `re` for regex matching and `urllib.parse` for URL parsing.
SOURCE: https://github.com/cloudflare/cloudflare-docs/blob/production/src/content/docs/workers/examples/conditional-response.mdx#_snippet_2

LANGUAGE: Python
CODE:
```
import re
from workers import Response
from urllib.parse import urlparse

async def on_fetch(request):
    blocked_hostnames = ["nope.mywebsite.com", "bye.website.com"]
    url = urlparse(request.url)

    # Block on hostname
    if url.hostname in blocked_hostnames:
        return Response("Blocked Host", status=403)

    # On paths ending in .doc or .xml
    if re.search(r'\.(doc|xml)$', url.path):
        return Response("Blocked Extension", status=403)

    # On HTTP method
    if "POST" in request.method:
        return Response("Response for POST")

    # On User Agent
```

----------------------------------------

TITLE: Responding to Emails with a Workers AI Model in TypeScript
DESCRIPTION: This Cloudflare Email Worker script demonstrates how to automatically reply to incoming emails using a Workers AI model. It parses the raw incoming email using `postal-mime`, extracts the text content, and sends it to the `@cf/meta/llama-2-7b-chat-fp16` AI model for a response. The generated AI response is then used to construct a new MIME message with `mimetext`, setting appropriate headers like `In-Reply-To`, sender, recipient, and subject, before sending it back as a reply using `message.reply()`. This requires `postal-mime`, `mimetext`, and a Workers AI binding (`env.AI`).
SOURCE: https://github.com/cloudflare/cloudflare-docs/blob/production/src/content/changelog/email-routing/2025-03-12-reply-limits.mdx#_snippet_0

LANGUAGE: typescript
CODE:
```
import PostalMime from "postal-mime";
import {createMimeMessage} from "mimetext"
import { EmailMessage } from "cloudflare:email";

export default {
  async email(message, env, ctx) {
    const email = await PostalMime.parse(message.raw)
    const res = await env.AI.run('@cf/meta/llama-2-7b-chat-fp16', {
      messages: [{
        role: "user",
        content: email.text ?? ''
      }]
    })

    // message-id is generated by mimetext
    const response = createMimeMessage()
    response.setHeader("In-Reply-To", message.headers.get("Message-ID")!);
    response.setSender("agent@example.com");
    response.setRecipient(message.from);
    response.setSubject("Llama response");
    response.addMessage({
      contentType: 'text/plain',
      data: res instanceof ReadableStream ? await new Response(res).text() : res.response!
    })

    const replyMessage = new EmailMessage("<email>", message.from, response.asRaw());
    await message.reply(replyMessage)
  }
} satisfies ExportedHandler<Env>;
```

----------------------------------------

TITLE: Handling Incoming Requests with Fetch in Cloudflare Workers (JavaScript)
DESCRIPTION: This snippet demonstrates the basic structure of a `fetch` handler in a Cloudflare Worker. It shows how the `fetch` function receives an incoming `Request` object and returns a `Response` object, serving as the primary entry point for all HTTP requests to the Worker. The `request`, `env`, and `ctx` parameters provide access to the incoming request details, environment variables, and runtime context respectively.
SOURCE: https://github.com/cloudflare/cloudflare-docs/blob/production/src/content/docs/workers/runtime-apis/handlers/fetch.mdx#_snippet_0

LANGUAGE: JavaScript
CODE:
```
export default {
	async fetch(request, env, ctx) {
		return new Response('Hello World!');
	},
};
```

----------------------------------------

TITLE: Defining Fetch Handler for Request Context in Cloudflare Workers (JavaScript)
DESCRIPTION: This snippet defines the default `fetch` handler for a Cloudflare Worker, demonstrating where the `Request` context begins. It takes `request`, `env`, and `ctx` as parameters and returns a simple `Response` object. This handler is invoked for every incoming HTTP request.
SOURCE: https://github.com/cloudflare/cloudflare-docs/blob/production/src/content/docs/workers/runtime-apis/request.mdx#_snippet_4

LANGUAGE: javascript
CODE:
```
export default {
	async fetch(request, env, ctx) {
        // Request context starts here
		return new Response('Hello World!');
	},
};
```

----------------------------------------

TITLE: Define and Handle Cloudflare Workflow in Worker Entry File
DESCRIPTION: This TypeScript code defines a `MyWorkflow` class extending `WorkflowEntrypoint`, illustrating how to implement a multi-step workflow using `step.do` for actions and `step.sleep` for delays. It also shows the `fetch` handler setup for a React Router application, integrating Cloudflare environment and context for request handling.
SOURCE: https://github.com/cloudflare/cloudflare-docs/blob/production/src/content/docs/workers/framework-guides/web-apps/react-router.mdx#_snippet_5

LANGUAGE: ts
CODE:
```
import { createRequestHandler } from "react-router";
import { WorkflowEntrypoint, WorkflowStep, WorkflowEvent } from 'cloudflare:workers';

declare global {
	interface CloudflareEnvironment extends Env {}
}

type Env = {
	MY_WORKFLOW: Workflow;
};

export class MyWorkflow extends WorkflowEntrypoint<Env> {
	override async run(event: WorkflowEvent<Params>, step: WorkflowStep) {
		await step.do("first step", async () => {
			return { output: "First step result" };
		});

		await step.sleep("sleep", "1 second");

		await step.do("second step", async () => {
			return { output: "Second step result" };
		});

		return "Workflow output";
	}
}

const requestHandler = createRequestHandler(
	() => import("virtual:react-router/server-build"),
	import.meta.env.MODE
);

export default {
	async fetch(request, env, ctx) {
		return requestHandler(request, {
			cloudflare: { env, ctx },
		});
	},
} satisfies ExportedHandler<CloudflareEnvironment>;
```

----------------------------------------

TITLE: Creating REST API Endpoints for Interview Management with Hono in TypeScript
DESCRIPTION: This TypeScript code defines REST API endpoints using the Hono framework for managing interview sessions. It includes helper functions for retrieving Durable Object instances and validating input, along with routes for creating new interviews (`POST /`) and fetching all interviews (`GET /`). Authentication middleware is applied to protect these routes.
SOURCE: https://github.com/cloudflare/cloudflare-docs/blob/production/src/content/docs/workers-ai/guides/tutorials/build-ai-interview-practice-tool.mdx#_snippet_15

LANGUAGE: TypeScript
CODE:
```
import { Hono } from "hono";
import { BadRequestError } from "../errors";
import {
	InterviewInput,
	ApiContext,
	HonoCtx,
	InterviewTitle,
	InterviewSkill,
} from "../types";
import { requireAuth } from "../middleware/auth";

/**
 * Gets the Interview Durable Object instance for a given user.
 * We use the username as a stable identifier to ensure each user
 * gets their own dedicated DO instance that persists across requests.
 */
const getInterviewDO = (ctx: HonoCtx) => {
	const username = ctx.get("username");
	const id = ctx.env.INTERVIEW.idFromName(username);
	return ctx.env.INTERVIEW.get(id);
};

/**
 * Validates the interview creation payload.
 * Makes sure we have all required fields in the correct format:
 * - title must be present
 * - skills must be a non-empty array
 * Throws an error if validation fails.
 */
const validateInterviewInput = (input: InterviewInput) => {
	if (
		!input.title ||
		!input.skills ||
		!Array.isArray(input.skills) ||
		input.skills.length === 0
	) {
		throw new BadRequestError("Invalid input");
	}
};

/**
 * GET /interviews
 * Retrieves all interviews for the authenticated user.
 * The interviews are stored and managed by the user's DO instance.
 */
const getAllInterviews = async (ctx: HonoCtx) => {
	const interviewDO = getInterviewDO(ctx);
	const interviews = await interviewDO.getAllInterviews();
	return ctx.json(interviews);
};

/**
 * POST /interviews
 * Creates a new interview session with the specified title and skills.
 * Each interview gets a unique ID that can be used to reference it later.
 * Returns the newly created interview ID on success.
 */
const createInterview = async (ctx: HonoCtx) => {
	const body = await ctx.req.json<InterviewInput>();
	validateInterviewInput(body);

	const interviewDO = getInterviewDO(ctx);
	const interviewId = await interviewDO.createInterview(
		body.title as InterviewTitle,
		body.skills as InterviewSkill[],
	);

	return ctx.json({ success: true, interviewId });
};

/**
 * Sets up all interview-related routes.
 * Currently supports:
 * - GET / : List all interviews
 * - POST / : Create a new interview
 */
export const configureInterviewRoutes = () => {
	const router = new Hono<ApiContext>();
	router.use("*", requireAuth);
	router.get("/", getAllInterviews);
	router.post("/", createInterview);
	return router;
};
```

----------------------------------------

TITLE: Verifying Cloudflare Access JWTs in JavaScript (Express)
DESCRIPTION: This JavaScript Express example illustrates how to verify Cloudflare Access JWTs using the `jose` library. It initializes a remote JWKS (JSON Web Key Set) from the Access certs URL and provides an asynchronous `verifyToken` middleware. This middleware extracts the JWT from the `Cf-Access-Jwt-Assertion` header, then uses `jose.jwtVerify` to validate the token's signature, issuer, and audience against the fetched public keys, returning a 403 status if the token is missing or invalid.
SOURCE: https://github.com/cloudflare/cloudflare-docs/blob/production/src/content/docs/cloudflare-one/identity/authorization-cookie/validating-json.mdx#_snippet_3

LANGUAGE: javascript
CODE:
```
const express = require("express");
const jose = require("jose");

// The Application Audience (AUD) tag for your application
const AUD = process.env.POLICY_AUD;

// Your CF Access team domain
const TEAM_DOMAIN = process.env.TEAM_DOMAIN;
const CERTS_URL = `${TEAM_DOMAIN}/cdn-cgi/access/certs`;

const JWKS = jose.createRemoteJWKSet(new URL(CERTS_URL));

// verifyToken is a middleware to verify a CF authorization token
const verifyToken = async (req, res, next) => {
	const token = req.headers["cf-access-jwt-assertion"];

	// Make sure that the incoming request has our token header
	if (!token) {
		return res.status(403).send({
			status: false,
			message: "missing required cf authorization token",
		});
	}

	const result = await jose.jwtVerify(token, JWKS, {
		issuer: TEAM_DOMAIN,
		audience: AUD,
	});

	req.user = result.payload;
	next();
};

const app = express();

app.use(verifyToken);

app.get("/", (req, res) => {
	res.send("Hello World!");
});

app.listen(3333);
```

----------------------------------------

TITLE: Setting CORS Headers with Cloudflare Workers (JavaScript)
DESCRIPTION: This snippet defines and applies Cross-Origin Resource Sharing (CORS) headers to responses, and handles preflight `OPTIONS` requests. It ensures that web applications can make cross-origin requests to the Worker by setting appropriate `Access-Control-*` headers.
SOURCE: https://github.com/cloudflare/cloudflare-docs/blob/production/src/content/docs/rules/snippets/when-to-use.mdx#_snippet_7

LANGUAGE: JavaScript
CODE:
```
const corsHeaders = {
	"Access-Control-Allow-Origin": "*", // Replace * with your allowed origin(s)
	"Access-Control-Allow-Methods": "GET, POST, PUT, DELETE, OPTIONS", // Adjust allowed methods as needed
	"Access-Control-Allow-Headers": "Content-Type, Authorization", // Adjust allowed headers as needed
	"Access-Control-Max-Age": "86400", // Adjust max age (in seconds) as needed
};

export default {
	async fetch(request) {
		// Make a copy of the request to modify its headers
		const modifiedRequest = new Request(request);

		// Handle preflight requests (OPTIONS)
		if (request.method === "OPTIONS") {
			return new Response(null, {
				headers: {
					...corsHeaders,
				},
				status: 200, // Respond with OK status for preflight requests
			});
		}

		// Pass the modified request through to the origin
		const response = await fetch(modifiedRequest);

		// Make a copy of the response to modify its headers
		const modifiedResponse = new Response(response.body, response);

		// Set CORS headers on the response
		Object.keys(corsHeaders).forEach((header) => {
			modifiedResponse.headers.set(header, corsHeaders[header]);
		});

		return modifiedResponse;
	},
};
```