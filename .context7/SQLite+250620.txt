TITLE: SELECT Statement Syntax (select-stmt)
DESCRIPTION: Provides the comprehensive syntax for the SELECT statement, including common table expressions (CTEs), result columns, FROM clause with joins, WHERE, GROUP BY, HAVING, WINDOW clauses, VALUES, compound operators, ORDER BY, and LIMIT/OFFSET.
SOURCE: https://www.sqlite.org/docs.html/lang_createtable

LANGUAGE: APIDOC
CODE:
```
[WITH [RECURSIVE] common-table-expression [,
]]
SELECT [DISTINCT | ALL] result-column [,
]
FROM table-or-subquery [join-clause [,
]]
[WHERE expr]
[GROUP BY expr [,
]]
[HAVING expr]
[WINDOW window-name AS window-defn [,
]]
| VALUES (
	expr
	[,
	]
)
[,
]
[compound-operator select-core]
[ORDER BY ordering-term [,
]]
[LIMIT expr [OFFSET expr | ,
expr]]
```

----------------------------------------

TITLE: select-stmt: SQL SELECT Statement Syntax
DESCRIPTION: Defines the comprehensive syntax for the SQL SELECT statement, including common table expressions, DISTINCT/ALL, result columns, FROM clause with joins, WHERE, GROUP BY, HAVING, WINDOW clauses, VALUES, compound operators (UNION, INTERSECT, EXCEPT), ORDER BY, LIMIT, and OFFSET.
SOURCE: https://www.sqlite.org/docs.html/lang_createtrigger

LANGUAGE: APIDOC
CODE:
```
WITH RECURSIVE common-table-expression , SELECT DISTINCT result-column , ALL FROM table-or-subquery join-clause , WHERE expr GROUP BY expr HAVING expr , WINDOW window-name AS window-defn , VALUES ( expr ) , , compound-operator select-core ORDER BY LIMIT expr ordering-term , OFFSET expr , expr
```

----------------------------------------

TITLE: SQLite Transaction Control Commands
DESCRIPTION: These SQL commands are fundamental for managing transactions in SQLite. BEGIN starts a transaction, SELECT reads data, UPDATE modifies data, COMMIT finalizes changes, ROLLBACK discards changes, and BEGIN IMMEDIATE starts a transaction that immediately acquires a write lock.
SOURCE: https://www.sqlite.org/docs.html/isolation

LANGUAGE: SQL
CODE:
```
BEGIN
SELECT
UPDATE
COMMIT
ROLLBACK
BEGIN IMMEDIATE
```

----------------------------------------

TITLE: SQLITE_BUSY Result Code
DESCRIPTION: The SQLITE_BUSY result code indicates that the database file could not be written (or in some cases read) because of concurrent activity by some other database connection, usually a database connection in a separate process. For example, if process A is in the middle of a large write transaction and at the same time process B attempts to start a new write transaction, process B will get back an SQLITE_BUSY result because SQLite only supports one writer at a time. Process B will need to wait for process A to finish its transaction before starting a new transaction. The sqlite3_busy_timeout() and sqlite3_busy_handler() interfaces and the busy_timeout pragma are available to process B to help it deal with SQLITE_BUSY errors. An SQLITE_BUSY error can occur at any point in a transaction: when the transaction is first started, during any write or update operations, or when the transaction commits. To avoid encountering SQLITE_BUSY errors in the middle of a transaction, the application can use BEGIN IMMEDIATE instead of just BEGIN to start a transaction. The BEGIN IMMEDIATE command might itself return SQLITE_BUSY, but if it succeeds, then SQLite guarantees that no subsequent operations on the same database through the next COMMIT will return SQLITE_BUSY. The SQLITE_BUSY result code differs from SQLITE_LOCKED in that SQLITE_BUSY indicates a conflict with a separate database connection, probably in a separate process, whereas SQLITE_LOCKED indicates a conflict within the same database connection (or sometimes a database connection with a shared cache).
SOURCE: https://www.sqlite.org/docs.html/rescode

LANGUAGE: APIDOC
CODE:
```
SQLITE_BUSY (5)
  Description: Database file busy due to concurrent activity from another database connection (separate process).
  Resolution: Use sqlite3_busy_timeout(), sqlite3_busy_handler(), busy_timeout pragma, or BEGIN IMMEDIATE.
  Distinction: Differs from SQLITE_LOCKED (conflict within same connection).
```

----------------------------------------

TITLE: SQLite Column Value Retrieval and Information Functions
DESCRIPTION: A family of SQLite C API functions designed to retrieve values from a result set column in various data types (BLOB, bytes, double, int, int64, text) or to obtain metadata such as the number of columns or the column's data type.
SOURCE: https://www.sqlite.org/docs.html/cintro

LANGUAGE: APIDOC
CODE:
```
sqlite3_column_blob()
sqlite3_column_bytes()
sqlite3_column_bytes16()
sqlite3_column_count()
sqlite3_column_double()
sqlite3_column_int()
sqlite3_column_int64()
sqlite3_column_text()
sqlite3_column_text16()
sqlite3_column_type()
sqlite3_column_value()
```

----------------------------------------

TITLE: SQLite UPSERT: Incrementing a Counter on Conflict
DESCRIPTION: This example demonstrates how to use UPSERT to either insert a new vocabulary word or, if the word already exists (due to a PRIMARY KEY conflict on 'word'), increment its associated 'count' by one. The 'count+1' expression refers to the original value of 'count' before the attempted insert.
SOURCE: https://www.sqlite.org/docs.html/lang_upsert

LANGUAGE: SQL
CODE:
```
CREATE TABLE vocabulary(word TEXT PRIMARY KEY, count INT DEFAULT 1);
INSERT INTO vocabulary(word) VALUES('jovial')
  ON CONFLICT(word) DO UPDATE SET count=count+1;
```

----------------------------------------

TITLE: SQLite Result Column Syntax
DESCRIPTION: Defines the syntax for specifying columns in a SELECT statement's result set, including expressions, aliases, and wildcard selections.
SOURCE: https://www.sqlite.org/docs.html/lang_select

LANGUAGE: APIDOC
CODE:
```
expr AS column-alias * table-name . *
```

----------------------------------------

TITLE: Disable Untrusted Schema Execution with sqlite3_db_config
DESCRIPTION: To prevent malicious database schemas from executing custom SQL functions or virtual tables, invoke this C API call immediately upon opening each database connection. This sets the SQLITE_DBCONFIG_TRUSTED_SCHEMA flag to 0, disabling the surreptitious use of untrusted schema elements.
SOURCE: https://www.sqlite.org/docs.html/security

LANGUAGE: C
CODE:
```
sqlite3_db_config(db,SQLITE_DBCONFIG_TRUSTED_SCHEMA,0,0);
```

----------------------------------------

TITLE: C Function for Incremental Online SQLite Database Backup
DESCRIPTION: The `backupDb` C function facilitates an online backup of a SQLite database (`pDb`) to a specified file (`zFilename`). It initializes a backup object, then iteratively copies 5 database pages per step. After each step, it invokes a progress function (`xProgress`) with the remaining and total page counts, and then sleeps for 250 milliseconds if the backup is ongoing or busy. This incremental approach, utilizing `sqlite3_backup_init`, `sqlite3_backup_step`, `sqlite3_sleep`, and `sqlite3_backup_finish`, ensures that the source database remains accessible for other operations throughout the backup process. It returns `SQLITE_OK` on successful completion or an SQLite error code if an issue occurs.
SOURCE: https://www.sqlite.org/docs.html/backup

LANGUAGE: C
CODE:
```
/*
** Perform an online backup of database pDb to the database file named
** by zFilename. This function copies 5 database pages from pDb to
** zFilename, then unlocks pDb and sleeps for 250 ms, then repeats the
** process until the entire database is backed up.
**
** The third argument passed to this function must be a pointer to a progress
** function. After each set of 5 pages is backed up, the progress function
** is invoked with two integer parameters: the number of pages left to
** copy, and the total number of pages in the source file. This information
** may be used, for example, to update a GUI progress bar.
**
** While this function is running, another thread may use the database pDb, or
** another process may access the underlying database file via a separate
** connection.
**
** If the backup process is successfully completed, SQLITE_OK is returned.
** Otherwise, if an error occurs, an SQLite error code is returned.
*/
int backupDb(
  sqlite3 *pDb,               /* Database to back up */
  const char *zFilename,      /* Name of file to back up to */
  void(*xProgress)(int, int)  /* Progress function to invoke */
){
  int rc;                     /* Function return code */
  sqlite3 *pFile;             /* Database connection opened on zFilename */
  sqlite3_backup *pBackup;    /* Backup handle used to copy data */

  /* Open the database file identified by zFilename. */
  rc = sqlite3_open(zFilename, &pFile);
  if( rc==SQLITE_OK ){

    /* Open the sqlite3_backup object used to accomplish the transfer */
    pBackup = sqlite3_backup_init(pFile, "main", pDb, "main");
    if( pBackup ){

      /* Each iteration of this loop copies 5 database pages from database
      ** pDb to the backup database. If the return value of backup_step()
      ** indicates that there are still further pages to copy, sleep for
      ** 250 ms before repeating. */
      do {
        rc = sqlite3_backup_step(pBackup, 5);
        xProgress(
            sqlite3_backup_remaining(pBackup),
            sqlite3_backup_pagecount(pBackup)
        );
        if( rc==SQLITE_OK || rc==SQLITE_BUSY || rc==SQLITE_LOCKED ){
          sqlite3_sleep(250);
        }
      } while( rc==SQLITE_OK || rc==SQLITE_BUSY || rc==SQLITE_LOCKED );

      /* Release resources allocated by backup_init(). */
      (void)sqlite3_backup_finish(pBackup);
    }
    rc = sqlite3_errcode(pFile);
  }

  /* Close the database connection opened on database file zFilename
  ** and return the result of this function. */
  (void)sqlite3_close(pFile);
  return rc;
}
```

----------------------------------------

TITLE: SQL SELECT Statement Core Syntax Definition
DESCRIPTION: Formal definition of the SQLite SELECT statement's core structure. This includes the projection (result-column), source (FROM table-or-subquery, join-clause), filtering (WHERE), aggregation (GROUP BY, HAVING), and advanced features like WINDOW and VALUES clauses. This core syntax is used by compound-select-stmt, factored-select-stmt, and simple-select-stmt, and references expr, join-clause, result-column, table-or-subquery, and window-defn.
SOURCE: https://www.sqlite.org/docs.html/syntax/select-core

LANGUAGE: APIDOC
CODE:
```
SELECT [DISTINCT | ALL] result-column [, result-column, ...]
FROM table-or-subquery [join-clause] [, table-or-subquery [join-clause], ...]
[WHERE expr]
[GROUP BY expr [, expr, ...]]
[HAVING expr]
[WINDOW window-name AS window-defn [, window-name AS window-defn, ...]]
[VALUES (expr [, expr, ...]) [, (expr [, expr, ...]), ...]]
```

----------------------------------------

TITLE: SQLite Prepared Statement Object Lifecycle (APIDOC)
DESCRIPTION: This section outlines the typical sequence of operations for managing a `sqlite3_stmt` object. It covers creation, parameter binding, execution, optional resetting for re-execution, and final destruction, illustrating the flow of SQL statement processing.
SOURCE: https://www.sqlite.org/docs.html/c3ref/stmt

LANGUAGE: APIDOC
CODE:
```
1. Create the prepared statement object using sqlite3_prepare_v2().
2. Bind values to parameters using the sqlite3_bind_*() interfaces.
3. Run the SQL by calling sqlite3_step() one or more times.
4. Reset the prepared statement using sqlite3_reset() then go back to step 2. Do this zero or more times.
5. Destroy the object using sqlite3_finalize().
```

----------------------------------------

TITLE: SQLite C API: sqlite3_open() Function
DESCRIPTION: The `sqlite3_open()` function is the primary C interface for opening a SQLite database connection. In multi-file transactions, it identifies the main database file, distinct from any attached auxiliary databases.
SOURCE: https://www.sqlite.org/docs.html/atomiccommit

LANGUAGE: C
CODE:
```
int sqlite3_open(const char *filename, sqlite3 **ppDb);
```

----------------------------------------

TITLE: SQLite SQL Language Features Overview
DESCRIPTION: Lists the various SQL commands, functions, and clauses supported by SQLite, providing a comprehensive overview of its SQL dialect capabilities.
SOURCE: https://www.sqlite.org/docs.html/lang

LANGUAGE: APIDOC
CODE:
```
- aggregate functions
- ALTER TABLE
- ANALYZE
- ATTACH DATABASE
- BEGIN TRANSACTION
- comment
- COMMIT TRANSACTION
- core functions
- CREATE INDEX
- CREATE TABLE
- CREATE TRIGGER
- CREATE VIEW
- CREATE VIRTUAL TABLE
- date and time functions
- DELETE
- DETACH DATABASE
- DROP INDEX
- DROP TABLE
- DROP TRIGGER
- DROP VIEW
- END TRANSACTION
- EXPLAIN
- expression
- INDEXED BY
- INSERT
- JSON functions
- keywords
- math functions
- ON CONFLICT clause
- PRAGMA
- REINDEX
- RELEASE SAVEPOINT
- REPLACE
- RETURNING clause
- ROLLBACK TRANSACTION
- SAVEPOINT
- SELECT
- UPDATE
- UPSERT
- VACUUM
- window functions
- WITH clause
```

----------------------------------------

TITLE: SQL: Example UPDATE Statement
DESCRIPTION: This SQL UPDATE statement modifies the 'one' column of records in the 'examp' table by enclosing its current value in parentheses, specifically for rows where the 'two' column's value is less than 50.
SOURCE: https://www.sqlite.org/docs.html/vdbe

LANGUAGE: SQL
CODE:
```
UPDATE examp SET one= '(' || one || ')' WHERE two < 50;
```

----------------------------------------

TITLE: SQLite Syntax: join-constraint
DESCRIPTION: Specifies the conditions or columns used to establish a join between tables.
SOURCE: https://www.sqlite.org/docs.html/lang_select

LANGUAGE: APIDOC
CODE:
```
join-constraint:
  USING ( column-name )
  ON expr
```

----------------------------------------

TITLE: SQLite Prepared Statement Management and Parameter Binding
DESCRIPTION: Details the core routines for managing and reusing SQLite prepared statements, including resetting them for re-evaluation and binding parameters to allow for dynamic values. Emphasizes performance benefits of reuse by avoiding repeated calls to sqlite3_prepare().
SOURCE: https://www.sqlite.org/docs.html/cintro

LANGUAGE: APIDOC
CODE:
```
API Routines for Prepared Statements:
  sqlite3_reset():
    Purpose: Rewinds a prepared statement to its beginning for re-evaluation.
    Usage: Call after sqlite3_step() to reuse the statement.
    Benefit: Avoids repeated calls to sqlite3_prepare(), improving performance.

  sqlite3_bind():
    Purpose: Attaches values to parameters within a prepared statement.
    Usage: Call prior to sqlite3_step() for the first time or immediately after sqlite3_reset().
    Behavior: Overrides prior bindings on the same parameter.

  sqlite3_step():
    Purpose: Evaluates a prepared SQL statement.

  sqlite3_prepare():
    Purpose: Compiles an SQL statement into a prepared statement.
    Note: Time needed to run often equals or exceeds sqlite3_step(); reusing prepared statements avoids this call.

SQL Statement Parameters:
  Purpose: Allow dynamic values in SQL statements (DQL or DML).
  Allowed Locations: Wherever a string literal, blob literal, numeric constant, or NULL is allowed.
  Disallowed Locations: Column or table names, values for constraints or default values (DDL).
  Initial Value: NULL.
  Forms:
    - ?: Unnamed parameter.
    - ?NNN: Numbered parameter (NNN is an integer value).
    - :AAA: Named parameter (AAA is an identifier).
    - $AAA: Named parameter (AAA is an identifier).
    - @AAA: Named parameter (AAA is an identifier).
```

----------------------------------------

TITLE: SQLite Primary Result Codes Reference
DESCRIPTION: This snippet provides a complete list of the primary result codes used by SQLite, along with their integer values. These codes indicate the outcome of SQLite API calls, such as success, errors, or specific states like busy or locked. They are defined in `sqlite3.h` and are crucial for error handling and status checking in SQLite applications.
SOURCE: https://www.sqlite.org/docs.html/rescode

LANGUAGE: APIDOC
CODE:
```
SQLite Primary Result Codes:
SQLITE_ABORT (4)
SQLITE_AUTH (23)
SQLITE_BUSY (5)
SQLITE_CANTOPEN (14)
SQLITE_CONSTRAINT (19)
SQLITE_CORRUPT (11)
SQLITE_DONE (101)
SQLITE_EMPTY (16)
SQLITE_ERROR (1)
SQLITE_FORMAT (24)
SQLITE_FULL (13)
SQLITE_INTERNAL (2)
SQLITE_INTERRUPT (9)
SQLITE_IOERR (10)
SQLITE_LOCKED (6)
SQLITE_MISMATCH (20)
SQLITE_MISUSE (21)
SQLITE_NOLFS (22)
SQLITE_NOMEM (7)
SQLITE_NOTADB (26)
SQLITE_NOTFOUND (12)
SQLITE_NOTICE (27)
SQLITE_OK (0)
SQLITE_PERM (3)
SQLITE_PROTOCOL (15)
SQLITE_RANGE (25)
SQLITE_READONLY (8)
SQLITE_ROW (100)
SQLITE_SCHEMA (17)
SQLITE_TOOBIG (18)
SQLITE_WARNING (28)
```

----------------------------------------

TITLE: sqlite3_step API Documentation
DESCRIPTION: Detailed API documentation for the `sqlite3_step` function, including its purpose, prerequisites, behavior differences between API versions, and a comprehensive breakdown of its possible return values and their implications.
SOURCE: https://www.sqlite.org/docs.html/capi3ref

LANGUAGE: APIDOC
CODE:
```
sqlite3_step(sqlite3_stmt* stmt)
  Description: Evaluates a prepared SQL statement one or more times.
  Prerequisites:
    - Statement must be prepared using sqlite3_prepare_v2(), sqlite3_prepare_v3(), sqlite3_prepare16_v2(), sqlite3_prepare16_v3(), or legacy sqlite3_prepare(), sqlite3_prepare16().
  Behavior Differences (vX vs. Legacy Interfaces):
    - Newer "vX" interfaces are recommended for new applications.
    - Legacy interfaces are still supported.
  Return Values:
    - SQLITE_BUSY: Database engine unable to acquire necessary locks.
      - If COMMIT or outside explicit transaction: Can retry statement.
      - If not COMMIT and within explicit transaction: Rollback transaction before continuing.
    - SQLITE_DONE: Statement finished executing successfully.
      - Must call sqlite3_reset() to reset the virtual machine before calling sqlite3_step() again.
    - SQLITE_ROW: A new row of data is ready for processing.
      - Values can be accessed using column access functions.
      - Call sqlite3_step() again to retrieve the next row.
    - SQLITE_ERROR: A run-time error (e.g., constraint violation) has occurred.
      - Do not call sqlite3_step() again on the VM.
      - More information via sqlite3_errmsg().
      - Legacy Interface: Call sqlite3_reset() for specific error code (e.g., SQLITE_INTERRUPT, SQLITE_SCHEMA, SQLITE_CORRUPT).
      - "v2" Interface: Specific error code returned directly by sqlite3_step().
    - SQLITE_MISUSE: Routine called inappropriately.
      - Examples: Called on a finalized statement, on a statement that previously returned SQLITE_ERROR or SQLITE_DONE, or concurrent multi-thread use on the same database connection.
  Automatic Reset (Post SQLite 3.6.23.1):
    - sqlite3_step() automatically calls sqlite3_reset() if it returns anything other than SQLITE_ROW.
    - This prevents SQLITE_MISUSE errors that would have occurred in older versions.
    - The SQLITE_OMIT_AUTORESET compile-time option can restore the legacy behavior.
  Legacy Interface Note ("Goofy Interface Alert"):
    - Always returns generic SQLITE_ERROR for most errors (except SQLITE_BUSY and SQLITE_MISUSE).
    - Requires calling sqlite3_reset() or sqlite3_finalize() to find specific error codes.
    - This design flaw has been fixed with the "v2" interface.
```

----------------------------------------

TITLE: CREATE TABLE Statement Syntax (create-table-stmt)
DESCRIPTION: Defines the syntax for creating a new table in SQLite. It includes options for temporary tables, conditional creation, schema and table naming, column definitions, table constraints, and creating a table from a SELECT statement.
SOURCE: https://www.sqlite.org/docs.html/lang_createtable

LANGUAGE: APIDOC
CODE:
```
CREATE [TEMP | TEMPORARY] TABLE [IF NOT EXISTS] schema-name . table-name (
	column-def
	| table-constraint
	[,
	]
)
[table-options]
[,
AS select-stmt]
```

----------------------------------------

TITLE: SQLite C API: sqlite3_step Function Documentation
DESCRIPTION: Detailed documentation for the `sqlite3_step` function, explaining its behavior, return values, and interaction with prepared statements in SQLite. It covers the differences between legacy and 'vX' interfaces and the implications of various return codes.
SOURCE: https://www.sqlite.org/docs.html/c3ref/step

LANGUAGE: APIDOC
CODE:
```
sqlite3_step(sqlite3_stmt*):
  Purpose: Evaluates a prepared SQL statement one or more times.
  Parameters:
    sqlite3_stmt*: A pointer to the prepared statement.
  Usage:
    - Must be called after a statement is prepared using sqlite3_prepare_v2/v3, sqlite3_prepare16_v2/v3, or legacy interfaces.
    - Call repeatedly to retrieve multiple rows of data.
    - Do not call again on a virtual machine after SQLITE_DONE or SQLITE_ERROR without first calling sqlite3_reset().
  Return Values:
    - SQLITE_BUSY: Database engine unable to acquire locks.
      - If COMMIT or outside explicit transaction: can retry.
      - If not COMMIT and within explicit transaction: rollback transaction before continuing.
    - SQLITE_DONE: Statement finished executing successfully. Requires sqlite3_reset() before re-use.
    - SQLITE_ROW: A new row of data is ready for processing. Access values using column access functions. Call sqlite3_step() again for next row.
    - SQLITE_ERROR: A run-time error (e.g., constraint violation) occurred. Do not call again on VM. More info via sqlite3_errmsg().
      - Legacy interface: Specific error code via sqlite3_reset().
      - v2 interface: Specific error code returned directly.
    - SQLITE_MISUSE: Routine called inappropriately (e.g., on finalized statement, after SQLITE_ERROR/DONE, or concurrent thread usage).
  Behavior Differences (Legacy vs. "vX" Interfaces):
    - Recommended: "vX" interfaces (sqlite3_prepare_v2/v3, sqlite3_prepare16_v2/v3).
    - Legacy interface: Returns generic SQLITE_ERROR for most errors.
    - v2 interface: Can return any other result codes or extended result codes directly.
  Automatic Reset (Post-SQLite 3.6.23.1):
    - After version 3.6.23.1 (2010-03-26), sqlite3_step() automatically calls sqlite3_reset() when returning anything other than SQLITE_ROW, instead of SQLITE_MISUSE.
    - SQLITE_OMIT_AUTORESET compile-time option can restore legacy behavior.
```

----------------------------------------

TITLE: SQL Expression Syntax
DESCRIPTION: Describes the general syntax for SQL expressions, encompassing literal values, bind parameters, column references, unary and binary operators, function calls, subqueries, CAST operations, COLLATE clauses, LIKE/GLOB/REGEXP/MATCH/ESCAPE predicates, NULL checks, IS DISTINCT FROM, BETWEEN, IN, EXISTS, CASE statements, and the RAISE function.
SOURCE: https://www.sqlite.org/docs.html/lang_createindex

LANGUAGE: APIDOC
CODE:
```
literal-value bind-parameter schema-name . table-name . column-name unary-operator expr expr binary-operator expr function-name ( function-arguments ) filter-clause over-clause ( expr ) , CAST ( expr AS type-name ) expr COLLATE collation-name expr NOT LIKE GLOB REGEXP MATCH expr expr ESCAPE expr expr ISNULL NOTNULL NOT NULL expr IS NOT DISTINCT FROM expr expr NOT BETWEEN expr AND expr expr NOT IN ( select-stmt ) expr , schema-name . table-function ( expr ) table-name , NOT EXISTS ( select-stmt ) CASE expr WHEN expr THEN expr ELSE expr END raise-function
```

----------------------------------------

TITLE: SQLite Syntax: join-clause
DESCRIPTION: Defines the syntax for combining two or more tables or subqueries in a SELECT statement.
SOURCE: https://www.sqlite.org/docs.html/lang_select

LANGUAGE: APIDOC
CODE:
```
join-clause:
  table-or-subquery
  join-operator
  table-or-subquery
  join-constraint
```

----------------------------------------

TITLE: SQLite Expression (expr) Syntax Definition
DESCRIPTION: Defines the complete syntax for expressions in SQLite, detailing the various forms an expression can take. This includes basic values, operations, function invocations, and complex conditional or subquery-based constructs. This syntax is fundamental to many SQLite statements, as indicated by its extensive 'Used by' list.
SOURCE: https://www.sqlite.org/docs.html/syntax/expr

LANGUAGE: APIDOC
CODE:
```
expr :=
  literal-value
| bind-parameter
| schema-name . table-name . column-name
| unary-operator expr
| expr binary-operator expr
| function-name ( function-arguments ) filter-clause over-clause
| ( expr )
| CAST ( expr AS type-name )
| expr COLLATE collation-name
| expr [NOT] ( LIKE | GLOB | REGEXP | MATCH ) expr [ESCAPE expr]
| expr ( ISNULL | NOTNULL | NOT NULL )
| expr IS [NOT] DISTINCT FROM expr
| expr [NOT] BETWEEN expr AND expr
| expr [NOT] IN ( select-stmt )
| expr , schema-name . table-function ( expr ) table-name
| [NOT] EXISTS ( select-stmt )
| CASE expr WHEN expr THEN expr [ELSE expr] END
| raise-function
```

----------------------------------------

TITLE: Optimizing SQLite INSERT Performance with Transactions (SQL)
DESCRIPTION: Demonstrates how to significantly improve the speed of multiple INSERT statements by wrapping them within a single transaction using BEGIN and COMMIT. This amortizes the disk I/O overhead associated with each individual transaction, which is typically limited by disk rotational speed.
SOURCE: https://www.sqlite.org/docs.html/faq

LANGUAGE: SQL
CODE:
```
BEGIN;
INSERT INTO my_table (col1, col2) VALUES ('value1', 'value2');
INSERT INTO my_table (col1, col2) VALUES ('value3', 'value4');
-- ... many more INSERT statements ...
COMMIT;
```

----------------------------------------

TITLE: SQLite SELECT Core Statement Syntax Definition
DESCRIPTION: Defines the fundamental components of a SELECT statement in SQLite, excluding compound operators, ORDER BY, and LIMIT clauses. It specifies elements like DISTINCT, result columns, FROM clause, WHERE, GROUP BY, HAVING, and WINDOW clauses. This core definition is used by various higher-level select statement types and references other grammar components such as expressions and join clauses.
SOURCE: https://www.sqlite.org/docs.html/syntaxdiagrams

LANGUAGE: APIDOC
CODE:
```
SELECT
DISTINCT
result-column
,
ALL
FROM
table-or-subquery
join-clause
,
WHERE
expr
GROUP
BY
expr
HAVING
expr
,
WINDOW
window-name
AS
window-defn
,
VALUES
(
expr
)
,
,
```

----------------------------------------

TITLE: SQLite COMMIT Transaction Statement Syntax
DESCRIPTION: Defines the syntax for committing the current transaction in SQLite, making all changes permanent and visible to other database connections. The 'END' keyword serves as an alias for 'COMMIT TRANSACTION'.
SOURCE: https://www.sqlite.org/docs.html/lang_transaction

LANGUAGE: APIDOC
CODE:
```
COMMIT
TRANSACTION
END
```

----------------------------------------

TITLE: New Scalar SQL Functions: concat and concat_ws
DESCRIPTION: Documentation for the newly added scalar SQL functions concat() and concat_ws(), providing string concatenation capabilities compatible with other major SQL databases.
SOURCE: https://www.sqlite.org/docs.html/releaselog/3_44_2

LANGUAGE: SQL
CODE:
```
concat(value1, value2, ...)
  Description: Concatenates two or more string values.
  Compatibility: PostgreSQL, SQLServer, MySQL.
```

LANGUAGE: SQL
CODE:
```
concat_ws(separator, value1, value2, ...)
  Description: Concatenates two or more string values with a specified separator.
  Compatibility: PostgreSQL, SQLServer, MySQL.
```

----------------------------------------

TITLE: SQLite Syntax: Select Statement (select-stmt)
DESCRIPTION: Defines the full structure of a SELECT statement, including common table expressions (WITH clause), core select components, compound operators, ORDER BY, LIMIT, and OFFSET clauses.
SOURCE: https://www.sqlite.org/docs.html/lang_select

LANGUAGE: APIDOC
CODE:
```
WITH RECURSIVE common-table-expression , SELECT DISTINCT result-column , ALL FROM table-or-subquery join-clause , WHERE expr GROUP BY expr HAVING expr , WINDOW window-name AS window-defn , VALUES ( expr ) , , compound-operator select-core ORDER BY LIMIT expr ordering-term , OFFSET expr , expr
```

----------------------------------------

TITLE: Applying WHERE Clause Filtering in SQLite Queries
DESCRIPTION: The WHERE clause in SQLite is used to filter rows from the input dataset. For each row, the WHERE expression is evaluated as a boolean. Only rows where the expression evaluates to TRUE are included in the result set. Rows where the WHERE clause evaluates to FALSE or NULL are excluded.
SOURCE: https://www.sqlite.org/docs.html/lang_select

LANGUAGE: APIDOC
CODE:
```
WHERE Clause Filtering:
  Evaluates a boolean expression for each input row.
  Includes rows only if the expression evaluates to TRUE.
  Excludes rows if the expression evaluates to FALSE or NULL.
```

----------------------------------------

TITLE: SQLite API: sqlite3_open()
DESCRIPTION: Opens a connection to an SQLite database file. This routine returns a database connection object and is typically the first SQLite API call made by an application. It serves as the constructor for the database connection object.
SOURCE: https://www.sqlite.org/docs.html/cintro

LANGUAGE: APIDOC
CODE:
```
sqlite3_open(): Open Database Connection
  Purpose: Establishes a connection to an SQLite database file.
  Returns: A pointer to a `sqlite3` database connection object.
  Notes: Conceptual name; actual routines include `sqlite3_open()`, `sqlite3_open16()`, and `sqlite3_open_v2()`.
```

----------------------------------------

TITLE: SQLite SQL Expression (expr) Syntax
DESCRIPTION: Defines the comprehensive syntax for expressions in SQLite, covering literal values, bind parameters, column references, unary and binary operators, function calls, subqueries, CAST operations, COLLATE, LIKE/GLOB/REGEXP/MATCH, ISNULL/NOTNULL/NULL, IS DISTINCT FROM, BETWEEN, IN, EXISTS, CASE statements, and the raise-function.
SOURCE: https://www.sqlite.org/docs.html/lang_returning

LANGUAGE: APIDOC
CODE:
```
literal-value
bind-parameter
schema-name
.
table-name
.
column-name
unary-operator
expr
expr
binary-operator
expr
function-name
(
function-arguments
)
filter-clause
over-clause
(
expr
)
,
CAST
(
expr
AS
type-name
)
expr
COLLATE
collation-name
expr
NOT
LIKE
GLOB
REGEXP
MATCH
expr
expr
ESCAPE
expr
expr
ISNULL
NOTNULL
NOT
NULL
expr
IS
NOT
DISTINCT
FROM
expr
expr
NOT
BETWEEN
expr
AND
expr
expr
NOT
IN
(
select-stmt
)
expr
,
schema-name
.
table-function
(
expr
)
table-name
,
NOT
EXISTS
(
select-stmt
)
CASE
expr
WHEN
expr
THEN
expr
ELSE
expr
END
raise-function
```

----------------------------------------

TITLE: SQLite JOIN Clause Syntax
DESCRIPTION: Specifies the syntax for joining tables or subqueries in SQLite, involving a table-or-subquery, a join-operator, another table-or-subquery, and an optional join-constraint.
SOURCE: https://www.sqlite.org/docs.html/lang_select

LANGUAGE: APIDOC
CODE:
```
table-or-subquery
join-operator
table-or-subquery
join-constraint
```

----------------------------------------

TITLE: SQLite CREATE INDEX Statement Syntax
DESCRIPTION: Defines the complete syntax for creating an index in SQLite. It includes options for creating unique indexes, conditional creation (IF NOT EXISTS), specifying the schema and index name, the target table and indexed columns, and an optional WHERE clause for partial indexes. This statement is a component of `sql-stmt` and utilizes `expr` and `indexed-column`.
SOURCE: https://www.sqlite.org/docs.html/syntax/create-index-stmt

LANGUAGE: SQL
CODE:
```
CREATE [ UNIQUE ] INDEX [ IF NOT EXISTS ] [ schema-name . ] index-name ON table-name ( indexed-column [ , indexed-column ]* ) [ WHERE expr ]
```

----------------------------------------

TITLE: SQLite Syntax: select-stmt
DESCRIPTION: Defines the comprehensive syntax for a SELECT statement in SQLite, including WITH RECURSIVE, DISTINCT/ALL, FROM, JOIN, WHERE, GROUP BY, HAVING, WINDOW, VALUES, compound operators, ORDER BY, LIMIT, and OFFSET clauses.
SOURCE: https://www.sqlite.org/docs.html/lang_aggfunc

LANGUAGE: APIDOC
CODE:
```
WITH
RECURSIVE
common-table-expression
,
SELECT
DISTINCT
result-column
,
ALL
FROM
table-or-subquery
join-clause
,
WHERE
expr
GROUP
BY
expr
HAVING
expr
,
WINDOW
window-name
AS
window-defn
,
VALUES
(
expr
)
,
,
compound-operator
select-core
ORDER
BY
LIMIT
expr
ordering-term
,
OFFSET
expr
,
expr
```

----------------------------------------

TITLE: Discouragement and Alternatives for SQLite Shared-Cache Mode
DESCRIPTION: States that shared-cache mode is an obsolete and discouraged feature, with most use cases better served by WAL mode (introduced circa 2010). WAL mode permits simultaneous access without breaking transaction isolation, addressing issues shared-cache aimed to solve. It also recommends using the -DSQLITE_OMIT_SHARED_CACHE compile-time option for smaller and faster binaries.
SOURCE: https://www.sqlite.org/docs.html/sharedcache

LANGUAGE: APIDOC
CODE:
```
Use of shared-cache is discouraged:
  - Obsolete feature.
  - Most use cases better served by WAL mode (circa 2010).
  - WAL mode permits simultaneous access without breaking transaction isolation.
  - Recommendation: Compile SQLite with -DSQLITE_OMIT_SHARED_CACHE option for smaller and faster binaries.
  - Shared-cache interfaces will continue to be supported for backwards compatibility, but use is discouraged.
```

----------------------------------------

TITLE: Speeding Up SQLite Writes with PRAGMA synchronous=OFF (SQL)
DESCRIPTION: Explains the use of PRAGMA synchronous=OFF to increase write operation speed by instructing SQLite not to wait for data to be physically written to disk. While this boosts performance, it carries a risk of database corruption if power is lost or the OS crashes during a transaction.
SOURCE: https://www.sqlite.org/docs.html/faq

LANGUAGE: SQL
CODE:
```
PRAGMA synchronous=OFF;
```

----------------------------------------

TITLE: SQLite Column Constraint Syntax Definition
DESCRIPTION: Defines the various keywords and clauses that can be used to specify column constraints in SQLite table creation or alteration statements. This includes primary keys, unique constraints, nullability, default values, check constraints, collation, foreign keys, and generated columns. It also references other related syntax elements like conflict clauses and expressions.
SOURCE: https://www.sqlite.org/docs.html/syntax/column-constraint

LANGUAGE: APIDOC
CODE:
```
column-constraint:
  - CONSTRAINT name
  - PRIMARY KEY [ASC|DESC] [conflict-clause] [AUTOINCREMENT]
  - NOT NULL [conflict-clause]
  - UNIQUE [conflict-clause]
  - CHECK ( expr )
  - DEFAULT ( expr ) | literal-value | signed-number
  - COLLATE collation-name
  - foreign-key-clause
  - GENERATED ALWAYS AS ( expr ) [VIRTUAL|STORED]

Used by: column-def
References: conflict-clause, expr, foreign-key-clause, literal-value, signed-number
```

----------------------------------------

TITLE: join-clause: SQL JOIN Clause Syntax
DESCRIPTION: Defines the syntax for a SQL JOIN clause, specifying how two table-or-subquery elements are combined using a join operator and an optional join constraint.
SOURCE: https://www.sqlite.org/docs.html/lang_createtrigger

LANGUAGE: APIDOC
CODE:
```
table-or-subquery join-operator table-or-subquery join-constraint
```

----------------------------------------

TITLE: SQLite Binding Constants: SQLITE_STATIC and SQLITE_TRANSIENT
DESCRIPTION: Explains the purpose and usage of SQLITE_STATIC and SQLITE_TRANSIENT constants when binding values in SQLite, particularly concerning object lifetime management.
SOURCE: https://www.sqlite.org/docs.html/c3ref/bind_blob

LANGUAGE: APIDOC
CODE:
```
Constant: SQLITE_STATIC
  Description: Indicates that the application remains responsible for disposing of the object.
  Lifetime: Object and pointer must remain valid until the prepared statement is finalized or the same SQL parameter is bound to something else, whichever occurs sooner.

Constant: SQLITE_TRANSIENT
  Description: Indicates that the object is to be copied prior to the return from sqlite3_bind_*().
  Lifetime: Object and pointer must remain valid until the copy is made. SQLite then manages the lifetime of its private copy.
```

----------------------------------------

TITLE: SQLite Full SELECT Statement Syntax Definition
DESCRIPTION: Defines the complete SELECT statement in SQLite, encompassing common table expressions (WITH clause), the core SELECT components, compound operators (like UNION, INTERSECT, EXCEPT), and optional ORDER BY, LIMIT, and OFFSET clauses. This is a fundamental statement used as a subquery or a top-level command in many other SQL constructs.
SOURCE: https://www.sqlite.org/docs.html/syntaxdiagrams

LANGUAGE: APIDOC
CODE:
```
WITH
RECURSIVE
common-table-expression
,
SELECT
DISTINCT
result-column
,
ALL
FROM
table-or-subquery
join-clause
,
WHERE
expr
GROUP
BY
expr
HAVING
expr
,
WINDOW
window-name
AS
window-defn
,
VALUES
(
expr
)
,
,
compound-operator
select-core
ORDER
BY
LIMIT
expr
ordering-term
,
OFFSET
expr
,
expr
```

----------------------------------------

TITLE: C Function: Load or Save SQLite In-Memory Database to Disk
DESCRIPTION: This C function, `loadOrSaveDb`, facilitates the transfer of data between an in-memory SQLite database and a physical database file on disk. It can either load data from a file into memory or save in-memory data to a file, overwriting existing content if saving. The function utilizes the SQLite backup API to perform the data transfer, handling file opening, backup object initialization, data stepping, and resource cleanup. It returns `SQLITE_OK` on success or an SQLite error code on failure.
SOURCE: https://www.sqlite.org/docs.html/backup

LANGUAGE: C
CODE:
```
/*
** This function is used to load the contents of a database file on disk
** into the "main" database of open database connection pInMemory, or
** to save the current contents of the database opened by pInMemory into
** a database file on disk. pInMemory is probably an in-memory database,
** but this function will also work fine if it is not.
**
** Parameter zFilename points to a nul-terminated string containing the
** name of the database file on disk to load from or save to. If parameter
** isSave is non-zero, then the contents of the file zFilename are
** overwritten with the contents of the database opened by pInMemory. If
** parameter isSave is zero, then the contents of the database opened by
** pInMemory are replaced by data loaded from the file zFilename.
**
** If the operation is successful, SQLITE_OK is returned. Otherwise, if
** an error occurs, an SQLite error code is returned.
*/
int loadOrSaveDb(sqlite3 *pInMemory, const char *zFilename, int isSave){
  int rc;                   /* Function return code */
  sqlite3 *pFile;           /* Database connection opened on zFilename */
  sqlite3_backup *pBackup;  /* Backup object used to copy data */
  sqlite3 *pTo;             /* Database to copy to (pFile or pInMemory) */
  sqlite3 *pFrom;           /* Database to copy from (pFile or pInMemory) */

  /* Open the database file identified by zFilename. Exit early if this fails
  ** for any reason. */
  rc = sqlite3_open(zFilename, &pFile);
  if( rc==SQLITE_OK ){

    /* If this is a 'load' operation (isSave==0), then data is copied
    ** from the database file just opened to database pInMemory.
    ** Otherwise, if this is a 'save' operation (isSave==1), then data
    ** is copied from pInMemory to pFile.  Set the variables pFrom and
    ** pTo accordingly. */
    pFrom = (isSave ? pInMemory : pFile);
    pTo   = (isSave ? pFile     : pInMemory);

    /* Set up the backup procedure to copy from the "main" database of
    ** connection pFile to the main database of connection pInMemory.
    ** If something goes wrong, pBackup will be set to NULL and an error
    ** code and message left in connection pTo.
    **
    ** If the backup object is successfully created, call backup_step()
    ** to copy data from pFile to pInMemory. Then call backup_finish()
    ** to release resources associated with the pBackup object.  If an
    ** error occurred, then an error code and message will be left in
    ** connection pTo. If no error occurred, then the error code belonging
    ** to pTo is set to SQLITE_OK.
    */
    pBackup = sqlite3_backup_init(pTo, "main", pFrom, "main");
    if( pBackup ){
      (void)sqlite3_backup_step(pBackup, -1);
      (void)sqlite3_backup_finish(pBackup);
    }
    rc = sqlite3_errcode(pTo);
  }

  /* Close the database connection opened on database file zFilename
  ** and return the result of this function. */
  (void)sqlite3_close(pFile);
  return rc;
}
```

----------------------------------------

TITLE: SQL Statement with Host Parameters for Data Binding
DESCRIPTION: Demonstrates the recommended way to insert large strings into SQLite using host parameters (question marks) instead of embedding literals. This approach prevents SQL injection attacks and improves performance by avoiding parsing and copying large strings.
SOURCE: https://www.sqlite.org/docs.html/limits

LANGUAGE: SQL
CODE:
```
INSERT INTO tab1 VALUES(?,?,?);
```

----------------------------------------

TITLE: JOIN Clause Syntax
DESCRIPTION: Specifies the syntax for joining tables or subqueries, including the join operator and join constraints.
SOURCE: https://www.sqlite.org/docs.html/lang_delete

LANGUAGE: APIDOC
CODE:
```
table-or-subquery join-operator table-or-subquery join-constraint
```

----------------------------------------

TITLE: SQLite Join Constraint Syntax
DESCRIPTION: Specifies the conditions for joining tables, either by common column names using 'USING' or by an arbitrary expression using 'ON'.
SOURCE: https://www.sqlite.org/docs.html/lang_createtable

LANGUAGE: APIDOC
CODE:
```
join-constraint:
  USING ( column-name )
  ON expr
```

----------------------------------------

TITLE: SQLite C API: sqlite3_bind_* Function Signatures
DESCRIPTION: These functions are part of the SQLite C API, used to bind values of various data types (BLOB, double, integer, text, null, pointer, zeroblob) to SQL parameters within a prepared statement. They take a sqlite3_stmt object, the 1-based index of the parameter, and the value to bind. Some functions also accept a byte count and a destructor callback for memory management, particularly for BLOB and text data.
SOURCE: https://www.sqlite.org/docs.html/c3ref/bind_blob

LANGUAGE: C
CODE:
```
int sqlite3_bind_blob(sqlite3_stmt*, int, const void*, int n, void(*)(void*));
int sqlite3_bind_blob64(sqlite3_stmt*, int, const void*, sqlite3_uint64,
                        void(*)(void*));
int sqlite3_bind_double(sqlite3_stmt*, int, double);
int sqlite3_bind_int(sqlite3_stmt*, int, int);
int sqlite3_bind_int64(sqlite3_stmt*, int, sqlite3_int64);
int sqlite3_bind_null(sqlite3_stmt*, int);
int sqlite3_bind_text(sqlite3_stmt*,int,const char*,int,void(*)(void*));
int sqlite3_bind_text16(sqlite3_stmt*, int, const void*, int, void(*)(void*));
int sqlite3_bind_text64(sqlite3_stmt*, int, const char*, sqlite3_uint64,
                         void(*)(void*), unsigned char encoding);
int sqlite3_bind_value(sqlite3_stmt*, int, const sqlite3_value*);
int sqlite3_bind_pointer(sqlite3_stmt*, int, void*, const char*,void(*)(void*));
int sqlite3_bind_zeroblob(sqlite3_stmt*, int, int n);
int sqlite3_bind_zeroblob64(sqlite3_stmt*, int, sqlite3_uint64);
```

----------------------------------------

TITLE: Querying Highest Paid Employee with SQLite's Flexible Aggregate Queries
DESCRIPTION: This SQL query demonstrates SQLite's non-standard behavior where non-aggregate columns (first_name, last_name) can be selected in an aggregate query (max(salary)) without being explicitly included in a GROUP BY clause. In SQLite, these columns will correspond to the row that satisfied the aggregate condition (e.g., the row with the maximum salary). This behavior differs from most other SQL implementations, which would typically require first_name and last_name to be in the GROUP BY clause or an aggregate function.
SOURCE: https://www.sqlite.org/docs.html/quirks

LANGUAGE: SQL
CODE:
```
SELECT max(salary), first_name, last_name FROM employee;
```

----------------------------------------

TITLE: Understanding SQLite Type Affinity and Data Storage
DESCRIPTION: Explains how SQLite handles data types, noting that column types are hints, not strict restrictions. It details the type affinity feature where SQLite attempts to convert inserted values to the column's declared type, inserting the original string if conversion fails. The exception is INTEGER PRIMARY KEY columns, which strictly enforce 64-bit signed integers.
SOURCE: https://www.sqlite.org/docs.html/faq

LANGUAGE: APIDOC
CODE:
```
SQLite Type Affinity Rules:
- Column type is a hint, not a strict restriction.
- All columns can hold arbitrary length strings.
- Exception: INTEGER PRIMARY KEY columns strictly hold 64-bit signed integers.
- Conversion attempt: If inserting a string into a numeric column, SQLite tries to convert it.
- If conversion succeeds, the converted value is inserted.
- If conversion fails, the original string is inserted.
```

----------------------------------------

TITLE: SQLite API: Compiling SQL Statements (sqlite3_prepare family)
DESCRIPTION: These SQLite C API functions are used to compile an SQL statement into a prepared bytecode program, which is represented by a `sqlite3_stmt` object. The `_v2` versions are preferred, and `_v3` adds a `prepFlags` option. UTF-8 interfaces are recommended over UTF-16. The functions take a database handle, the SQL statement, its length, an output pointer for the prepared statement, and an optional output pointer for the unused portion of the SQL string. The caller is responsible for finalizing the prepared statement with `sqlite3_finalize()`.
SOURCE: https://www.sqlite.org/docs.html/capi3ref

LANGUAGE: APIDOC
CODE:
```
int sqlite3_prepare(
  sqlite3 *db,            /* Database handle */
  const char *zSql,       /* SQL statement, UTF-8 encoded */
  int nByte,              /* Maximum length of zSql in bytes. */
  sqlite3_stmt **ppStmt,  /* OUT: Statement handle */
  const char **pzTail     /* OUT: Pointer to unused portion of zSql */
);
int sqlite3_prepare_v2(
  sqlite3 *db,            /* Database handle */
  const char *zSql,       /* SQL statement, UTF-8 encoded */
  int nByte,              /* Maximum length of zSql in bytes. */
  sqlite3_stmt **ppStmt,  /* OUT: Statement handle */
  const char **pzTail     /* OUT: Pointer to unused portion of zSql */
);
int sqlite3_prepare_v3(
  sqlite3 *db,            /* Database handle */
  const char *zSql,       /* SQL statement, UTF-8 encoded */
  int nByte,              /* Maximum length of zSql in bytes. */
  unsigned int prepFlags, /* Zero or more SQLITE_PREPARE_ flags */
  sqlite3_stmt **ppStmt,  /* OUT: Statement handle */
  const char **pzTail     /* OUT: Pointer to unused portion of zSql */
);
int sqlite3_prepare16(
  sqlite3 *db,            /* Database handle */
  const void *zSql,       /* SQL statement, UTF-16 encoded */
  int nByte,              /* Maximum length of zSql in bytes. */
  sqlite3_stmt **ppStmt,  /* OUT: Statement handle */
  const void **pzTail     /* OUT: Pointer to unused portion of zSql */
);
int sqlite3_prepare16_v2(
  sqlite3 *db,            /* Database handle */
  const void *zSql,       /* SQL statement, UTF-16 encoded */
  int nByte,              /* Maximum length of zSql in bytes. */
  sqlite3_stmt **ppStmt,  /* OUT: Statement handle */
  const void **pzTail     /* OUT: Pointer to unused portion of zSql */
);
int sqlite3_prepare16_v3(
  sqlite3 *db,            /* Database handle */
  const void *zSql,       /* SQL statement, UTF-16 encoded */
  int nByte,              /* Maximum length of zSql in bytes. */
  unsigned int prepFlags, /* Zero or more SQLITE_PREPARE_ flags */
  sqlite3_stmt **ppStmt,  /* OUT: Statement handle */
  const void **pzTail     /* OUT: Pointer to unused portion of zSql */
);
```

----------------------------------------

TITLE: Bind Values to Wildcards in SQLite Prepared Statements
DESCRIPTION: A collection of sqlite3_bind routines are used to assign values to wildcards within a prepared SQL statement. Unbound wildcards are interpreted as NULLs. Bindings are not automatically reset by sqlite3_reset(), allowing wildcards to be rebound to new values after a reset.
SOURCE: https://www.sqlite.org/docs.html/capi3

LANGUAGE: C
CODE:
```
int sqlite3_bind_blob(sqlite3_stmt*, int, const void*, int n, void(*)(void*));
int sqlite3_bind_double(sqlite3_stmt*, int, double);
int sqlite3_bind_int(sqlite3_stmt*, int, int);
int sqlite3_bind_int64(sqlite3_stmt*, int, long long int);
int sqlite3_bind_null(sqlite3_stmt*, int);
int sqlite3_bind_text(sqlite3_stmt*, int, const char*, int n, void(*)(void*));
int sqlite3_bind_text16(sqlite3_stmt*, int, const void*, int n, void(*)(void*));
int sqlite3_bind_value(sqlite3_stmt*, int, const sqlite3_value*);
```

----------------------------------------

TITLE: SQLite Simple SELECT Statement Syntax
DESCRIPTION: Defines the core syntax for a simple SELECT statement in SQLite, including optional WITH, RECURSIVE, common table expressions, ORDER BY, LIMIT, and OFFSET clauses.
SOURCE: https://www.sqlite.org/docs.html/lang_select

LANGUAGE: APIDOC
CODE:
```
WITH
RECURSIVE
common-table-expression
,
select-core
ORDER
BY
LIMIT
expr
ordering-term
,
OFFSET
expr
,
expr
```