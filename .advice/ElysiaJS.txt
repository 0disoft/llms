1.  타입 무결성을 위해 메서드 체이닝을 활용하세요. ElysiaJS의 타입 시스템은 복잡해서 모든 메서드는 새로운 타입 참조를 반환합니다. 앱 전체에서 타입 무결성과 정확한 타입 추론을 보장하려면 항상 메서드 체이닝(`.get().post().use()`)을 사용해야 해요. 이걸 안 지키면 ElysiaJS가 새로운 타입을 저장하지 못해서 타입 추론 문제나 오류가 생길 수 있습니다. 이건 ElysiaJS의 강력한 타이핑 기능을 활용하기 위한 기본적인 패턴이에요.
2.  모든 Elysia 인스턴스를 컴포넌트로 취급하세요. 모든 Elysia 인스턴스는 플러그인처럼 작동하는 컴포넌트 역할을 합니다. 이건 라우터, 스토어, 서비스 등 앱의 다양한 부분을 나타낼 수 있어요. 이런 모듈식 설계는 앱을 더 작고 관리하기 쉬운 조각으로 나누도록 권장하며, 기능을 추가하거나 제거하는 과정을 단순화합니다. 이 접근 방식은 깔끔한 아키텍처를 직접 지원하고 코드 구성을 개선합니다.
3.  `Elysia.t`를 활용해서 통합된 타입 정의를 만드세요. `Elysia.t`(TypeBox의 포크)를 데이터 타입의 단일 진실 공급원으로 활용하세요. 이건 단일 정의에서 런타임 유효성 검사, 데이터 강제 변환, TypeScript 타입, OpenAPI 스키마 생성을 제공합니다. 이건 상용구 코드를 크게 줄이고 앱 계층 전반의 일관성을 보장합니다.
4.  Elysia의 자동 타입 추론을 이해하세요. ElysiaJS의 타입 시스템은 코드를 자동으로 타입으로 추론하도록 정교하게 만들어져서, 명시적인 TypeScript 선언이 필요 없어요. 비즈니스 로직에 집중하고 프레임워크가 복잡한 타입 추론을 처리하도록 맡기세요. 이건 핵심적인 인체공학적 이점이지만, 프레임워크의 추론 기능을 믿어야 합니다.
5.  Eden을 사용해서 종단 간 타입 안전성을 확보하세요. ElysiaJS의 클라이언트 라이브러리인 "Eden"을 사용해서 백엔드 타입을 프론트엔드 팀과 자동으로 동기화하세요. Eden은 코드 생성 없이 Elysia 서버를 쿼리할 수 있게 해서 전체 스택에 걸쳐 타입 안전성을 보장합니다. 이건 풀스택 개발에서 흔히 발생하는 버그의 원인을 없애줍니다.
6.  기능 기반 폴더 구조를 채택하세요. ElysiaJS는 폴더 구조에 대해 딱히 정해진 의견이 없지만, 대규모 앱의 경우 기능 기반 접근 방식을 추천합니다. 코드를 모듈로 구성하고, 각 모듈에는 자체 컨트롤러(Elysia 인스턴스), 서비스, 모델을 포함하도록 하세요. 이렇게 하면 프로젝트가 커질수록 코드를 찾고 관리하기가 더 좋아집니다.
7.  Elysia 인스턴스를 컨트롤러로 사용하세요. 컨트롤러를 위한 별도 클래스를 만들고 전체 Context 객체를 전달하는 대신, 하나의 Elysia 인스턴스를 하나의 컨트롤러로 취급하세요. 이건 ElysiaJS의 설계와 일치하고, 복잡하고 동적인 Context 타입과 관련된 문제를 피해서 코드를 더 쉽게 타이핑하고 정적으로 분석할 수 있게 해줍니다.
8.  더 나은 타입 추론을 위해 인라인 함수를 선호하세요. 가능하다면 라우트 핸들러와 훅에 인라인 함수를 사용하세요. ElysiaJS의 타입 시스템은 인라인 코드에서 타입을 더 정확하게 추론할 수 있습니다. 외부 함수가 필요하면, 타입 명확성을 유지하기 위해 Context에서 속성을 구조 분해해서 사용하세요.
9.  `Elysia.Ref`를 활용해서 스키마를 참조하세요. 스키마 안에서 모델을 참조할 때, 향상된 자동 완성 및 개발자 경험을 위해 `Elysia.Ref`를 사용하세요. 이건 `t.Ref`보다 개선된 기능이며 인라인 스키마를 지원합니다. 이건 스키마 관리를 간소화하고 IDE 지원을 강화합니다.
10. 성능을 위한 플러그인 중복 제거를 이해하세요. ElysiaJS는 Elysia 인스턴스에 `name` 속성을 제공하면 기본적으로 플러그인 중복 제거를 처리합니다. 이건 플러그인이 한 번만 등록되도록 보장해서, 여러 번 사용해도 성능 저하와 중복된 라이프사이클 호출을 막아줍니다. 이건 대규모 앱의 시작 시간을 최적화하는 데 중요합니다.
11. 명확한 HTTP 메서드로 라우트를 정의하세요. ElysiaJS는 모든 표준 HTTP 메서드(get, post, put, patch, delete, all) 및 사용자 지정 메서드를 지원합니다. 명확성과 REST 원칙 준수를 위해 특정 메서드를 사용하세요. 동적 경로와 와일드카드도 유연한 라우팅을 위해 완벽하게 지원됩니다.
12. `Elysia.t`를 활용해서 포괄적인 유효성 검사를 수행하세요. `Elysia.t`를 사용해서 경로 매개변수(params), 쿼리 문자열(query), 요청 본문(body), 헤더(headers), 쿠키(cookie) 등 모든 들어오는 데이터를 유효성 검사하세요. 또 응답 본문을 보내기 전에 유효성 검사하는 것도 지원합니다. 이건 모든 상호 작용 지점에서 데이터 무결성을 보장합니다.
13. FormData 응답에 `t.Form`을 활용하세요. Elysia 1.3에 새로 나온 `t.Form` 타입을 사용해서 컴파일 타임에 FormData 응답을 처리하고 타입 검사하세요. 이건 multipart 폼 데이터에 대한 이전 `t.Object`의 한계를 대체합니다. 이건 파일 업로드와 복잡한 폼 데이터를 관리하는 더 견고하고 타입 안전한 방법을 제공합니다.
14. 성능 또는 프로토타이핑을 위해 `t.NoValidate`를 사용하세요. 특정 스키마에 대한 런타임 유효성 검사를 건너뛰어야 할 때(예: 빠른 프로토타이핑이나 유효성 검사가 다른 곳에서 처리되는 성능에 중요한 경로), `t.NoValidate`를 사용하세요. 이건 여전히 TypeScript 타입 검사 및 OpenAPI 스키마 생성을 제공합니다. 이건 런타임 검사를 우회하니까 신중하게 사용해야 합니다.
15. 라이프사이클 훅 순서의 중요성을 이해하세요. ElysiaJS의 라이프사이클 훅을 정의하는 순서는 아주 중요합니다. 이벤트는 훅이 등록된 후에 등록된 라우트에만 적용돼요. 예를 들어, `onError` 훅은 보호하려는 핸들러보다 먼저 호출되어야 합니다. 순서가 안 맞으면 예상치 못한 동작이나 처리되지 않은 오류가 발생할 수 있어요.
16. 로컬 훅과 인터셉터 훅을 현명하게 선택하세요. 라우트별 로직(예: 특정 엔드포인트의 콘텐츠 타입 설정)에는 로컬 훅(라우트 핸들러에 인라인으로 포함)을 사용하세요. 전역 로깅이나 속도 제한처럼 인스턴스 내의 모든 후속 라우트에 적용되는 로직에는 인터셉터 훅(`.on()`으로 등록)을 사용하세요.
17. 초기 요청 가로채기를 위해 `onRequest`를 사용하세요. `onRequest` 훅은 새 요청이 들어올 때 실행되는 가장 이른 라이프사이클 이벤트입니다. 캐싱, 속도 제한, 분석 또는 전역 CORS 헤더 설정 같은 공통 관심사를 구현하는 데 딱이에요. `onRequest`에서 값을 반환하면 전체 요청 라이프사이클이 중단됩니다.
18. 사용자 지정 본문 파싱을 위해 `onParse`를 구현하세요. ElysiaJS의 기본 파서(JSON, multipart/form-data)가 충분하지 않을 때 `onParse` 훅을 사용해서 사용자 지정 본문 파싱 로직을 구현하세요. 반환된 값은 `Context.body`에 할당됩니다. 이걸로 고유한 콘텐츠 타입이나 복잡한 데이터 구조를 처리할 수 있어요.
19. 유효성 검사 전 Context 변형을 위해 `transform`을 활용하세요. `transform` 라이프사이클 이벤트는 유효성 검사 전에 실행되며, 유효성 검사 규칙에 맞게 Context를 변형하는 데 유용합니다. 예를 들어, 경로 매개변수를 숫자로 유효성 검사하기 전에 숫자로 강제 변환하는 데 사용됩니다. 이건 데이터가 유효성 검사를 위해 예상되는 형식으로 되어 있는지 확인합니다.
20. 핸들러 전 로직을 위해 `onBeforeHandle`을 사용하세요. 일반적인 유효성 검사 후 메인 라우트 핸들러 전에 `onBeforeHandle`을 사용해서 사용자 지정 유효성 검사나 권한 부여 검사를 실행하세요. 이 훅에서 값을 반환하면 메인 핸들러의 실행이 중단됩니다. 이건 사용자 역할이나 권한에 따라 라우트를 보호하는 데 딱이에요.
21. `onAfterHandle`로 응답을 변환하세요. `onAfterHandle` 훅은 메인 핸들러가 값을 반환한 후에 실행됩니다. 반환된 값을 변환(예: 압축 또는 이벤트 스트림)하거나 응답 내용에 따라 사용자 지정 헤더를 추가하는 데 사용하세요. 이건 응답 후처리를 위한 중앙 집중식 지점을 제공합니다.
22. 웹 표준을 위해 `mapResponse`로 응답을 매핑하세요. `mapResponse`는 `onAfterHandle` 후에 실행되며, 반환된 값을 웹 표준 응답으로 매핑하도록 설계되었습니다. 압축 또는 특정 응답 형식 준수 보장 같은 작업에 적합합니다.
23. `onAfterResponse`로 정리 작업을 수행하세요. `onAfterResponse` 훅은 응답이 클라이언트에 전송된 후에 실행됩니다. 이건 클라이언트의 응답을 막을 필요가 없는 정리 작업, 로깅 또는 분석에 딱이에요.
24. `onError`로 전역 오류 처리를 구현하세요. `onError` 라이프사이클 이벤트를 사용해서 라이프사이클의 어느 곳에서든 발생한 예기치 않은 오류를 중앙에서 잡아서 해결하세요. 사용자 지정 오류 메시지 제공, 페일 세이프 구현, 요청 재시도, 로깅/분석에 권장됩니다.
25. 세분화된 처리를 위해 사용자 지정 오류 코드를 정의하세요. ElysiaJS는 `Elysia.error()`를 사용해서 사용자 지정 오류 코드를 지원합니다. 이건 `onError` 핸들러에서 완전한 타입 안전성과 자동 완성을 위해 오류 타입을 분류하고 세분화하는 데 도움이 됩니다. 이건 디버깅을 개선하고 더 구체적인 오류 응답을 가능하게 합니다.
26. `error` 함수에서 `status` 함수로 마이그레이션하세요. Elysia 1.3부터 `error` 함수는 더 이상 안 써요. 응답과 함께 HTTP 상태 코드를 반환하려면 `status` 함수로 바꾸세요. 이건 더 나은 추론과 명확한 API 계약을 위한 권장 방식입니다. (`error` 함수는 1.3 출시 후 최소 6개월 동안은 지원될 예정이에요.)
27. `guard`를 사용해서 로컬 오류 처리를 구현하세요. 라우트별 오류 처리를 위해 라우트의 `guard` 구성 안에서 `error` 속성을 사용하세요. 이걸로 특정 스코프에 대한 지역화된 오류 핸들러를 정의할 수 있습니다. 이건 특정 엔드포인트에 고유한 오류를 처리하는 데 유용합니다.
28. 런타임으로 Bun을 우선시하세요. ElysiaJS는 번들러, 테스트 러너, 패키지 관리자 역할을 하는 고속 JavaScript 런타임인 Bun에서 가장 잘 실행되도록 설계되었습니다. 최고 성능과 효율성을 위해 프로덕션 배포 시 Bun의 기본 기능을 활용하세요.
29. 정적 코드 분석 및 AOT 컴파일을 활용하세요. ElysiaJS는 정적 코드 분석과 AOT(Ahead-of-Time) 컴파일을 사용해서 고도로 최적화된 코드를 생성합니다. 이걸로 ElysiaJS는 Golang이나 Rust 프레임워크와 비슷한 성능을 낼 수 있어요. 이건 ElysiaJS의 핵심 성능 차별화 요소입니다.
30. Elysia 1.3의 Exact Mirror를 통한 정규화 이점을 활용하세요. Elysia 1.3은 TypeBox의 `Value.Clean`을 대체하는 기본 정규화 전략으로 Exact Mirror를 도입했습니다. 이건 코드 변경 없이도 엄청난 성능 개선(작은 객체에서 최대 ~500배 빠름)을 제공합니다. 이건 업그레이드 시 자동으로 적용되는 성능 향상이에요.
31. 동적 라우트에 Bun System Router를 활용하세요. Elysia 1.3은 이제 가능한 경우 Bun의 네이티브 라우터를 활용하는 이중 라우터 전략을 사용하는데, 이건 2-5% 더 빠른 성능을 제공합니다. 이 최적화는 자동으로 적용돼요. 이건 전반적인 라우팅 효율성에 기여합니다.
32. 타입 인스턴스화 감소를 활용하세요. Elysia 1.3은 타입 인스턴스화를 절반으로 줄여서 타입 추론 속도를 최대 60% 향상시켰습니다. 이건 특히 대규모 앱에서 더 빠른 IDE 자동 완성, 제안, 타입 검사로 이어집니다. 이건 개발자 생산성을 높여줍니다.
33. 메모리 사용량 감소 및 시작 시간 단축을 위해 최적화하세요. Elysia 1.3의 라우트 정보 저장 및 플러그인 생성 리팩토링은 메모리 사용량(라우트의 경우 최대 5.6배, 플러그인의 경우 10배)을 크게 줄이고 등록/생성 시간을 단축시켰습니다. 이런 개선 사항은 리소스 제약이 있는 환경과 서버리스 콜드 스타트에 아주 중요합니다.
34. `onRequest` 및 Redis를 사용해서 캐싱을 구현하세요. `onRequest` 라이프사이클 훅을 사용해서 캐싱 전략을 구현하세요. 이건 요청 라이프사이클에서 가장 이른 시점입니다. `@atakan75/elysia-redis` 같은 플러그인을 사용해서 Redis와 통합하고 자주 접근하는 데이터를 밀리초 미만의 성능으로 저장하세요.
35. 적절한 Redis 캐싱 패턴을 선택하세요. 앱 필요에 따라 캐시-어사이드(읽기 집약적 앱용), 쓰기-비하인드(쓰기 성능 향상용), 쓰기-스루(데이터 일관성용) 또는 캐시 프리페칭(연속 복제용) 같은 다양한 Redis 캐싱 패턴을 고려하세요.
36. 스트리밍 응답을 위해 제너레이터 함수를 활용하세요. 스트리밍 응답(예: Server-Sent Events, 대용량 파일 제공)의 경우 핸들러에서 제너레이터 함수(`function*`와 `yield`)를 사용하세요. ElysiaJS는 스트리밍을 자동으로 처리합니다. 이건 실시간 데이터나 대용량 페이로드에 효율적입니다.
37. 첫 번째 스트림 청크를 `yield`하기 전에 헤더를 설정하세요. 스트리밍을 위해 제너레이터 함수를 쓸 때, 필요한 모든 응답 헤더가 첫 번째 `yield` 문 전에 설정되었는지 확인하세요. 초기 청크가 전송된 후 설정된 헤더는 무시됩니다.
38. 조건부 스트리밍을 고려하세요. 제너레이터 함수 안에서 일반 응답을 조건부로 반환하거나 데이터를 스트리밍할 수 있어요. 함수가 `yield` 문 없이 값을 반환하면 ElysiaJS는 자동으로 그걸 표준 응답으로 변환합니다. 이건 응답 처리의 유연성을 제공합니다.
39. 효율적인 파일 제공을 위해 `Bun.file`을 사용하세요. 정적 파일을 제공하려면 `Bun.file`을 핸들러에서 직접 반환할 수 있습니다. `elysia-static`도 쓸 수 있지만, 대용량 미디어 파일의 바이트 범위 요청(탐색)에 대한 현재 제한 사항을 알아두세요. 간단한 정적 자산의 경우 이건 아주 효율적입니다.
40. 확장성을 위해 플러그인 생성을 최적화하세요. 여러 인스턴스를 만들고 플러그인으로 적용할 때, Elysia 1.3은 상당한 개선(메모리 사용량 최대 10배 감소, 생성 속도 3배 향상)을 보여줍니다. 이건 수많은 플러그인을 사용해서 모듈식으로 확장 가능한 앱을 만드는 걸 더 효율적으로 만들어줍니다.
41. 타입 안전 ORM을 위해 Prismabox와 Prisma를 통합하세요. 타입 안전 데이터베이스 상호 작용을 위해 Prisma를 ORM으로 사용하세요. Prismabox를 통합해서 Prisma 스키마에서 직접 Elysia 유효성 검사 모델을 만드세요. 이건 API 유효성 검사가 데이터베이스 스키마를 반영하도록 보장해서 데이터 불일치를 줄입니다.
42. 유효성 검사를 위해 drizzle-typebox와 Drizzle ORM을 사용하세요. Drizzle ORM 사용자라면 `drizzle-typebox`를 활용해서 Drizzle 스키마를 Elysia 유효성 검사 모델로 변환하세요. 이걸로 데이터베이스 스키마를 API 유효성 검사에 직접 쓸 수 있어요.
43. Drizzle 통합을 위해 `@sinclair/typebox` 버전을 고정하세요. Drizzle ORM을 쓸 때, `package.json`에서 `@sinclair/typebox` 버전을 ElysiaJS의 최소 버전과 일치하도록 명시적으로 고정하세요. 이건 심볼 충돌이나 "타입 인스턴스화가 무한할 수 있음" 오류를 막아줍니다.
44. Drizzle 스키마 처리를 위해 유틸리티 함수를 사용하세요. Drizzle 스키마 작업의 복잡성을 줄이고 "무한 타입 인스턴스화" 같은 복잡한 타입 문제를 피하려면, 유틸리티 함수(예: `spread`)를 사용해서 Drizzle 스키마를 `t.Pick`과 `t.Omit`에 쓸 수 있는 일반 객체로 변환하세요.
45. 싱글톤을 사용해서 Drizzle 스키마 접근을 중앙 집중화하세요. 코드베이스 전반에서 Drizzle 테이블 스키마에 더 깔끔하게 접근하려면, `db` 객체를 저장하기 위한 싱글톤 패턴을 구현하세요. 이걸로 `db.insert.user`를 직접 임포트할 수 있어서 코드 가독성과 일관성이 향상됩니다.
46. 자동 완성 및 OpenAPI를 위해 `Elysia.t`로 모델을 정의하세요. 항상 `Elysia.t`를 사용해서 데이터 모델(DTO)을 정의하세요. 이건 자동 완성을 제공하고, 스키마 수정을 허용하며, 모델이 OpenAPI 문서(예: Swagger)에 올바르게 표시되도록 보장합니다.
47. 조직화를 위해 관련 모델을 그룹화하세요. 더 나은 조직화와 모듈성을 위해 여러 관련 모델을 단일 객체로 그룹화하세요. 이건 스키마 정의를 깔끔하게 유지하고 관리하기 쉽게 합니다.
48. 전체 Context를 서비스에 전달하는 것을 피하세요. 전체 Context 객체를 서비스 함수에 전달하지 마세요. 대신, 객체 구조 분해를 사용해서 필요한 속성만 추출하세요. 이건 타입 명확성을 유지하고 서비스를 ElysiaJS의 동적 Context에 너무 밀접하게 묶는 걸 막아줍니다.
49. 요청에 독립적인 서비스를 정적 클래스로 추상화하세요. 서비스나 함수가 HTTP 요청 Context에 접근할 필요가 없다면, 이걸 정적 클래스나 함수로 추상화하세요. 이건 비즈니스 로직을 웹 프레임워크에서 분리해서 더 테스트하기 쉽고 재사용 가능하게 만들어줍니다.
50. 요청에 종속적인 서비스를 Elysia 인스턴스로 추상화하세요. HTTP 요청을 처리하거나 Context 속성에 접근해야 하는 서비스의 경우, 이걸 별도의 Elysia 인스턴스로 추상화하세요. 이건 타입 무결성을 유지하고 성능을 위해 ElysiaJS의 플러그인 중복 제거를 활용합니다.