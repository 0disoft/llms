1.  기본적으로 제로 자바스크립트 채택: 모든 비대화형 콘텐츠는 정적 HTML로 렌더링하는 걸 우선하세요. Astro의 가장 큰 장점은 자바스크립트를 최소한으로만 사용해서 초기 페이지 로딩을 엄청나게 빠르게 하고 핵심 웹 바이탈 점수를 높인다는 거예요. 이건 사용자 경험과 검색 엔진 최적화(SEO) 순위를 크게 높여줍니다.
2.  부분 하이드레이션(아일랜드) 전략적으로 사용: `client:*` 지시어(예: `client:load`, `client:visible`)를 사용해서 대화형 컴포넌트에만 자바스크립트를 하이드레이션하세요. 이렇게 하면 불필요한 JS 번들을 로드하지 않아서 사이트를 가볍고 빠르게 유지할 수 있습니다.
3.  내장 기능으로 이미지 최적화: Astro의 `<Image />` 컴포넌트를 활용해서 자동 이미지 최적화(자르기, 반응형 레이아웃 포함)를 수행하세요. 모든 장치에 맞게 이미지가 올바르게 크기 조정되고 형식이 지정되어서 로드 시간을 단축할 수 있습니다.
4.  실험적인 SVG 컴포넌트 활용: 벡터 그래픽의 경우 Astro 5.x에서 실험적인 SVG 컴포넌트를 활성화하는 걸 고려하세요. `.svg` 파일을 컴포넌트로 바로 가져와서 쉽게 스타일링하고 최적화할 수 있어요. 이건 HTTP 요청을 줄이고 SVG 자산을 더 잘 제어하는 데 도움이 됩니다.
5.  중요 CSS 인라인화: 중요한 CSS를 HTML 문서에 직접 인라인화하는 기능을 구현하세요. Astro는 이 내장 최적화를 지원하며, 외부 스타일시트를 기다릴 필요 없이 '스크롤 없이 볼 수 있는' 콘텐츠를 더 빠르게 렌더링하는 데 도움이 됩니다.
6.  모든 코드 자산 최소화: 빌드 과정에서 HTML, CSS, 자바스크립트 코드가 최소화되었는지 확인하세요. Astro는 이걸 내장 최적화로 포함해서 파일 크기를 줄이고 사용자 다운로드 속도를 높여줍니다.
7.  화면 밖 콘텐츠에 대한 지연 로딩 구현: 이미지를 포함한 필수적이지 않은 자산은 뷰포트에 들어올 때까지 로드를 지연시키세요. Astro의 내장 지연 로딩 기능은 불필요한 초기 다운로드를 막아서 체감 성능을 향상시킵니다.
8.  핵심 웹 바이탈 정기적으로 모니터링: Largest Contentful Paint (LCP), Cumulative Layout Shift (CLS), First Input Delay (FID) 같은 지표를 계속 추적하세요. Astro로 만든 사이트는 보통 높은 점수(예: CWV 합격률 95%)를 받지만, 꾸준한 모니터링이 중요합니다.
9.  과도한 하이드레이션 피하기: 불필요한 컴포넌트를 하이드레이션하지 않도록 주의하세요. 이건 Astro의 성능 이점을 상쇄시킬 수 있습니다. 사용자 경험을 정말로 향상시키는 곳에만 클라이언트 측 상호 작용을 추가하세요.
10. 타사 스크립트 및 글꼴 신중하게 관리: 이런 요소들은 성능에 큰 영향을 줄 수 있습니다. `font-display: swap` 및 스크립트 지연(defer, async) 같은 모범 사례를 사용해서 차단 효과를 최소화하세요. 스크립트를 웹 워커로 오프로드하기 위해 `astro-partytown`을 고려할 수 있습니다.
11. 시맨틱 HTML 마크업 우선순위 지정: 접근 가능하고 시맨틱한 HTML을 작성하세요. 사용자에게 좋은 건 본질적으로 검색 엔진 크롤러에게도 좋아서, 이해도와 순위를 높여줍니다. Astro의 HTML 우선 접근 방식은 자연스럽게 이걸 장려합니다.
12. 적절한 메타 태그 구현: `astro-seo-plugin` 같은 전용 플러그인이나 수동 프론트매터를 사용해서 페이지 제목, 설명, Open Graph 태그, Twitter 카드 태그를 관리하세요. 이건 검색 결과와 소셜 공유에서 콘텐츠가 잘 보이도록 보장합니다.
13. 사이트맵 생성: `@astrojs/sitemap`을 사용해서 Astro 사이트의 사이트맵을 자동으로 만드세요. 사이트맵은 검색 엔진이 웹사이트의 모든 페이지를 효율적으로 찾고 크롤링하는 데 도움이 됩니다.
14. JSON-LD 구조화된 데이터 활용: JSON-LD 구조화된 데이터를 구현해서 Google 등 검색 엔진이 사이트 콘텐츠를 더 잘 이해하도록 도우세요. 이건 검색 결과에서 리치 스니펫으로 이어져 가시성을 높일 수 있습니다.
15. 자바스크립트 없이 크롤링 가능성 보장: 자바스크립트 실행 없이도 사이트의 중요한 콘텐츠가 검색 엔진 크롤러에게 제공되는지 확인하세요. Astro의 정적 우선 렌더링은 본질적으로 이걸 지원해서 SEO 우위를 제공합니다.
16. 빠른 로드 시간 최적화: 빠른 로드 시간이 SEO의 주요 순위 요소라는 걸 인식하세요. Astro의 최소 JS 및 내장 최적화는 여기에 직접적으로 기여해서 강력한 SEO 기반을 제공합니다.
17. 로봇 설정 구성: `robots` 메타 태그나 `robots.txt`를 사용해서 검색 엔진 봇에게 무엇을 크롤링하고 인덱싱할지 알려주세요. 이건 특정 페이지의 공개 가시성을 관리하는 데 중요합니다.
18. SEO 친화적인 URL을 위한 콘텐츠 컬렉션 활용: Astro의 내장 콘텐츠 컬렉션을 사용해서 콘텐츠를 구성하세요. 이건 깔끔하고 예측 가능하며 SEO 친화적인 URL 구조를 쉽게 만들어줍니다. 크롤링 가능성과 사용자 경험을 향상시킵니다.
19. 주제별 핵심에 초점을 맞춘 키워드 연구: 광범위한 주제별 콘텐츠 핵심을 중심으로 SEO 노력을 조직하고 관련 키워드를 타겟팅하세요. 이 전략은 권위를 확립하고 사용자를 판매 유입 경로로 더 끌어들이는 데 도움이 됩니다.
20. 사고 리더십 콘텐츠 생성: 사용자 검색 의도를 직접적으로 해결하는 간결하고 가치 있는 콘텐츠를 개발하세요. 명확한 클릭 유도 문안을 포함하고 시각적 요소를 사용해서 가독성과 참여도를 높이세요.
21. 정적 콘텐츠에 정적 사이트 생성(SSG) 선택: 문서, 블로그, 마케팅 페이지처럼 콘텐츠가 거의 안 바뀌는 경우 SSG를 선택하세요. 이건 가능한 가장 빠른 로드 시간과 CDN에서 가장 저렴한 호스팅을 제공합니다.
22. 동적 콘텐츠에 서버 측 렌더링(SSR) 사용: 전자상거래 재고나 사용자별 대시보드처럼 자주 바뀌는 콘텐츠에는 SSR을 사용하세요. SSR은 콘텐츠가 항상 최신 상태를 유지하도록 보장하며 SEO에 탁월합니다.
23. 혼합 콘텐츠에 하이브리드 렌더링 활용: 같은 프로젝트나 같은 페이지 안에서 SSG와 SSR을 결합하세요. Astro 5.x의 서버 아일랜드(실험적) 및 간소화된 사전 렌더링은 이걸 쉽게 만들어줘서 두 가지 장점을 모두 제공합니다.
24. 어댑터와 함께 증분 정적 재생성(ISR) 활용: 전체 재빌드 없이 가끔 업데이트가 필요한 정적 페이지의 경우 배포 어댑터를 통해 ISR을 구성하세요. 이건 성능과 콘텐츠 신선도 사이의 균형을 맞춰줍니다.
25. Astro 5.x의 사전 렌더링 간소화 이해: 하이브리드 및 정적 옵션이 이제 기본 정적 옵션으로 통합되었음을 알아두세요. 개별 경로에 대한 런타임 렌더링을 활성화하려면 어댑터를 추가하기만 하면 돼서 구성이 간단해집니다.
26. 동적 로직을 위한 엣지 함수 고려: 엣지 함수 및 미들웨어를 사용해서 동적 로직을 사용자에게 더 가깝게 배포해서 50ms 미만의 지연 시간을 달성하세요. 이건 속도를 유지하면서 개인화 및 동적 기능을 향상시킵니다.
27. 콘텐츠 요구 사항에 렌더링 정렬: 맹목적으로 한 가지 전략을 선택하지 말고 콘텐츠 변동성과 상호 작용 요구 사항을 평가하세요. 올바른 렌더링 선택은 사이트 속도, SEO, 개발자 경험, 비용에 영향을 미칩니다.
28. SSR 인프라 복잡성 인지: SSR은 신선도를 제공하지만 정적 호스팅에 비해 더 복잡한 인프라를 필요로 합니다. 이점과 늘어나는 운영 오버헤드 사이의 균형을 맞춰야 합니다.
29. 실시간 데이터를 위한 실시간 콘텐츠 컬렉션 사용: 실시간 스트림이나 개인화된 추천처럼 아주 동적인 데이터의 경우 실험적인 실시간 콘텐츠 컬렉션(Astro 5.10 이상)을 사용하세요. 이건 요청 시 데이터를 가져와서 절대적인 신선도를 보장합니다.
30. 실시간 컬렉션을 서버 아일랜드와 결합: 정말 하이브리드 페이지를 위해 실시간 콘텐츠 컬렉션을 서버 아일랜드와 함께 사용하세요. 이걸로 기본 콘텐츠는 정적으로 유지하면서 특정 컴포넌트가 동적으로 실시간 데이터를 가져와서 표시할 수 있습니다.
31. 구조화된 콘텐츠를 위한 콘텐츠 컬렉션 활용: Astro의 내장 콘텐츠 컬렉션을 사용해서 마크다운 및 MDX 콘텐츠를 구성하세요. 이건 타입 안전성, 프론트매터 유효성 검사, 최적화된 쿼리 API를 제공합니다.
32. 동적 데이터를 위한 실시간 콘텐츠 컬렉션 활용: 재고, 사용자 생성 콘텐츠처럼 자주 바뀌는 콘텐츠의 경우 실험적인 실시간 콘텐츠 컬렉션(Astro 5.10 이상)을 사용하세요. 이건 요청 시 데이터를 가져와서 실시간 정확도를 보장합니다.
33. 헤드리스 CMS와 통합: Sanity, Strapi, Sitepins 또는 TinaCMS 같은 헤드리스 CMS 플랫폼과 Astro 사이트를 연결하세요. 이건 콘텐츠를 코드에서 분리해서 비기술 팀을 위한 콘텐츠 편집을 간단하게 만듭니다.
34. 네이티브 Fetch API로 데이터 가져오기: Astro 컴포넌트 프론트매터 또는 프레임워크 컴포넌트 안에서 표준 Fetch API를 직접 사용하세요. Astro는 빌드 시간 또는 런타임에 편리한 데이터 가져오기를 위해 최상위 `await`를 지원합니다.
35. GraphQL 엔드포인트 쿼리: Astro는 Fetch API를 사용해서 GraphQL 서버를 직접 쿼리할 수 있습니다. 이건 다양한 데이터 소스와 상호 작용할 수 있는 유연성을 제공합니다.
36. 양식 데이터 효과적으로 처리: 양식 제출의 경우 컴포넌트의 프론트매터에서 `Astro.request.formData()`를 사용해서 서버 측 처리를 위해 데이터에 접근하세요. 클라이언트 측 상호 작용의 경우 API 경로 또는 Astro 액션을 사용하세요.
37. 빌드 시간 대 요청 시간 데이터 가져오기 이해: 데이터가 언제 가져와지는지 구분하세요. 빌드 시간 컬렉션은 정적 콘텐츠용이고, 실시간 컬렉션 및 API 호출은 동적 데이터용입니다. 이건 성능과 콘텐츠 신선도에 영향을 미칩니다.
38. 빌드 시간 데이터를 위한 `getCollection()` 및 `getEntry()` 사용: 자주 바뀌지 않는 콘텐츠에 대해 이런 함수를 사용해서 콘텐츠의 불변 스냅샷을 쿼리하세요. 이건 아주 성능이 좋습니다.
39. 실시간 데이터에 대한 오류 처리 구현: `getLiveCollection()` 또는 `getLiveEntry()`를 사용할 때 항상 오류 처리를 포함하세요. 외부 소스에서 실시간 데이터를 가져오는 건 잠재적인 네트워크 또는 API 오류를 발생시킵니다.
40. 긴밀한 결합을 위한 Git 기반 CMS 고려: 콘텐츠와 코드가 긴밀하게 결합되어야 하는 프로젝트의 경우 Sitepins 또는 TinaCMS 같은 Git 기반 CMS가 좋은 선택입니다. 이들은 버전 관리되는 콘텐츠 워크플로우를 통해 시각적 편집을 제공합니다.
41. 하이드레이션 제어를 위한 클라이언트 지시어 숙달: `client:load`, `client:idle`, `client:visible`, `client:media`, `client:only`를 이해하고 적용해서 UI 프레임워크 컴포넌트가 하이드레이션되는 시점과 방식을 제어하세요. 이건 정확한 상호 작용과 성능에 중요합니다.
42. 여러 UI 프레임워크를 아일랜드로 통합: Astro의 프레임워크 독립적인 특성을 활용해서 React, Vue, Svelte 또는 Solid 컴포넌트를 상호 작용이 필요한 곳에만 사용하세요. 이걸로 단일 프로젝트 안에서 여러 기술을 섞어 쓸 수 있습니다.
43. 유연한 콘텐츠 삽입을 위한 슬롯 활용: Astro 컴포넌트에서 기본 및 명명된 `<slot />` 요소를 사용해서 부모 컴포넌트의 동적 콘텐츠를 허용하는 재사용 가능한 레이아웃 및 컴포넌트를 만드세요. 이건 모듈화와 깔끔한 코드를 촉진합니다.
44. Astro 컴포넌트를 MDX 및 Markdoc과 결합: Astro 컴포넌트를 MDX(`.mdx`) 및 Markdoc(`.mdoc`) 파일 안에 직접 통합해서 풍부하고 대화형 콘텐츠를 만드세요. 이걸로 콘텐츠 안에 차트나 대화형 양식 같은 동적 요소를 넣을 수 있습니다.
45. 컴포넌트를 위한 사용자 정의 Markdoc 태그/노드 생성: Markdoc의 경우 사용자 정의 태그(예: `{% aside %}`)를 매핑하거나 표준 HTML 요소(예: `<img>`)를 재정의해서 특정 Astro 컴포넌트를 렌더링하세요. 이건 아주 사용자 정의 가능한 콘텐츠 작성 경험을 가능하게 합니다.
46. 콘텐츠의 최적화된 이미지를 위한 `astro:assets` 사용: MDX 또는 Markdoc에 이미지를 넣을 때 `astro:assets`를 통해 Astro의 내장 이미지 최적화를 활용하세요. 이건 반응형 이미지와 형식을 자동으로 처리합니다.
47. 원활한 탐색을 위한 뷰 전환 고려: Astro의 기본 브라우저 뷰 전환(v4에 도입) 지원을 활용해서 부드러운 페이지 탐색을 구현하세요. 이건 체감 속도와 사용자 경험을 향상시킵니다.
48. 데이터를 프레임워크 컴포넌트에 프롭으로 전달: Astro의 프론트매터에서 가져온 데이터를 클라이언트 측 UI 프레임워크 컴포넌트에 프롭으로 효율적으로 전달하세요. 이건 데이터 가져오기를 서버에 유지하면서 클라이언트 측 상호 작용을 허용합니다.
49. 동적 부분을 위한 서버 아일랜드 이해: 서버 아일랜드(Astro 5.x)를 실험해서 서버에서 동적 콘텐츠를 렌더링하고 클라이언트로 스트리밍하세요. 이건 전체 페이지 하이드레이션 없이 개인화된 콘텐츠에 딱이에요.
50. 대화형 코드 예제를 위한 CodeToggle 활용: 문서 사이트의 경우 CodeToggle 같은 컴포넌트를 고려해서 대화형 컴포넌트와 해당 소스 코드를 함께 표시하세요. 이건 기술 콘텐츠에 대한 개발자 경험을 향상시킵니다.