1.  Resumability를 완전히 받아들이세요. Qwik 앱은 하이드레이션 과정 없이 서버에서 실행을 멈췄다가 클라이언트에서 바로 이어서 실행된다는 걸 이해해야 합니다. 이 방식 덕분에 Qwik은 거의 즉각적인 시작 성능을 낼 수 있어요.
2.  자바스크립트 실행을 최대한 지연시키세요. Qwik의 핵심 전략은 JS 실행과 다운로드를 가능한 한 오래 미루는 겁니다. 초기 JS는 대략 1KB 정도만으로 부팅되도록 앱을 설계해서 Qwik의 최적화 도구가 필요할 때만 코드를 동적으로 로드하게 만드세요. 이건 거의 즉각적인 상호 작용을 보장해 줍니다.
3.  세분화된 지연 로딩을 활용하세요. Qwik은 앱을 개별 컴포넌트보다 더 작은, 아주 많은 작은 조각들로 자동으로 쪼개서 지연 로드해요. 이렇게 '세분화된' 접근 방식을 쓰면 사용자 작업에 꼭 필요한 코드만 다운로드되고 실행돼서 불필요하게 덩치가 커지는 걸 막을 수 있습니다.
4.  `$` 마커를 이해하세요. `$component()`, `$onClick()`, `$useTask()`처럼 `$` 접미사는 지연 로딩 경계의 명확한 표시로 사용됩니다. 이 명시적인 마커는 Qwik의 최적화 도구가 코드를 효과적으로 분리하고, 개발자에게 비동기 지연 로딩이 어디서 일어나는지 알려주는 데 아주 중요해요.
5.  `qwikVite()`로 번들 배포를 최적화하세요. `vite.config.ts` 파일에서 `qwikVite()` 플러그인을 사용해서 Qwik 심볼이 청크로 배포되는 방식을 제어하세요. 기본값은 `smart`지만, 런타임 분석을 기반으로 `manual` 설정을 고려해서 자주 쓰는 심볼들을 한곳에 모으고 HTTP 요청을 최소화하는 게 좋습니다.
6.  번들 최적화를 위해 런타임 분석을 활용하세요. `qsymbol` 이벤트 리스너를 추가해서 실행 중인 앱에서 심볼 사용량을 수집하세요. 이 데이터를 보면 어떤 심볼이 함께 사용되는지 알 수 있어서, `vite.config.ts`를 개선하고 네트워크 워터폴 지연을 줄이는 데 도움이 됩니다.
7.  프리페칭을 위해 Qwik 프리로더로 전환하세요. 2025년 5월 Qwik 1.14.0부터 서비스 워커는 번들 프리페칭에 `<link rel="modulepreload">`를 활용하는 Qwik 프리로더로 바뀌었어요. 프로젝트를 업데이트해서 시작 페널티 감소와 TTI 단축의 이점을 꼭 누리세요.
8.  `Cache-Control` 헤더를 올바르게 설정하세요. 서비스 워커를 사용하지 않게 되면서 번들 및 자산에 적절한 HTTP `Cache-Control` 헤더(예: `public`, `max-age=31536000`, `immutable`)를 설정하는 게 중요해요. 이건 변경 불가능한 해시된 파일 이름에 대해 오래 캐싱해서 불필요한 재다운로드를 막아줍니다.
9.  Qwik Insights로 프리페칭 우선순위를 정하세요. Qwik은 사용자 이벤트나 "스크롤 없이 볼 수 있는 부분" 컴포넌트를 기반으로 어떤 번들이 요청될 가능성이 높은지 미리 예측할 수 있어요. Qwik Insights(향후 기능)를 활용해서 프리페칭의 우선순위를 더 높여서 중요한 상호 작용이 즉시 이루어지도록 만드세요.
10. 네트워크 워터폴을 최소화하세요. Qwik 아키텍처는 필요할 때만 코드를 다운로드하고 필요한 모듈은 백그라운드에서 미리 가져와서 네트워크 워터폴을 본질적으로 줄여줍니다. 이걸 최대한 활용하도록 앱을 설계해서 워터폴을 다시 유발할 수 있는 즉시 로딩 패턴은 피하세요.
11. 파일 이름에 케밥 케이스를 사용하세요. 모든 파일 이름에 `kebab-case`(예: `my-component.tsx`처럼)를 써서 프로젝트 일관성을 유지하세요. 이건 강제는 아니지만, 가독성을 높이고 커뮤니티 스타일 가이드와도 일치합니다.
12. 시그널에 "Sig" 접미사를 추가하세요. `useSignal()`, `useStore()`, `useComputed$()`로 만든 변수 이름에는 항상 `Sig` 접미사를 붙이세요. 이렇게 하면 반응형 상태 변수가 명확하게 구분돼서 컴포넌트 코드를 더 '훑어보기 좋게' 만들고 비반응형 값과의 혼동을 막을 수 있습니다.
13. 태스크 함수 이름을 명시적으로 지정하세요. `useTask$()`나 `useVisibleTask$()`를 쓸 때, 익명 화살표 함수 대신 `function initTask()`처럼 이름을 붙인 함수로 정의하세요. 이렇게 하면 호출 스택에 이름이 있는 함수가 생겨서 디버깅이 더 쉬워지고 목적도 명확해집니다.
14. 최적의 반응성을 위해 템플릿에 작업을 바로 넣으세요. 간단한 작업은 외부에서 미리 계산하는 대신 JSX 템플릿 안에서 바로 처리하세요. 이건 Qwik의 최적화 도구가 더 세분화된 반응성을 달성해서 전체 컴포넌트 대신 시그널 값에 따라 특정 DOM 부분만 다시 렌더링할 수 있도록 해줍니다.
15. 시그널 읽기를 `useTask$` 또는 `useComputed$`로 옮기세요. 불필요하게 전체 컴포넌트가 다시 렌더링되도록 하는 경우 컴포넌트 함수 안에서 시그널/스토어 값을 직접 읽는 걸 피하세요. 대신 이런 읽기 작업을 `useTask$()`(사이드 이펙트용)나 `useComputed$()`(파생 값용)로 감싸서 정밀한 업데이트를 보장하세요.
16. `useVisibleTask$()`를 최후의 수단으로 사용하세요. `useVisibleTask$()`는 즉시 실행되고 메인 스레드를 막아서 태스크가 끝날 때까지 사용자 상호 작용을 방해할 수 있어요. 이건 '탈출구' 정도로 생각해야 합니다. SSR 호환 효과에는 `useTask$()`를, 이벤트 리스너에는 `useOn()`/`useOnWindow()`/`useOnDocument()`를 선호하세요. 동기 클라이언트 측 코드가 정말 불가피할 때만 `useVisibleTask$()`를 쓰세요.
17. DOM 이벤트를 선언적으로 또는 `useOn()` 훅으로 등록하세요. `useClientEffect$()`로 이벤트 리스너를 프로그래밍 방식으로 등록하는 걸 피하세요. 이건 JS를 즉시 로딩하게 만들고 수동 정리가 필요해요. 대신 `onClick$` 같은 JSX 속성이나 Qwik의 `useOn()`, `useOnWindow()`, `useOnDocument()` 훅을 사용해서 효율적이고 지연 로드되는 이벤트 처리를 하세요.
18. `window.location` 직접 접근을 피하세요. 컴포넌트 루트나 `useClientEffect$()`에서 위치 정보에 `window.location`을 쓰지 마세요. 이건 클라이언트 측 실행과 즉시 로딩을 강제할 수 있어요. 대신 SSR과 재개 가능성에 최적화된 Qwik City의 `useLocation()` 훅을 사용하세요.
19. React별 속성 대신 `class` 및 `for`를 선호하세요. Qwik은 표준 HTML 속성을 선호합니다. JSX에서 React의 `className` 대신 `class`를, `htmlFor` 대신 `for`를 사용하세요. ESLint 규칙을 통해서 이걸 강제할 수 있습니다.
20. 목록에 `key` 속성을 꼭 넣으세요. `map()`으로 목록을 렌더링할 때 항상 각 항목에 고유한 `key` 속성을 제공하세요. 이건 효율적인 렌더링과 조정에 중요하며, 성능 문제나 예상치 못한 동작을 막아줍니다.
21. 단일 반응형 값에 `useSignal()`을 선택하세요. `useSignal()`을 사용해서 숫자, 문자열, 불리언 같은 단일 기본 값에 대한 반응형 시그널을 만드세요. 이건 `.value` 속성을 가진 객체를 반환하는데, 이 속성이 바뀌면 종속된 컴포넌트가 자동으로 업데이트됩니다.
22. 반응형 객체/배열에 `useStore()`를 선택하세요. 여러 관련된 값이나 복잡한 중첩 데이터 구조를 관리할 때는 `useStore()`가 더 나은 선택입니다. 이건 중첩된 속성을 포함해서 어떤 속성이 바뀌어도 업데이트를 일으키는 반응형 객체를 만들어요.
23. `useStore()` 객체에 대한 참조를 유지하세요. `useStore()`의 경우 항상 반응형 객체에 대한 직접적인 참조를 유지하세요. 속성을 구조 분해한 다음 변경하는 건 피해야 합니다. 이건 Qwik의 반응성 시스템을 우회해서 업데이트를 트리거하지 않아요.
24. 동기 파생 상태에 `useComputed$()`를 사용하세요. 기존 반응형 상태에서 동기적으로 파생될 수 있는 계산된 값(예: 이름과 성에서 전체 이름)에는 `useComputed$()`가 딱이에요. 이건 값을 메모이제이션해서 입력 시그널이 바뀔 때만 다시 계산합니다.
25. 비동기 데이터 가져오기에 `useResource$()`를 사용하세요. 비동기적으로 또는 외부 소스(예: API 호출)에서 데이터를 가져올 때 `useResource$()`를 사용하세요. 이건 리소스의 상태(로딩 중, 해결됨, 거부됨)를 제공하며, 데이터 상태에 따라 UI를 렌더링하는 `<Resource />` 컴포넌트와 잘 통합됩니다.
26. 초기 서버 측 데이터 가져오기에 `routeLoader$()`를 선호하세요. HTTP 요청 수명 주기 초기에 필요한 데이터(예: 초기 페이지 로드 데이터)의 경우 `routeLoader$()`가 일반적으로 `useResource$()`보다 더 좋습니다. 이건 SSR의 일부로 서버에서 데이터가 가져와져서 초기 페이지 콘텐츠를 최적화하도록 보장합니다.
27. 명시적 통신을 위해 `props`를 통해 상태를 전달하세요. 자식 컴포넌트에 상태를 전달하는 가장 간단한 방법은 `props`를 통해 명시적으로 전달하는 겁니다. Qwik 컴포넌트는 반응형이며 `props`가 바뀌면 다시 렌더링돼서 효율적인 데이터 흐름을 가능하게 합니다.
28. 암시적 상태 공유를 위해 Context API를 활용하세요. "prop drilling" 없이 자손 컴포넌트와 상태를 암시적으로 공유하려면 Qwik의 Context API(`createContextId()`, `useContextProvider()`, `useContext()`)를 사용하세요. 이걸로 모든 자손이 공유 상태 참조에 접근할 수 있습니다.
29. 직렬화할 수 없는 데이터에 `noSerialize()`를 사용하세요. 반응형 상태 안에 직렬화할 수 없는 데이터(예: Monaco 에디터 같은 서드파티 라이브러리 인스턴스)를 저장해야 한다면 `noSerialize()`로 감싸세요. 이런 값은 클라이언트에서 `undefined`가 되니까 다시 초기화해야 한다는 걸 기억하세요.
30. 정규 함수로 QRL을 사용해서 스토어 메서드를 정의하세요. `useStore()` 객체에 메서드를 추가할 때 QRL(`$` 사용)로 정의하고 정규 `function(){}` 표현식을 사용하세요. 이건 Qwik의 최적화 도구에 대한 올바른 `this` 바인딩과 직렬화 가능성을 보장합니다.
31. 파일 시스템 기반 라우팅을 채택하세요. Next.js처럼 Qwik City의 파일 시스템 기반 라우팅을 사용해서 앱 경로를 구성하세요. 디렉토리는 URL 세그먼트를 정의하고, `index.tsx`/`mdx` 파일은 페이지를 정의하며, `layout.tsx` 파일은 중첩된 레이아웃이나 미들웨어를 정의합니다.
32. 동적 경로 세그먼트를 활용하세요. 대괄호로 묶인 디렉토리 이름(예: `[id]`, `[...catchall]`)을 사용해서 동적 경로를 구현해서 변동 가능한 URL 매개변수를 처리하세요. 유연한 콘텐츠 전달을 위해 `useLocation().params`로 이런 매개변수에 접근하세요.
33. 페이지와 엔드포인트를 구분하세요. `index.tsx`는 Qwik 컴포넌트를 웹 페이지로 렌더링하는 데 쓰고, `index.ts`는 `onRequest`, `onGet`, `onPost` 등을 내보내서 직접 HTTP 응답(예: RESTful API)을 위해 사용하세요. 이건 관심사를 명확하게 분리할 수 있게 해줍니다.
34. 공유 UI/미들웨어에 중첩 레이아웃을 활용하세요. `layout.tsx` 파일을 사용해서 UI 컴포넌트(예: 헤더/푸터)를 공유하고 경로 그룹 간에 미들웨어 로직(예: 인증, 쿠키 유효성 검사)을 구현하세요. 중첩 레이아웃에서 `onRequest` 메서드의 실행 순서를 이해해야 합니다.
35. `routeLoader$()`로 초기 데이터 로딩을 최적화하세요. 페이지가 렌더링되기 전에 `routeLoader$()`를 사용해서 경로에 필요한 데이터를 가져오세요. 이 훅은 초기 HTTP 요청의 일부로 서버에서 실행돼서 SSR에 데이터가 존재하도록 보장하고, 사용자가 느끼는 로드 시간을 개선합니다.
36. `routeAction$()`으로 폼 제출을 처리하세요. 폼 POST, PUT, DELETE 요청을 처리하려면 `routeAction$()`을 사용하세요. 이건 자바스크립트가 비활성화된 경우에도 폼 데이터가 서버에서 처리되도록 보장하고, 서버 로직과 상호 작용하는 타입 안전한 방법을 제공합니다.
37. Qwik City의 SPA/MPA 유연성을 받아들이세요. Qwik은 SPA와 MPA의 경계를 모호하게 합니다. `<Link>` 컴포넌트를 SPA 탐색에 사용하면 호버 시 다음 페이지를 미리 가져와서 즉각적인 전환을 가능하게 합니다. 전체 페이지 새로 고침에는 `<Link reload>`를 사용하세요.
38. `RequestEvent` 객체로 요청 이벤트를 관리하세요. 모든 미들웨어와 경로 핸들러는 `RequestEvent` 객체를 받습니다. 이 객체의 속성과 유틸리티 함수(예: `cacheControl`, `cookie`, `redirect`, `json`, `sharedMap`)를 사용해서 HTTP 요청과 응답을 효과적으로 제어하세요.
39. 타입 안전 라우팅을 구현하세요. Qwik City의 타입 안전 경로 및 선언적 라우팅 기능을 활용해서 앱 탐색 전반에 걸쳐 타입 안전성을 높이세요. 이건 런타임 오류를 줄이고 개발자 경험을 개선합니다.
40. SEO/현지화를 위해 경로 재작성을 고려하세요. Qwik City의 경로 재작성 기능을 사용해서 여러 경로 이름에 대해 단일 페이지 컴포넌트와 레이아웃을 재사용하세요. 이건 경로 파일을 복제하지 않고 SEO, A/B 테스트 또는 페이지 번역에 유용합니다.
41. 컴포넌트별 스타일에 CSS 모듈을 우선시하세요. Qwik은 Vite를 통해 CSS 모듈을 바로 지원합니다. `.module.css` 파일을 사용하고 이걸 컴포넌트로 가져와서 스타일이 범위 지정되고 필요할 때만 지연 로드되도록 하세요.
42. CSS 클래스에 `class`를 사용하세요. React의 `className` 대신 `class`를 사용해서 CSS 클래스를 적용함으로써 표준 HTML 속성을 따르세요. Qwik은 조건부나 여러 클래스에 대해 배열 및 객체 구문도 지원합니다.
43. CSS-in-JS에 `styled-vanilla-extract`를 활용하세요. 제로 런타임 CSS-in-JS 솔루션을 위해 `styled-vanilla-extract`를 통합하세요. 이걸로 TypeScript로 스타일을 작성하고 정적 추출의 이점을 누릴 수 있으며, 다른 CSS-in-JS 라이브러리에서 흔히 발생하는 런타임 성능 오버헤드를 피할 수 있습니다.
44. 유틸리티 우선 스타일링에 Tailwind CSS를 통합하세요. 유틸리티 우선 접근 방식을 선호한다면 내장된 통합 스크립트를 사용해서 Tailwind CSS를 Qwik 프로젝트에 추가하세요. 이건 앱 스타일링에 매우 구성 가능하고 효율적인 방법을 제공합니다.
45. 범위 지정 CSS에 `useStylesScoped$()`를 사용하세요. 컴포넌트 안에 범위 지정 CSS를 직접 넣으려면 `useStylesScoped$()` 훅을 사용하세요. Qwik은 충돌을 막고 적절한 스타일 캡슐화를 보장하기 위해 선택기에 고유한 이름을 자동으로 붙여줍니다.
46. 범위 지정 스타일 내에서 `:global()` 선택기를 사용하세요. `useStylesScoped$()`가 활성화된 경우 `:global()` 선택기를 사용해서 `<Slot />`을 통해 렌더링된 자식 컴포넌트를 스타일링하거나 필요할 때 범위 지정 스타일에서 벗어나세요.
47. 지연 로드 가능한 스타일에 `useStyles$()`를 활용하세요. 컴포넌트와 독립적으로 지연 로드되어야 하는 스타일(예: SSR 하이드레이션 중 이중 로딩 방지)에는 `useStyles$()`를 사용하세요. CSS 파일을 `?inline` 쿼리 매개변수와 함께 가져오세요.
48. 컴포넌트 스타일링에 전역 스타일시트를 피하세요. 전역 스타일시트는 초기화에는 좋지만 개별 컴포넌트 스타일링에는 사용하지 않는 게 좋습니다. Qwik은 필요한 스타일만 다운로드하도록 최적화되어 있으니, 큰 전역 시트는 모든 스타일을 즉시 로드하게 만들어서 이런 목적을 무효화합니다.
49. Vite와 CSS 전처리기 사용. Qwik은 Vite를 통해 Sass, Less, Stylus 같은 CSS 전처리기를 지원합니다. 전처리기를 설치하기만 하면 Qwik별 플러그인은 필요 없습니다.
50. 컴포넌트에 `<style>` 태그를 인라인하는 것을 피하세요. 컴포넌트 안에 `<style>` 태그를 직접 넣지 마세요. 이건 스타일이 두 번 로드될 수 있어요(SSR 중 한 번, 다시 렌더링 시 한 번). 독립적인 스타일 로드에는 `useStyles$()`를 선호하세요.