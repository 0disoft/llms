1.  Bevy의 ECS 코어 개념을 이해하세요. 엔티티(Entities)는 고유한 ID로, 컴포넌트(Components)는 엔티티에 할당된 원시 데이터로, 시스템(Systems)은 특정 컴포넌트 세트에서 작동하는 Rust 함수로 정의됩니다. 이건 데이터와 로직을 명확히 분리해서 코드 재사용성과 유지보수를 쉽게 해줘요.
2.  데이터 타입을 작고 세분화된 컴포넌트로 나누세요. 예를 들어, 플레이어 엔티티의 건강과 위치를 별개의 컴포넌트로 분리하는 게 좋습니다. 이건 코드 재사용을 장려하고 각 데이터 조각에 독립적으로 접근할 수 있게 해줘요.
3.  시스템 내에서 `Query`를 사용해서 특정 기준과 일치하는 엔티티의 컴포넌트에 접근하고 반복하세요. 컴포넌트 데이터를 수정해야 하면 쿼리는 변경 가능(`&mut`)해야 합니다.
4.  엔티티 생성, 제거, 컴포넌트 추가/제거 같은 구조적 변경은 `Commands`를 통해 지연된 작업으로 처리하세요. 이렇게 해야 다른 시스템이 실행 중일 때 메모리 레이아웃이 바뀌는 걸 막을 수 있습니다.
5.  Bevy 0.15부터 `Query::single` 같은 메서드가 `Result`를 반환하도록 바뀌었으니, 단일 엔티티 쿼리의 오류 처리에 활용하세요.
6.  2025년 1월부터 `Fallible Commands`가 `queue_handled`를 통해 도입되어 명령이 `Result`를 반환할 수 있게 됐으니, 더 정교한 오류 처리 로직을 구현하세요.
7.  `Schedules`(예: `Startup`, `Update`)를 사용해서 시스템 실행 시점과 방식을 제어하세요. `Startup` 시스템은 앱 시작 시 한 번만, `Update` 시스템은 매 프레임마다 실행됩니다.
8.  `Update` 스케줄에 추가된 모든 시스템은 `State` 및 `SystemSet`에 기반한 `run_if` 조건으로 제한해서 불필요한 시스템 실행을 막고 동작의 예측 가능성을 높이세요.
9.  Bevy 0.14에 도입된 `StateScoped Entities`를 활용해서 관련 상태가 종료될 때 엔티티와 그 자식들이 자동으로 제거되도록 하세요. 이렇게 하면 정리 코드가 줄어듭니다.
10. Bevy 0.14에 도입된 `Computed States`와 `Sub-States`를 활용해서 상태를 파생시키거나 중첩시켜서 복잡한 게임 상태 관리를 개선하세요.
11. 특정 `State`에 대한 `OnEnter` 및 `OnExit` 시스템 등록을 함께 배치해서 설정 및 정리 로직의 명확성을 확보하세요.
12. 저장/로드 또는 네트워킹처럼 지속돼야 하는 게임 요소의 경우, 원시 `Entity ID` 대신 `Strong IDs`(예: `QuestId` 같은 사용자 정의 ID 유형)를 사용하는 게 좋습니다.
13. Bevy 0.16부터 Bevy의 ECS에 일대다 엔티티 관계가 내장됐으니, 이걸로 엔티티 간 연결을 쉽고 견고하게 모델링하세요.
14. 가상 지오메트리(실험적) 기능을 활용해서 메시를 '메시릿'으로 전처리해서 명시적인 LOD(Level of Detail) 없이도 방대한 양의 지오메트리를 효율적으로 렌더링하세요. 이건 아주 상세한 대규모 환경에 딱이에요.
15. `VolumetricFog` 및 `VolumetricLight` 컴포넌트를 카메라 및 방향성 조명에 적용해서 사실적인 3D 안개와 멋진 '갓 레이'를 시뮬레이션하고 장면에 깊이와 분위기를 더하세요.
16. `ScreenSpaceReflectionsSettings`를 카메라에 추가해서 실시간 반사를 근사화하고, 부드러운 표면의 시각적 충실도를 높이세요.
17. `MotionBlurBundle`을 카메라에 적용해서 빠르게 움직이는 객체를 흐리게 처리함으로써 시각적 부드러움을 개선하고 속도감을 전달하세요.
18. 포괄적인 `Filmic Color Grading` 도구로 게임의 시각적 스타일을 미세 조정하고, `Auto Exposure`를 활성화해서 장면 밝기에 따라 카메라 노출을 동적으로 조정함으로써 인간의 눈 적응을 모방한 높은 동적 범위 효과를 구현하세요.
19. `DepthOfFieldSettings`를 카메라에 추가해서 특정 초점 범위 밖의 객체를 흐리게 처리함으로써 사실적인 카메라 렌즈 효과를 얻으세요.
20. `StandardMaterial`의 `anisotropy_strength` 및 `anisotropy_rotation`을 활용해서 브러시드 메탈이나 머리카락 같은 표면의 재질 사실감을 높이세요.
21. `Percentage-Closer Filtering (PCF)`을 사용해서 부드러운 점광원 그림자를 구현하고, `Subpixel Morphological Antialiasing (SMAA)`을 사용해서 들쭉날쭉한 가장자리를 제거해서 전반적인 이미지 품질을 높이세요.
22. Bevy 0.16의 향상된 GPU 기반 렌더링 및 오클루전 컬링을 활용해서 더 많은 렌더링 작업을 GPU로 넘기고 가려진 객체를 렌더링하지 않아서 복잡한 장면의 성능을 크게 높이세요.
23. 절차적 대기 산란(Procedural Atmospheric Scattering)을 구현해서 낮은 성능 비용으로 하루 중 언제든 사실적인 지구와 같은 하늘을 시뮬레이션하고 동적인 환경 사실감을 더하세요. (Bevy 0.16)
24. 데칼(Decals)을 사용해서 렌더링된 메시에 동적으로 텍스처를 겹쳐서 총알 자국, 핏자국, 환경 마모 같은 효과를 메시 지오메트리를 수정하지 않고도 구현하세요. (Bevy 0.16)
25. 새로운 순서 독립 투명도 알고리즘을 선택해서 투명 객체의 안정성과 품질을 높이고 일반적인 렌더링 아티팩트를 해결하세요. (Bevy 0.15)
26. `VBAO` (Visibility Bitmask Ambient Occlusion)를 통합해서 앰비언트 오클루전 품질을 개선하고, 색수차를 후처리 효과로 사용해서 사실적인 렌즈 왜곡을 시뮬레이션하세요. (Bevy 0.15)
27. 2D 및 3D 블룸 효과를 위한 새로운 스케일 팩터를 활용해서 아나모픽 블러를 구현하고 조명에 시네마틱한 느낌을 더하세요. (2025년 1월)
28. 가상 지오메트리 생성이 이제 `meshopt` 대신 `METIS`를 사용한다는 점을 알아두세요. (2025년 1월)
29. `RenderAssetBytesPerFrame` (0.14에 도입)을 사용해서 GPU로의 렌더 자산 업로드 속도를 조절해서 대규모 데이터 전송으로 인한 끊김 현상을 방지하고 성능과 자산 표시 지연 사이의 균형을 맞추세요.
30. `NodeBundle` 및 `ButtonBundle`에 `BorderRadius`를 적용해서 UI 노드의 모서리를 둥글게 처리하세요. (Bevy 0.14)
31. `UI Box Shadows`를 Bevy UI 노드에 구현해서 구성 가능한 시각적 깊이와 분리를 제공하고 UI 디자인 가능성을 높이세요. (Bevy 0.15)
32. `UI Node Outline Gizmos`를 사용해서 UI 크기 및 레이아웃 디버깅을 위한 시각적 도구를 활용하세요. (Bevy 0.14)
33. `BackgroundColor`가 `UiImage`와 분리된 점을 활용해서 UI 이미지가 단색 배경을 가질 수 있도록 하고, `UiImage::color`는 이미지 자체에 색조를 적용해서 시각적 스타일링에 더 많은 제어를 제공하세요. (Bevy 0.14)
34. `Improved Text Rendering` (Cosmic Text를 통해)을 활용해서 복잡한 텍스트, 특히 비라틴어 언어 및 양방향 텍스트 렌더링 기능을 크게 향상시키세요. (Bevy 0.15)
35. Bevy 0.15부터 게임패드가 `Entities`로 표현되므로, ECS 내에서 게임패드 입력의 상호 작용 및 관리를 간소화하세요.
36. 2025년 1월 업데이트에서 도입된 `Directional UI Navigation`을 게임패드 컨트롤에 활용하고, 새로운 `InputFocus`와 통합해서 UI 및 비UI 요소에 대한 초기적이고 더 직관적인 내비게이션 경험을 제공하세요.
37. `WinitEvent` 이벤트 스트림(0.14에 도입)을 활용해서 반응형 사용자 경험에 필수적인 입력 이벤트 순서의 정확한 처리를 가능하게 하세요.
38. `leafwing_input_manager` 또는 `Bevy Enhanced Input` 같은 커뮤니티 플러그인을 고려해서 동적 및 상황별 입력 매핑을 구현하고 플레이어가 키를 재지정하고 다양한 장치를 지원할 수 있도록 하세요.
39. `AnimationGraph`(0.14)를 통한 애니메이션 블렌딩을 활용해서 다양한 애니메이션을 부드럽게 블렌딩하고 프로그램적으로 변경할 수 있는 저수준 API를 사용하세요.
40. Bevy 0.15의 일반화된 엔티티 애니메이션, 애니메이션 마스크, 가산 블렌딩, 애니메이션 이벤트를 활용해서 더 정교한 애니메이션 제어 및 게임플레이 로직 통합을 가능하게 하세요.
41. 스킨드 메시 및 모프 타겟에 대한 모션 벡터 지원(0.14)을 활용해서 애니메이션 캐릭터에서도 TAA(Temporal Anti Aliasing) 및 Per-Object Motion Blur가 제대로 작동하도록 하세요.
42. `bevy_tweening` 같은 커뮤니티 애니메이션 플러그인을 탐색해서 컴포넌트 값의 이징 및 트위닝을 구현하거나, `bevy_trickfilm`을 써서 간단한 스프라이트 애니메이션을 구현하세요.
43. `Cargo.toml` 프로필을 구성해서 개발 반복 속도(빠른 컴파일)와 릴리스 성능(최적화된 바이너리)을 최적화하세요. 개발 시에는 `[profile.dev]`에서 `debug = 0`, `strip = "debuginfo"`, `opt-level = 0` 또는 `1`을 사용해서 컴파일 및 링크 시간을 줄이세요.
44. 개발 중에 Bevy의 `dynamic_linking` 기능(`cargo run -F bevy/dynamic_linking`)을 활용해서 변경 시마다 Bevy 및 해당 종속성을 다시 컴파일하는 비용을 피하고 반복 속도를 크게 높이세요.
45. `dynamic_linking`을 사용하지 않는 경우 LLD 또는 mold 같은 더 빠른 링커를 실험해서 링크 시간을 더 줄이세요.
46. 릴리스 빌드의 경우, 최대 성능과 더 작은 바이너리 크기를 위해 `opt-level = 3`, `panic = 'abort'`, `debug = 0`, `strip = "debuginfo"`, `lto = "thin"`을 사용하세요.
47. 릴리스 빌드에서는 `Cargo.toml`에서 `log` 및 `tracing` 기능을 구성해서 높은 로그 수준을 비활성화해서 런타임 성능을 높이세요 (예: `release_max_level_warn` 또는 `release_max_level_off`).
48. Bevy의 내장 핫 리로딩 기능을 활용해서 자산(장면, 텍스처, 메시) 변경 사항을 실행 중인 앱에서 바로 확인하세요. 이건 콘텐츠 생성 및 반복 속도를 높여줍니다.
49. `Gizmos API`를 광범위하게 사용해서 디버깅하세요. 0.14에 도입된 새로운 둥근 상자, 그리드, 좌표축, 조명 기즈모를 포함해서 게임 로직, 콜라이더, 변환을 에디터에서 직접 시각화할 수 있습니다.
50. 2025년 1월에는 `bevy_mod_picking`의 `DebugPickingPlugin`이 업스트림됐으니, 엔티티 피킹 및 포인터 이벤트의 시각적 디버깅을 위한 핵심 기능을 활용하세요.