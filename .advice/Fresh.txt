1.  Fresh의 기본 SSR 원칙을 활용하세요. Fresh는 기본적으로 서버 측 렌더링을 사용해서 초기 콘텐츠를 제공합니다. 이건 검색 엔진 최적화(SEO)와 First Contentful Paint(FCP)를 개선하는 데 아주 중요해요. 페이지의 정적 부분이 빠르게 표시되도록 보장해서 사용자 경험을 향상시킵니다.
2.  클라이언트 측 자바스크립트를 최소화하세요. Fresh의 핵심은 기본적으로 클라이언트에 자바스크립트를 보내지 않는 겁니다. 불필요한 스크립트 로드를 줄여서 페이지 로드 속도를 최고로 만들고, 앱 전반의 성능을 크게 높여줘요.
3.  오류 발생 시 우아한 저하를 설계하세요. Fresh는 오류의 영향 범위를 최소화하고 시스템이 우아하게 작동하도록 설계되었습니다. 이건 앱의 복원력을 높여서, 부분적인 문제가 전체 시스템에 영향을 주지 않도록 합니다.
4.  Fresh의 의견 있는 결정에 따르세요. Fresh는 웹 앱을 만드는 방법에 대해 명확한 기준을 제시합니다. 이런 의견 있는 접근 방식은 개발자가 성능과 안정성을 위해 최적화된 패턴을 자연스럽게 따르도록 이끌어줘요.
5.  상호 작용이 필요한 부분에만 아일랜드를 사용하세요. 아일랜드 아키텍처는 페이지의 특정 상호 작용 영역에만 자바스크립트를 로드합니다. 이건 초기 자바스크립트 번들 크기를 크게 줄여서 페이지 로드 속도를 향상시켜 줍니다.
6.  `islands/` 폴더를 활용해서 아일랜드를 정의하세요. Fresh 프로젝트에서 아일랜드는 `islands/` 폴더 안에 파일을 만들어서 정의됩니다. Fresh는 클라이언트에서 아일랜드를 자동으로 재수화합니다.
7.  아일랜드에 직렬화 가능한 `props`만 전달하세요. 아일랜드에 `props`를 전달할 수 있지만, 원시 타입, 일반 객체, 배열, Uint8Array, JSX 요소 또는 Preact Signals 같은 직렬화 가능한 값만 지원됩니다. Date 객체나 함수 같은 복잡한 객체는 직접 지원되지 않아요.
8.  아일랜드 내에서 컴포넌트를 중첩하세요. 아일랜드는 다른 아일랜드 안에 중첩될 수 있는데, 이 경우 일반 Preact 컴포넌트처럼 작동합니다. 이건 상호 작용 가능한 영역 안에서 컴포넌트 재사용성을 높이는 데 유용해요.
9.  `components/` 디렉터리의 공유 컴포넌트를 활용하세요. `components/` 디렉터리에 있는 공유 컴포넌트는 정적 콘텐츠와 상호 작용 가능한 아일랜드 모두에서 사용될 수 있습니다. `onClick` 핸들러 같은 클라이언트 측 상호 작용은 이런 컴포넌트가 아일랜드 안에서 사용될 때만 작동해요.
10. 클라이언트 전용 API 사용 시 `IS_BROWSER` 플래그를 사용하세요. `EventSource` 또는 `navigator.getUserMedia` 같은 클라이언트 전용 API를 쓰는 컴포넌트에서는 `$fresh/runtime.ts`의 `IS_BROWSER` 플래그를 써서 서버 측 실행을 막아야 합니다. 이건 서버에서 오류가 나는 걸 방지해 줘요.
11. 새로운 플러그인 API에 익숙해지세요. Fresh 2.0은 기존의 복잡한 플러그인 API를 Express/Hono와 비슷한 간단한 자바스크립트 함수 기반 API로 바꿉니다. 이건 Fresh의 많은 기능이 표준 미들웨어로 구현될 수 있도록 해서 내부 일관성을 높여줍니다.
12. 간소화된 미들웨어 시그니처를 활용하세요. Fresh 2.0에서는 `Request` 객체가 `FreshContext` 객체로 옮겨가서 미들웨어 시그니처가 간단해집니다. 이건 미들웨어에서 `Request` 객체를 직접 접근하는 경우가 드물기 때문에 상용구 코드를 줄여줘요.
13. 진정한 비동기 서버 측 컴포넌트를 활용하세요. Fresh 2.0은 Preact의 최신 발전을 활용해서 서버에서 비동기 컴포넌트 렌더링을 기본으로 지원합니다. 이걸로 `useContext` 같은 훅이 비동기 컴포넌트 안에서 제대로 작동해서 Fresh 1.x의 제한 사항이 해결돼요.
14. 통합된 `_error.tsx` 템플릿을 준비하세요. Fresh 2.0에서는 `_500.tsx`와 `_404.tsx` 템플릿이 하나의 `_error.tsx` 파일로 합쳐집니다. 개발자는 이 통합 템플릿 안에서 오류 상태 코드에 따라 조건부 로직을 구현해서 더 유연하게 쓸 수 있습니다.
15. 오류 페이지를 애플리케이션 섹션별로 분리하세요. `_error.tsx` 템플릿은 `routes/` 폴더 안의 다양한 레벨에 둘 수 있어요. 예를 들어, `admin/_error.tsx`를 써서 관리자 섹션에 특화된 오류 페이지를 제공할 수 있습니다.
16. `<Head>` 컴포넌트 제거에 대비하세요. Fresh 2.0에서는 스트리밍 렌더링 기능을 위해 `<Head>` 컴포넌트가 없어지고, 라우트 핸들러에서 `<head>` 요소를 직접 추가하는 새로운 방식이 도입될 예정입니다.
17. Deno의 기본 TypeScript 지원을 활용하세요. Deno는 TypeScript를 기본으로 지원해서 별도 설정 없이 TypeScript 코드를 바로 실행할 수 있습니다. 이건 개발 워크플로우를 간단하게 하고 타입 안전성을 보장해 줘요.
18. Deno의 강력한 보안 모델을 따르세요. Deno는 파일 시스템, 네트워크, 환경 변수 접근에 명시적인 권한을 요구하는 보안 중심 설정을 제공합니다. 앱의 보안 위험을 줄이려면 필요한 최소한의 권한만 주세요.
19. Deno의 내장 툴체인을 활용하세요. Deno는 린터(`deno lint`), 코드 포맷터(`deno fmt`), 테스트 러너(`deno test`) 같은 강력한 내장 툴체인을 제공합니다. 이런 도구들을 써서 외부 의존성 없이 코드 품질을 유지하고 개발 생산성을 높일 수 있습니다.
20. Deno 2.3의 향상된 `deno fmt`를 사용하세요. Deno 2.3(2025년 5월)은 `deno fmt`에 대한 확장된 옵션과 제어 기능을 도입했어요. CSS, HTML, SQL 템플릿 리터럴에 대한 포맷팅 지원은 코드 일관성을 유지하는 데 큰 도움이 됩니다.
21. Deno 2.3의 `using` 키워드를 활용하세요. Deno 2.3(2025년 5월)은 자바스크립트에서도 `using` 키워드를 지원해서 코드 가독성과 리소스 관리를 개선합니다. 이건 깔끔한 코드 작성을 돕고 리소스 누수를 막아줍니다.
22. Deno 2.2의 OpenTelemetry 통합을 탐색하세요. Deno 2.2(2025년 2월)는 OpenTelemetry를 기본으로 지원해서 앱의 관찰 가능성(observability)을 높여줍니다. 요청 추적, 성능 지표, 구조화된 로그 수집을 통해 프로덕션 환경에서 디버깅과 모니터링을 간소화할 수 있습니다.
23. 파일 시스템 라우팅 규칙을 숙지하세요. `routes/` 폴더 안의 파일 이름이 URL 경로에 매핑됩니다. `[slug].ts` 같은 동적 세그먼트와 `[...path].ts` 같은 와일드카드 접미사를 활용해서 유연한 라우팅을 구현하세요.
24. 컴포넌트 공동 배치(co-location)를 활용해서 코드 구조를 최적화하세요. 밑줄로 시작하는 폴더(예: `_components`)는 라우팅 시스템에서 무시됩니다. 이걸로 특정 라우트와 관련된 컴포넌트, 아일랜드, 기타 자산을 함께 배치해서 코드 가독성과 유지 보수성을 높일 수 있습니다.
25. 핸들러 라우트와 하이브리드 라우트를 적절히 사용하세요. API 엔드포인트에는 `Request`와 `Context`를 받아 `Response`를 반환하는 핸들러 라우트를 사용하세요. 서버 측 렌더링과 API 기능을 결합하려면 `handler` 객체 안에 HTTP 동사 이름(예: `GET`, `POST`)을 가진 함수를 사용하는 하이브리드 라우트를 활용하세요.
26. 서버 측 `props`는 항상 `props.data`로 접근하세요. 서버에서 가져와 `props`로 전달된 모든 데이터는 페이지 컴포넌트 안에서 `props.data` 속성을 통해 접근해야 합니다. 이건 데이터 접근의 일관성을 유지해 줍니다.
27. Fresh 2.0의 비동기 서버 측 컴포넌트를 활용해서 데이터 접근을 간소화하세요. Fresh 2.0에서는 진정한 비동기 서버 측 컴포넌트가 도입돼서 `useContext` 같은 훅을 서버 렌더링된 콘텐츠의 데이터 접근 패턴에 바로 활용할 수 있습니다.
28. Preact Signals를 사용해서 반응형 상태를 정의하세요. Signals는 `.value` 속성을 가진 객체로, 이 속성을 통해 실제 상태 값을 저장합니다. Signals는 값이 바뀔 때만 컴포넌트를 자동으로 업데이트해서 효율적인 렌더링을 가능하게 합니다.
29. 전역 상태 관리에 `signal()`과 Preact Context를 사용하세요. 전역 상태를 위해 `signal()` 함수를 써서 상태를 정의하고, `createAppState` 같은 함수 안에 캡슐화하세요. 이걸 Preact Context를 통해 컴포넌트에 노출해서 전역 상태를 공유할 수 있습니다.
30. 지역 컴포넌트 상태에 `useSignal()` 훅을 사용하세요. 개별 컴포넌트의 지역 상태를 관리할 때는 `useSignal()` 훅을 사용하세요. 이건 컴포넌트 수준에서 반응형 상태를 효율적으로 관리하는 데 도움이 됩니다.
31. `computed()` 및 `useComputed()`를 사용해서 파생된 상태를 관리하세요. `computed()` 함수(전역 상태용)와 `useComputed()` 훅(지역 상태용)을 사용해서 기존 Signals에서 파생된 값을 정의하세요. 이건 종속성이 바뀔 때 자동으로 업데이트됩니다.
32. `effect()` 및 `useSignalEffect()`로 사이드 이펙트를 관리하세요. 로컬 스토리지 업데이트 같은 사이드 이펙트는 `effect()` 함수(전역) 또는 `useSignalEffect()` 훅(지역)을 사용해서 관리할 수 있습니다. 이들은 Signal 값 변경에 자동으로 반응합니다.
33. 컴포넌트와 아일랜드의 역할 구분을 명확히 하세요. Fresh에서 "컴포넌트"는 보통 서버에서 렌더링되는 JSX 반환 함수입니다. "아일랜드"는 클라이언트 측 상호 작용 계층의 루트 역할을 하는 격리된 Preact 컴포넌트입니다.
34. 상호 작용이 없는 컴포넌트는 `components/`에 배치하세요. `components/` 디렉터리에 있는 컴포넌트는 정적 콘텐츠와 아일랜드 모두에서 사용될 수 있습니다. 클라이언트 측 상호 작용(예: `onClick` 핸들러)은 이들이 아일랜드 안에서 사용될 때만 활성화됩니다.
35. 아일랜드 내 자식 컴포넌트에 함수를 `props`로 전달하세요. 아일랜드 안에 중첩된 자식 컴포넌트는 함수를 `props`로 받을 수 있습니다. 이건 아일랜드의 상호 작용 범위 안에서 컴포넌트 간 통신을 가능하게 합니다.
36. `IS_BROWSER` 플래그를 사용해서 클라이언트 전용 코드를 보호하세요. `EventSource` 같은 브라우저 전용 API를 쓰는 코드는 `$fresh/runtime.ts`에서 `IS_BROWSER` 플래그로 감싸서 서버 측에서 실행되지 않도록 하세요. 이건 런타임 오류를 방지합니다.
37. `_middleware.ts` 파일을 활용해서 요청을 가로채세요. 미들웨어는 `routes/` 폴더 안에 `_middleware.ts` 파일로 정의됩니다. 이건 요청 및 응답을 수정하거나 검사하는 사용자 정의 로직을 수행하는 데 사용됩니다.
38. 미들웨어를 사용해서 인증 및 권한 부여를 구현하세요. 미들웨어는 세션 ID나 인증 토큰을 확인하고 인증되지 않은 사용자를 리디렉션하는 데 사용될 수 있습니다. Deno 네이티브 라이브러리를 사용해서 OAuth 통합을 지원합니다.
39. `ctx.state`를 사용해서 미들웨어 간 데이터를 전달하세요. 각 미들웨어는 `ctx`(컨텍스트) 인수를 받는데, 여기에는 `next` 함수와 임의의 데이터를 다운스트림 또는 업스트림 핸들러에 전달할 수 있는 `state` 속성이 포함됩니다.
40. 미들웨어의 스코프 및 계층화를 이해하세요. 여러 `_middleware.ts` 파일이 하나의 요청에 적용될 수 있으며, 가장 덜 구체적인 미들웨어가 먼저 실행됩니다. 단일 미들웨어 파일은 핸들러 배열을 내보내 여러 미들웨어를 정의할 수도 있습니다.
41. `ctx.params`를 통해 라우트 매개변수에 접근하세요. 미들웨어는 `ctx.params`를 통해 라우트 매개변수에 접근할 수 있어서 URL 세그먼트를 기반으로 동적 로직을 구현할 수 있습니다.
42. 미들웨어에서 리디렉션을 수행하세요. `Response.redirect()`를 사용해서 미들웨어에서 요청을 리디렉션할 수 있습니다. 307(임시 리디렉션) 또는 301(영구 리디렉션) 같은 적절한 HTTP 상태 코드를 사용하세요.
43. `fresh-logging` 같은 커뮤니티 미들웨어를 활용하세요. 특정 로깅 요구 사항을 위해 `fresh-logging` 같은 커뮤니티 기여 미들웨어를 고려하세요. 이건 구성 가능한 형식, UTC 시간, 응답 지속 시간 추적 기능을 제공합니다.
44. 핸들러 라우트를 사용해서 API 엔드포인트를 구축하세요. `Request`와 `Context` 객체를 인수로 받아 `Response`를 반환하는 함수를 내보내서 핸들러 라우트를 정의하세요. 이건 RESTful API 엔드포인트를 만드는 데 적합합니다.
45. 하이브리드 라우트로 서버 측 렌더링과 데이터 가져오기를 결합하세요. `handler` 객체 안에서 HTTP 동사 이름(예: `GET`, `POST`)을 가진 함수를 사용해서 API 핸들러와 서버 측 렌더링 기능을 결합하세요. 보통 `context.render`의 결과를 반환해서 서버 측 `props`를 페이지 컴포넌트에 전달합니다.
46. 폼 제출 및 동적 요청을 서버 측에서 처리하세요. Fresh는 폼 제출 및 기타 동적 요청을 서버 측에서 처리하는 데 도움이 되는 편리한 도구를 제공합니다. 이건 기본 브라우저 기능을 활용해서 클라이언트 측 자바스크립트의 필요성을 최소화합니다.
47. `Deno.test()` 함수로 테스트를 정의하세요. Deno는 `Deno.test()` 함수를 사용해서 테스트를 정의하며, 동기, 비동기, 이름, 함수, 무시, 전용 실행 같은 옵션을 가진 구성된 테스트를 지원합니다.
48. `deno test` 명령어로 테스트를 실행하세요. `deno test` 서브커맨드는 현재 디렉터리 안에서 `*_test.ts` 같은 패턴에 맞는 테스트 파일을 자동으로 찾아서 재귀적으로 실행합니다.
49. `t.step()`으로 테스트 단계를 분할하세요. `t.step()`을 사용해서 복잡한 테스트를 더 작고 관리하기 쉬운 부분으로 나누세요. 이건 테스트 안에서 설정 및 해체 작업에 유용합니다.
50. `--filter` 옵션으로 특정 테스트를 실행하세요. `--filter` 옵션을 사용해서 이름이나 패턴으로 테스트를 필터링할 수 있습니다. Deno 구성 파일을 통해 테스트 파일을 포함하거나 제외할 수도 있습니다.