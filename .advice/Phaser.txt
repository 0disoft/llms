1.  FPS 카운터를 활용하세요. 개발 초기부터 FPS 카운터를 구현해서 다양한 장치에서 성능을 정확하게 측정하세요. 이걸로 병목 현상을 식별하는 객관적인 데이터를 확보할 수 있습니다.
2.  오브젝트 풀링을 구현하세요. 총알이나 적처럼 계속 만들고 없애는 게임 오브젝트 대신 재사용해서 메모리 누수와 가비지 컬렉션으로 인한 일시 정지를 막으세요. 사용하지 않는 오브젝트는 `active = false`로 설정해서 재활용 준비를 해야 합니다.
3.  참조 캐싱을 사용하세요. 자주 접근하는 오브젝트나 데이터에 대한 참조를 캐싱해서 조회 시간을 줄이고 전체 게임 루프의 효율성을 높이세요. 이건 중복 계산을 최소화하는 데 도움이 됩니다.
4.  게임 루프를 최적화하세요. 활성화되거나 화면에 보이는 오브젝트만 처리하고 렌더링하도록 게임 루프를 최적화하세요. 사용하지 않는 스프라이트는 비활성화하고 연결된 트윈이나 파티클 이미터를 중지해야 합니다.
5.  자산을 압축하세요. 이미지(예: Squoosh) 및 오디오 파일(예: ffmpeg)을 압축해서 로딩 시간과 메모리 사용량을 크게 줄이세요. 이건 웹 기반 게임에 특히 중요합니다.
6.  자산 지연 로딩을 사용하세요. 모든 자산을 한 번에 로드하는 대신 특정 장면이나 게임 섹션에 필요할 때만 자산을 로드하세요. 이건 초기 로딩 시간을 개선하는 데 기여합니다.
7.  Canvas와 WebGL 렌더링을 실험하세요. WebGL이 보통 더 빠르지만, Canvas 렌더링으로 바꾸면 오래된 장치나 저사양 모바일 장치에서 성능이 30% 향상될 수 있어요. 대상 사용자층에 맞춰 두 옵션을 모두 테스트해야 합니다.
8.  캔버스 크기 및 해상도를 최적화하세요. 캔버스 크기가 작을수록 CPU와 GPU가 처리하는 픽셀 수가 줄어서 보통 성능이 좋아져요. 게임 해상도와 자산 크기를 여기에 맞춰 조정하는 걸 고려해야 합니다.
9.  최신 Phaser 버전을 유지하세요. 게임 엔진을 최신 Phaser 버전으로 정기적으로 업데이트하세요. 새 릴리스에는 성능 개선 및 버그 수정 사항이 자주 포함되어 있습니다.
10. 다양한 장치에서 테스트하세요. 일관된 성능을 보장하고 장치별 문제를 식별하려면 항상 광범위한 장치, 특히 시장 점유율이 높은 장치에서 게임을 테스트해야 합니다.
11. 스프라이트용 텍스처 아틀라스를 사용하세요. 여러 개의 작은 이미지를 하나의 텍스처 아틀라스로 합쳐서 드로우 콜을 줄이고 렌더링 성능을 최적화하세요. Texture Packer는 Phaser에 대한 기본 지원을 제공합니다.
12. 텍스처 아틀라스 크기를 최적화하세요. 2048x2048 아틀라스를 목표로 하되, 고사양 장치에서는 KTX2 압축과 함께 4096x4048을 고려하고, 지원되지 않을 경우 2048x2048로 폴백하는 전략을 사용하세요. 이건 품질과 호환성을 모두 잡는 방법입니다.
13. KTX2 압축을 활용하세요. 텍스처 아틀라스에 KTX2 압축을 적용해서 메모리 사용량을 줄이고 로딩 시간을 개선하세요. 특히 대용량 아틀라스에 유용하며, WebGL 확장 지원 여부를 확인해야 합니다.
14. Spine2D 애니메이션을 고려하세요. 복잡한 2D 애니메이션의 경우 Spine2D를 쓰는 게 좋습니다. 이건 하나의 텍스처와 JSON 파일로 많은 애니메이션을 처리해서 상당한 공간과 메모리를 절약하고 VRAM 사용량을 줄여줍니다.
15. 전용 장면에서 자산을 미리 로드하세요. 공유되거나 꼭 필요한 게임 자산은 '부트' 또는 '프리로드' 장면에서 미리 로드해야 합니다. 이걸로 게임 플레이 전에 자원이 준비되고 진행률 표시줄을 구현할 수 있습니다.
16. 장면별로 비공유 자산을 로드하세요. 특정 레벨이나 메뉴에만 사용되는 자산은 해당 장면 안에서 로드해야 합니다. 이건 초기 로딩 시간을 줄이고 장면이 끝나면 메모리 정리를 할 수 있게 해줍니다.
17. Phaser의 로더 이벤트를 활용하세요. 로더 이벤트(`onComplete`, `onProgress`)를 받아서 동적인 로딩 바를 만들고 자산 로딩 중에 플레이어에게 피드백을 제공하세요. 이건 사용자 경험을 향상시킵니다.
18. 오디오 스프라이트를 관리하세요. 여러 개의 짧은 사운드 효과를 하나의 파일로 묶는 오디오 스프라이트를 사용해서 HTTP 요청 수를 줄이세요. Phaser의 `SoundManager`는 이걸 효율적으로 재생할 수 있습니다.
19. 게임 요구 사항에 따라 물리 엔진을 선택하세요. 간단하고 빠른 AABB 충돌에는 Arcade Physics를, 제약 조건과 다각형을 포함한 복잡하고 사실적인 전체 바디 물리에는 Matter.js를 고르세요. 같은 스프라이트에 두 시스템을 동시에 쓰지 않도록 주의해야 합니다.
20. 2D 플랫폼 게임을 위해 Arcade Physics를 구성하세요. 플랫폼 게임에서 속도와 사용 편의성을 위해 Arcade Physics를 활용하세요. 게임 설정에서 중력, 월드 경계, 충돌 검사를 구성해야 합니다.
21. 마찰을 이용해서 '미끄러운' 플랫폼을 구현하세요(Arcade Physics). 플레이어가 미끄러져야 하는 플랫폼의 경우 `platform.body.friction.x = 0`으로 설정하세요. 이건 수평 드래그를 효과적으로 없애서 독특한 게임 플레이를 만들 수 있습니다.
22. Matter.js를 통해 고급 상호작용을 활용하세요. 게임에 강체, 복합체, 탄성 충돌 또는 복잡한 모양이 필요하면 Matter.js를 활성화하세요. 사실적인 효과를 위해 복원력, 마찰, 공기 저항 같은 속성을 구성해야 합니다.
23. Matter.js에서 충돌 카테고리를 사용하세요. 비트마스크를 사용해서 충돌 카테고리를 정의하고, 어떤 오브젝트가 상호작용할지 정확하게 제어하고, 관련 없는 바디 간의 불필요한 충돌 검사를 막아서 성능을 최적화하세요.
24. Phaser 4의 새로운 셰이더 시스템을 마스터하세요. Phaser 4용 종합 셰이더 가이드를 활용해서 멋진 시각 효과를 만들고, 후처리 필터를 구현하고, 새로운 WebGL 렌더링 파이프라인('Phaser Beam')을 이해해야 합니다.
25. 셰이더 게임 오브젝트는 신중하게 사용하세요. 강력하지만 셰이더 게임 오브젝트는 렌더링 파이프라인을 방해하고 배치 처리를 막을 수 있습니다. 배경 효과나 특수 마스크에 사용하되, 완전히 배치 처리되는 커스텀 셰이더에는 커스텀 파이프라인을 고려해야 합니다. 이건 성능에 아주 중요해요.
26. Phaser 4에서 마스크 필터를 최적화하세요. Phaser 4에서는 WebGL이 마스크 필터를 사용합니다 (캔버스 렌더러용 Geometry Masks만 있고, Bitmap Masks는 없어졌어요). 스택 가능하며 게임 오브젝트나 텍스처에서 가져올 수 있는 기능을 활용해서 복잡한 시각 효과를 구현하세요.
27. 동적 콘텐츠를 위해 렌더 텍스처를 활용하세요. `RenderTexture` (또는 전역 사용을 위한 `DynamicTexture`)를 사용해서 복잡한 오브젝트나 전체 장면을 단일 텍스처에 그리세요. 이건 동적인 시각 효과에 필요한 비용이 많이 드는 GPU 업로드를 줄여서 성능을 최적화합니다.
28. 성능을 위해 텍스트 오브젝트보다 비트맵 텍스트를 우선하세요. 자주 바뀌거나 대량의 텍스트에는 `BitmapText`를 사용해야 합니다. 표준 `Text` 오브젝트는 캔버스 재렌더링 및 GPU 재업로드 때문에 성능 비용이 많이 들 수 있어요. 이건 UI에 중요한 최적화입니다.
29. 그래픽스 오브젝트를 최적화하세요. `Graphics` 오브젝트가 정적이거나 거의 안 바뀐다면 `generateTexture()`를 호출해서 텍스처로 '굽기'하세요. 자주 업데이트되는 그래픽에는 이 방법을 피해야 합니다. 이건 계속 새 텍스처를 만들어서 메모리를 쓰기 때문입니다.
30. 멀티 텍스처 배치 처리를 활용하세요. 지원되는 경우 (Phaser CE 및 이후 버전) 멀티 텍스처 배치 처리를 활성화해서 드로우 콜을 줄여 렌더링 성능을 크게 높이세요. 게임을 프로파일링해서 배치 처리 기회를 찾고 디스플레이 목록을 재정렬해야 합니다.
31. 통합된 입력 처리를 사용하세요. 마우스, 터치, 키보드, 게임패드 입력을 추상화하는 Phaser의 통합 입력 시스템을 활용하세요. `gameObject.setInteractive()`를 사용해서 게임 오브젝트에 입력을 활성화해야 합니다. 이건 교차 장치 호환성을 간단하게 만들어줍니다.
32. 커스텀 히트 영역을 정의하세요. 정확한 입력 감지를 위해 `setInteractive(shape, callback)`와 함께 `Phaser.Geom` 도형(Circle, Ellipse, Polygon)을 사용해서 커스텀 히트 영역을 정의하세요. 이건 경계 상자를 넘어 정확한 상호작용을 보장합니다.
33. 드래그 상호작용을 관리하세요. `setInteractive({ draggable: true })` 또는 `scene.input.setDraggable()`을 사용해서 게임 오브젝트의 드래그를 활성화하세요. `dragstart`, `drag`, `dragend` 이벤트를 받아서 동적인 조작을 구현하세요. 이건 풍부한 상호작용 제어를 제공합니다.
34. 점프를 위한 '체공 시간'을 구현하세요. 플랫폼 게임에서 플레이어가 플랫폼에서 떨어진 후에도 짧은 시간 동안 점프할 수 있는 기회를 제공하세요. `edgeTimer`를 사용해서 땅에서 떨어진 후 짧은 시간(예: 250ms) 안에 점프를 허용해야 합니다. 이건 플레이어의 조작감을 향상시킵니다.
35. 입력 이벤트 리스너를 최적화하세요. `update()` 루프에서 성능에 유의하세요. 터치/마우스 입력의 경우 `pointer.isDown`을 사용해서 계속 검사하고, `pointerdown`/`pointerup` 이벤트를 사용해서 한 번만 발생하는 작업을 처리해서 과도한 처리를 피하세요. 이건 성능 병목 현상을 막아줍니다.
36. 장면(Scene)으로 모듈화하세요. 게임을 논리적인 `Scene`으로 나누세요 (예: 로딩, 메인 메뉴, 게임 레벨, 보스전). 각 장면은 자체 입력, 트윈, 게임 오브젝트를 포함하는 독립적인 단위가 될 수 있습니다. 이건 모듈성과 재사용성을 촉진합니다.
37. 공유 리소스를 위한 전역 관리자를 활용하세요. `Renderer`, `Animation Manager`, `Cache`, `Registry`, `Input Manager`, `Scene Manager`, `Device Inspector`, `Sound Manager`, `TimeStep`이 전역임을 이해하고, 장면 간에 공유되는 데이터 및 리소스를 위해 이들을 사용하세요. 이건 데이터 중복을 막아줍니다.
38. 장면 간 데이터 교환을 위한 레지스트리를 활용하세요. 장면 간 쉬운 데이터 교환을 위해 전역 `Registry`를 사용하세요. 이건 장면이 직접적인 종속성 없이 공유 게임 상태에 접근하고 수정할 수 있도록 합니다. 이건 전역 게임 데이터를 위한 견고한 메커니즘입니다.
39. `init`를 통해 장면으로 데이터를 전달하세요. 장면을 시작하거나 전환할 때 필요한 데이터를 `init` 메서드를 통해 전달하세요. 이건 장면이 활성화될 때 필요한 구성이나 게임 상태를 받도록 보장합니다. 이건 장면 초기화를 위한 깔끔한 패턴입니다.
40. 게임 오브젝트 팩토리 및 크리에이터를 활용하세요. `Phaser.GameObjects.GameObjectFactory` 및 `Phaser.GameObjects.GameObjectCreator`를 사용해서 게임 오브젝트를 효율적으로 만들고 관리하고, 필요에 따라 커스텀 로직으로 확장하세요. 이건 오브젝트 인스턴스화를 간단하게 만들어줍니다.
41. 아이프레임을 통해 자바스크립트 프레임워크와 통합하세요. UI와 앱 로직을 위해 React, Vue, Svelte 같은 프레임워크와 통합할 때 Phaser 게임을 iframe 안에 넣으세요. 이건 캡슐화, 격리, 최적화된 로딩을 보장합니다.
42. `postMessage`를 통해 아이프레임 통신을 하세요. `window.postMessage`를 사용해서 메인 앱과 iframe 안의 Phaser 게임 간에 데이터를 주고받으세요. 이건 교차 출처 통신을 위한 안전하고 권장되는 방법입니다. 초기 데이터에는 쿼리 매개변수도 쓸 수 있어요.
43. Phaser Editor를 통해 시각적 레이아웃을 활용하세요. Phaser Editor의 시각적 도구를 사용해서 드래그 앤 드롭 장면 레이아웃, 오브젝트 조작, 실시간 속성 편집을 하세요. 이건 IDE와 통합되는 소스 코드를 만들어서 장면 생성을 간단하게 만들어줍니다.
44. 현대 빌드 도구를 활용하세요. Phaser의 업데이트된 템플릿에서 지원하는 Vite (v6.3.x), ESBuild, Webpack, Rollup, Parcel 같은 최신 빌드 도구를 사용하세요. 이건 개발 및 배포 과정을 간단하게 만들어줍니다.
45. Electron을 통해 Steam 웹 게임을 퍼블리싱하세요. Electron을 써서 Phaser 웹 게임을 데스크톱 앱으로 만들어서 Steam 같은 플랫폼에서 더 많은 사용자에게 도달하세요. 이건 브라우저를 넘어 배포 채널을 확장합니다.
46. Phaser Debug Tool 확장 프로그램을 활용하세요. Chrome/Firefox용 Phaser Debug Tool 확장 프로그램을 설치해서 실행 중인 게임을 실시간으로 확인하고 수정하세요. 이 도구는 FPS 미터, 장면/디스플레이 목록 검사, 속성 편집 기능을 제공합니다. 라이브 디버깅에 아주 유용합니다.
47. 점진적 디버깅을 활용하세요. 게임 기능을 하나씩 비활성화하면서 성능 병목 현상을 찾으세요. `create()` 및 `update()` 함수 실행 후, 그리고 오디오 없이 테스트해서 지연의 원인을 정확히 찾아야 합니다. 이 체계적인 접근 방식은 문제를 분리하는 데 도움이 됩니다.
48. 브라우저 개발자 도구를 활용하세요. Firefox의 캔버스 도구 같은 브라우저 내장 도구를 사용해서 드로우 콜 스냅샷을 찍고 프레임별 렌더링 성능을 분석하세요. 드로우 콜을 줄여 CPU/GPU 효율성을 높여야 합니다. 이건 렌더링에 대한 깊은 통찰력을 줍니다.
49. 커스텀 플러그인을 탐색하세요. Phaser 커뮤니티는 등각 투영 뷰 및 경로 찾기부터 UI 요소 및 파티클 편집기에 이르기까지 다양한 기능을 위한 풍부한 플러그인 생태계를 제공합니다. 이걸 활용해서 Phaser 기능을 확장하세요. 개발 시간을 절약할 수 있습니다.
50. Phaser 커뮤니티에 참여하세요. 활발한 Phaser 포럼(phaser.discourse.group)을 활용해서 지원을 받고, 피드백을 얻으며, 새로운 개발 소식을 접하세요. 커뮤니티 토론은 공식 문서에서 찾을 수 없는 해결책과 통찰력을 주는 경우가 많습니다.