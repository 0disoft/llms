1.  Deno의 통합 도구 체인을 활용해서 단순성을 확보하세요. Deno의 '배터리 포함' 철학은 내장된 린터, 포맷터, 테스트 러너, 컴파일러를 제공해서 복잡한 구성이나 외부 종속성이 필요 없게 해줍니다.
2.  `deno lint`, `deno fmt`, `deno test`를 개발 워크플로우 및 CI/CD 파이프라인에 바로 통합하세요. 이건 프로젝트 설정을 간단하게 하고 팀 전체에서 일관된 코드 품질을 보장합니다.
3.  `deno.json`을 사용해서 중앙 집중식 프로젝트 구성을 관리하세요. `deno.json` 또는 `deno.jsonc` 파일 안에 TypeScript 컴파일러 옵션, 린팅 규칙, 서식 지정 기본 설정, 작업을 구성하세요.
4.  `deno fmt --check` 및 `deno lint`로 코드 품질을 자동화하세요. `deno fmt --check`를 사전 커밋 훅이나 CI/CD 파이프라인에 통합해서 파일을 수정하지 않고도 일관된 코드 서식을 적용하세요.
5.  Deno의 내장 테스트 러너를 마스터해서 강력한 코드를 만드세요. `Deno.test()`를 사용해서 동기 및 비동기 테스트를 작성하고, `@std/assert` 또는 `@std/expect`를 사용해서 어설션을 활용하세요.
6.  `새니타이저`(sanitizeResources, sanitizeOps, sanitizeExit)를 사용해서 테스트 신뢰성을 보장하고 미묘한 버그를 잡으세요. 이건 테스트 중에 리소스 누수, 대기 중인 비동기 작업, 예기치 않은 종료를 막아줍니다.
7.  문서 테스트를 활용해서 '살아있는' 문서를 만드세요. JSDoc 주석이나 Markdown 파일 안에 코드 스니펫을 바로 작성하고 `deno test --doc`을 사용해서 테스트로 실행하세요.
8.  `deno compile`을 사용해서 독립 실행형 실행 파일을 만드세요. `deno compile`을 사용해서 Deno 앱을 독립 실행형 바이너리로 컴파일하고, 대상 시스템에 Deno가 설치되어 있지 않아도 배포할 수 있게 하세요.
9.  더 넓은 도달 범위를 위해 교차 컴파일을 사용하세요. `deno compile`과 함께 `--target` 플래그를 사용해서 단일 개발 환경에서 다양한 운영체제 및 아키텍처(예: Windows, macOS, Linux, ARM64)용 실행 파일을 만드세요.
10. 동적 모듈을 위해 `--include`를 사용해서 `deno compile`을 최적화하세요. 컴파일할 때, `deno compile`이 정적으로 분석할 수 없는 동적으로 임포트된 모듈이나 데이터 파일을 `--include <path>` 플래그를 사용해서 명시적으로 포함하세요.
11. 새 모듈을 게시할 때는 JSR(JavaScript Registry)을 우선적으로 사용하세요. JSR은 TypeScript를 기본으로 지원하고 문서 및 `.d.ts` 파일을 자동으로 생성해서 유형이 지정된 모듈의 작성 및 사용을 간단하게 만듭니다.
12. 안정성을 위해 버전 고정을 사용해서 URL 가져오기를 활용하세요. 버전 지정자(예: `https://deno.land/std@0.181.0/http/server.ts`)를 포함해서 URL에서 바로 모듈을 가져오세요.
13. 가져오기를 단순화하기 위해 `deno.json`에서 가져오기 맵을 사용하세요. `deno.json` 파일의 `imports` 필드를 사용해서 원격 모듈 URL 관리를 중앙 집중화하세요.
14. 올바른 `nodeModulesDir` 모드(none, auto, manual)를 이해하고 선택하세요. 새로운 Deno 우선 프로젝트의 경우 `none`(글로벌 캐시)이 권장됩니다.
15. 기존 npm 패키지에 `npm` 지정자를 선호하세요. npm 패키지를 쓸 때, `npm:` 지정자(예: `import express from "npm:express@4"`)로 바로 가져오세요.
16. CommonJS 상호 운용성 및 권한에 유의하세요. Deno는 CommonJS 모듈을 지원하지만, 파일 시스템 탐색을 위해 `--allow-read` 권한이 필요한 경우가 많습니다. 자체 코드에서는 ES 모듈을 선호하세요.
17. 간소화된 종속성 추가를 위해 `deno add`를 활용하세요. `deno add` 명령(예: `deno add jsr:@std/cli`)을 사용해서 `deno.json` 파일에 새 종속성을 빠르게 추가하세요.
18. 제로 구성 개발을 위해 네이티브 TypeScript 지원을 활용하세요. Deno는 TypeScript, JSX, 최신 ECMAScript 기능에 대한 네이티브, 제로 구성 지원을 제공합니다.
19. 유형이 지정되지 않은 npm 패키지에 `@ts-types` 지시문을 사용하세요. 자체 TypeScript 유형이 없는 npm 패키지의 경우, `// @ts-types="npm:@types/package-name"` 지시문을 사용해서 유형 정의를 제공하세요.
20. Node.js 전역 유형에 `@types/node`를 포함하세요. Deno 프로젝트가 Node.js 내장 모듈이나 Node.js 특정 전역 유형(예: `Buffer`)에 의존하는 npm 패키지를 쓴다면, 진입 파일에 `/// <reference types="npm:@types/node" />`를 추가하세요.
21. 로컬 디버깅을 위해 V8 Inspector 플래그를 사용하세요. `--inspect`, `--inspect-wait`, `--inspect-brk` 플래그를 사용해서 Deno 앱을 실행하세요. `--inspect-brk`는 보통 실행을 시작할 때 일시 중지하므로 권장됩니다.
22. 원활한 디버깅을 위해 VS Code Deno 확장과 통합하세요. 최적화된 디버깅 경험을 위해 공식 `vscode_deno` 확장을 사용하세요.
23. 성능 프로파일링을 위해 `Deno.memoryUsage()` 및 `--strace-ops`를 활용하세요. `Deno.memoryUsage()`를 사용해서 Deno 프로세스 및 V8 하위 시스템의 메모리 소비를 확인하세요.
24. 프로덕션 관찰성을 위해 OpenTelemetry를 활성화하세요. Deno는 OpenTelemetry를 기본적으로 지원해서 HTTP 요청 추적, 런타임 메트릭, 콘솔 로그를 제로 구성으로 수집할 수 있습니다.
25. 최소 권한 원칙에 따라 운영하세요. Deno는 기본적으로 안전합니다. 프로그램은 명시적으로 부여되지 않는 한 파일, 네트워크, 환경 변수에 접근할 수 없어요.
26. 프로덕션에서 `--allow-all (-A)`을 피하세요. `--allow-all` 플래그는 Deno의 보안 샌드박스를 완전히 비활성화해서 모든 시스템 I/O에 대한 완전한 접근을 허용합니다. 이건 프로덕션에서는 절대 쓰지 마세요.
27. `--allow-run` 및 `--allow-ffi`에 주의하세요. `--allow-run` (하위 프로세스 실행) 또는 `--allow-ffi` (외부 함수 인터페이스)를 부여하면 Deno의 보안 샌드박스가 사실상 무효화됩니다.
28. 특정 `--allow-read` 및 `--allow-write` 경로를 사용하세요. 넓은 파일 시스템 접근을 허용하는 대신, 앱이 읽거나 써야 하는 정확한 파일 또는 디렉터리만 지정하세요(예: `--allow-read=./data,./config`).
29. `--allow-net` 호스트 이름으로 네트워크 액세스를 화이트리스트에 추가하세요. 네트워크 요청을 할 때, 허용된 호스트 이름이나 IP 주소의 쉼표로 구분된 목록을 제공하세요(예: `--allow-net=api.example.com,cdn.example.com`).
30. `--allow-env` 이름으로 환경 변수 액세스를 제한하세요. 앱에 필요한 변수 이름만 지정해서 환경 변수 액세스를 제한하세요(예: `--allow-env=API_KEY,DATABASE_URL`).
31. 액세스를 명시적으로 금지하려면 `--deny` 플래그를 사용하세요. 중요한 리소스의 경우, `--allow` 플래그와 `--deny` 플래그를 결합해서 더 정확한 보안 정책을 만드세요.
32. 효율적인 HTTP 서버를 위해 `Deno.serve`를 활용하세요. Deno의 내장 `Deno.serve` API는 HTTP/1.1 및 HTTP/2를 기본으로 지원하는 빠르고 편리한 웹 서버 구축 방법을 제공합니다.
33. 웹 표준 `Request`/`Response` 객체를 받아들이세요. Deno는 HTTP 처리에 `Request` 및 `Response` 객체 같은 최신 웹 API를 사용해서 브라우저 표준과 일치시킵니다.
34. 강력한 요청 본문 처리 및 스트림 취소를 구현하세요. 요청 본문(예: `req.text()`, `req.json()`)을 읽을 때 클라이언트 연결 해제를 예상하고 잠재적인 오류를 처리해서 서버 충돌을 막으세요.
35. 내장 HTTPS 지원으로 웹 서비스를 보호하세요. `cert` 및 `key` 인수를 `Deno.serve`에 제공해서 HTTPS를 활성화하세요.
36. 복잡한 미들웨어 기반 웹 서비스에 Oak를 고려하세요. 더 표현적이고 구조화된 웹 서버 개발, 특히 미들웨어가 필요하다면 Deno는 Oak 프레임워크 사용을 권장합니다.
37. 코드 이식성을 위해 웹 표준 API를 우선적으로 사용하세요. Deno는 TC39 및 WinterCG에 적극적으로 참여해서 웹 표준과 일치시키고, `fetch`, `WebSocket`, `URL`, `Web Workers` 같은 친숙한 브라우저 API를 서버에 구현합니다.
38. 성능에 중요한 작업에 WebAssembly(Wasm)를 탐색하세요. Deno는 WebAssembly를 지원해서 웹 앱 성능을 높이는 방법을 제공합니다.
39. 효율적인 데이터 처리를 위해 웹 스트림을 활용하세요. Deno가 데이터 처리에 웹 표준 스트리밍 API를 쓰는 건 대량의 데이터를 처리하는 명확하고 효율적인 방법을 제공합니다.
40. Fresh의 아일랜드 아키텍처로 빠른 웹 애플리케이션을 만드세요. Deno의 서버 렌더링 웹 프레임워크인 Fresh를 활용하세요. 이건 기본적으로 브라우저에 자바스크립트를 전혀 안 보내고, 아일랜드 기반 아키텍처를 통해 필요한 곳에서만 하이드레이션합니다.
41. Fresh에서 강력한 데이터 처리를 위해 서버 측 양식을 활용하세요. Fresh 경로 안에서 서버에서 바로 양식 제출 및 기타 동적 요청을 처리하세요.
42. 동적 업데이트를 위해 Fresh Partials로 HTML 스트리밍을 구현하세요. Fresh Partials를 사용해서 전체 페이지를 다시 로드할 필요 없이 HTML을 페이지에 바로 가져와서 넣으세요.
43. Fresh 2.0 개발에 대한 최신 정보를 확인하세요. Fresh 2.0은 기본 사항을 제대로 구현하는 데 중점을 두고 활발히 개발 중입니다.
44. Deno KV의 효과적인 사용을 하세요. 특정하고 전역적으로 일관된 키-값 요구 사항에 `Deno KV`를 사용하세요. 이건 제로 설정, 전역적으로 일관된 키-값 저장소입니다.
45. 일반적인 목적의 데이터베이스가 아닌 `Deno KV`의 한계를 이해하세요. `Deno KV`는 대부분의 앱에서 기존 관계형 DB를 대체하도록 설계되지 않았습니다. 복잡한 데이터 모델의 경우 외부 관계형 DB를 계획하세요.
46. 큐와 함께 `Deno KV`를 쓸 때 멱등성(Idempotency)을 고려해서 설계하세요. 큐와 `Deno KV`를 같이 쓸 때, 메시지가 '최소 한 번' 전달되도록 보장되므로 큐 핸들러가 멱등성을 갖도록 해야 합니다.
47. `Deno Cron`을 사용해서 작업 자동화를 하세요. 서버리스 환경을 위해 `Deno.cron`으로 백그라운드 작업을 예약하세요.
48. `Deno.cron` 작업을 최상위 모듈 범위에 정의하세요. 모든 `Deno.cron` 작업은 모듈의 최상위 수준에 정의되어야 합니다. 중첩된 정의는 오류를 발생시키거나 무시됩니다.
49. `Deno Queues`로 무겁거나 비동기적인 워크로드를 오프로드하세요. `Deno Queues` (`Deno.Kv`의 일부)를 활용해서 더 큰 워크로드를 오프로드하거나 나중에 비동기 처리를 위해 작업을 예약하세요.
50. `Deno Deploy`를 통한 간소화된 배포를 하세요. 완전 관리형 서버리스 호스팅을 위해 `Deno Deploy`를 활용하세요. 이건 내장 KV, 큐, cron을 통해 웹 앱 및 API를 위한 전역 분산형 완전 관리형 서버리스 솔루션을 제공합니다.